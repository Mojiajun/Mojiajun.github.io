<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="C++,">










<meta name="description" content="反汇编与逆向分析技术揭秘第十一章虚函数阅读及用x86-64-g++平台分析 这篇主要是构造函数和析构函数和vtbl,vptr的联系.(就是把反汇编与逆向分析技术揭秘第十一章虚函数11.1节用x86-64 linux ATT汇编格式过了一遍…) 这篇还没涉及继承… [TOC] 构造函数和vptr 123456789101112131415161718#include &amp;lt;cstdio&amp;gt;cl">
<meta name="keywords" content="C++">
<meta property="og:type" content="article">
<meta property="og:title" content="C++-虚函数机制-02">
<meta property="og:url" content="https://mojiajun.github.io/post/a24c8ee4.html">
<meta property="og:site_name" content="mojiajun">
<meta property="og:description" content="反汇编与逆向分析技术揭秘第十一章虚函数阅读及用x86-64-g++平台分析 这篇主要是构造函数和析构函数和vtbl,vptr的联系.(就是把反汇编与逆向分析技术揭秘第十一章虚函数11.1节用x86-64 linux ATT汇编格式过了一遍…) 这篇还没涉及继承… [TOC] 构造函数和vptr 123456789101112131415161718#include &amp;lt;cstdio&amp;gt;cl">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2019-07-22T14:46:38.568Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="C++-虚函数机制-02">
<meta name="twitter:description" content="反汇编与逆向分析技术揭秘第十一章虚函数阅读及用x86-64-g++平台分析 这篇主要是构造函数和析构函数和vtbl,vptr的联系.(就是把反汇编与逆向分析技术揭秘第十一章虚函数11.1节用x86-64 linux ATT汇编格式过了一遍…) 这篇还没涉及继承… [TOC] 构造函数和vptr 123456789101112131415161718#include &amp;lt;cstdio&amp;gt;cl">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://mojiajun.github.io/post/a24c8ee4.html">





  <title>C++-虚函数机制-02 | mojiajun</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">mojiajun</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://mojiajun.github.io/post/a24c8ee4.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mojiajun">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mojiajun">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">C++-虚函数机制-02</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-07-22T00:00:00+08:00">
                2019-07-22
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>反汇编与逆向分析技术揭秘第十一章虚函数<br>阅读及用x86-64-g++平台分析</p>
<p>这篇主要是构造函数和析构函数和vtbl,vptr的联系.(就是把反汇编与逆向分析技术揭秘第十一章虚函数11.1节用x86-64 linux ATT汇编格式过了一遍…)</p>
<p>这篇还没涉及继承…</p>
<p>[TOC]</p>
<h3 id="构造函数和vptr"><a href="#构造函数和vptr" class="headerlink" title="构造函数和vptr"></a>构造函数和vptr</h3><hr>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CVirtual</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">GetNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> _nNumber;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SetNumber</span><span class="params">(<span class="keyword">int</span> nNumber)</span> </span>&#123;</span><br><span class="line">      _nNumber = nNumber;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> _nNumber;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CVirtual testObj;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disassemble main</span><br><span class="line">Dump of assembler code for function main():</span><br><span class="line">   0x000055555555475a &lt;+0&gt;:	push   %rbp</span><br><span class="line">   0x000055555555475b &lt;+1&gt;:	mov    %rsp,%rbp</span><br><span class="line">   0x000055555555475e &lt;+4&gt;:	sub    $0x20,%rsp</span><br><span class="line">   0x0000555555554762 &lt;+8&gt;:	mov    %fs:0x28,%rax</span><br><span class="line">   0x000055555555476b &lt;+17&gt;:	mov    %rax,-0x8(%rbp)</span><br><span class="line">   0x000055555555476f &lt;+21&gt;:	xor    %eax,%eax</span><br><span class="line">   0x0000555555554771 &lt;+23&gt;:	lea    -0x20(%rbp),%rax</span><br><span class="line">=&gt; 0x0000555555554775 &lt;+27&gt;:	mov    %rax,%rdi</span><br><span class="line">   0x0000555555554778 &lt;+30&gt;:	callq  0x5555555547c2 &lt;CVirtual::CVirtual()&gt;</span><br><span class="line">   0x000055555555477d &lt;+35&gt;:	mov    $0x0,%eax</span><br><span class="line">   0x0000555555554782 &lt;+40&gt;:	mov    -0x8(%rbp),%rdx</span><br><span class="line">   0x0000555555554786 &lt;+44&gt;:	xor    %fs:0x28,%rdx</span><br><span class="line">   0x000055555555478f &lt;+53&gt;:	je     0x555555554796 &lt;main()+60&gt;</span><br><span class="line">   0x0000555555554791 &lt;+55&gt;:	callq  0x555555554630 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">   0x0000555555554796 &lt;+60&gt;:	leaveq</span><br><span class="line">   0x0000555555554797 &lt;+61&gt;:	retq</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x $rax  # testObj对象地址</span><br><span class="line">0x7fffffffe470:	0xe0</span><br><span class="line">(gdb) info vtbl testObj</span><br><span class="line">vtable for &apos;CVirtual&apos; @ 0x5555555547e0 (subobject @ 0x7fffffffe470):</span><br><span class="line">[0]: 0x41d7894956415741</span><br><span class="line">[1]: 0x586258d4c544155</span><br><span class="line"># @ 0x5555555547e0是不能用的.因为还没有执行完callq  0x5555555547c2 &lt;CVirtual::CVirtual()&gt;,</span><br><span class="line"># 只有当执行完&lt;CVirtual::CVirtual()&gt;,才算是完整的构造好了对象.否则,别用gdb info vtbl.</span><br><span class="line"># 构造完成之后调用info vtbl testObj的结果,发现@ 0x555555754d98才是vptr正确的值!!!</span><br><span class="line">(gdb) info vtbl testObj</span><br><span class="line">vtable for &apos;CVirtual&apos; @ 0x555555754d98 (subobject @ 0x7fffffffe470):</span><br><span class="line">[0]: 0x555555554798 &lt;CVirtual::GetNumber()&gt;</span><br><span class="line">[1]: 0x5555555547aa &lt;CVirtual::SetNumber(int)&gt;</span><br></pre></td></tr></table></figure>
<p>在callq  0x5555555547c2 <a href="CVirtual::CVirtual()" target="_blank" rel="noopener">CVirtual::CVirtual()</a>之前,需要把testObj的地址(处于对象已经有内存了,但是vptr还没初始化的状态,即[半完成品]对象)放入%rdi.这个地方调用的合成的默认构造函数.也就是在callq CVirtual::CVirtual(),需要先拿到this指针送到%rdi寄存器.</p>
<p>然后是合成的默认构造函数内容:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disassemble 0x5555555547c2</span><br><span class="line">Dump of assembler code for function CVirtual::CVirtual():</span><br><span class="line">   0x00005555555547c2 &lt;+0&gt;:	push   %rbp</span><br><span class="line">   0x00005555555547c3 &lt;+1&gt;:	mov    %rsp,%rbp</span><br><span class="line">   0x00005555555547c6 &lt;+4&gt;:	mov    %rdi,-0x8(%rbp)  #把%rdi里面的this指针存到-0x8(%rbp)</span><br><span class="line">   0x00005555555547ca &lt;+8&gt;:	lea    0x2005c7(%rip),%rdx        # 0x555555754d98 &lt;_ZTV8CVirtual+16&gt;          # 把0x555555754d98这个虚函数表的地址送到%rdx</span><br><span class="line">   0x00005555555547d1 &lt;+15&gt;:	mov    -0x8(%rbp),%rax</span><br><span class="line">   0x00005555555547d5 &lt;+19&gt;:	mov    %rdx,(%rax)  # 把虚函数表地址0x555555754d98填入this指针的对象的前8个字节(也即存入虚表指针里).</span><br><span class="line">   0x00005555555547d8 &lt;+22&gt;:	nop</span><br><span class="line">   0x00005555555547d9 &lt;+23&gt;:	pop    %rbp</span><br><span class="line">   0x00005555555547da &lt;+24&gt;:	retq</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>
<p>这个合成的默认构造函数只干了一件事,那就是把class CVirtual的虚表地址填入对象的vptr指针.</p>
<p>不管testObj对象创建不创建.class CVirtual的虚表在程序加载好了之后就在内存里了.<br>通过x/16xb 0x555555754d98(虚表地址)就能查看虚表的内容.一个类的多个不同对象是共享同一张虚表的.只需要在调用构造函数的时候把虚表地址填入对象的vptr即可.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/16xb 0x555555754d98</span><br><span class="line">0x555555754d98 &lt;_ZTV8CVirtual+16&gt;:	0x98	0x47	0x55	0x55	0x55	0x55	0x00	0x00</span><br><span class="line">0x555555754da0 &lt;_ZTV8CVirtual+24&gt;:	0xaa	0x47	0x55	0x55	0x55	0x55	0x00	0x00</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="object直接调用-用’-’"><a href="#object直接调用-用’-’" class="headerlink" title="object直接调用(用’.’)"></a>object直接调用(用’.’)</h3><p>如果是testObj.SetNumber(200)和testObj.GetNumber()</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CVirtual testObj;</span><br><span class="line">    testObj.SetNumber(<span class="number">200</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\r\n"</span>, testObj.GetNumber());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disassemble main</span><br><span class="line">Dump of assembler code for function main():</span><br><span class="line">   0x00005555555547aa &lt;+0&gt;:	push   %rbp</span><br><span class="line">   0x00005555555547ab &lt;+1&gt;:	mov    %rsp,%rbp</span><br><span class="line">   0x00005555555547ae &lt;+4&gt;:	sub    $0x20,%rsp</span><br><span class="line">=&gt; 0x00005555555547b2 &lt;+8&gt;:	mov    %fs:0x28,%rax</span><br><span class="line">   0x00005555555547bb &lt;+17&gt;:	mov    %rax,-0x8(%rbp)</span><br><span class="line">   0x00005555555547bf &lt;+21&gt;:	xor    %eax,%eax</span><br><span class="line">   0x00005555555547c1 &lt;+23&gt;:	lea    -0x20(%rbp),%rax</span><br><span class="line">   0x00005555555547c5 &lt;+27&gt;:	mov    %rax,%rdi</span><br><span class="line">   0x00005555555547c8 &lt;+30&gt;:	callq  0x555555554842 &lt;CVirtual::CVirtual()&gt;</span><br><span class="line">   0x00005555555547cd &lt;+35&gt;:	lea    -0x20(%rbp),%rax  # this指针放入%rax</span><br><span class="line">   0x00005555555547d1 &lt;+39&gt;:	mov    $0xc8,%esi  # 200放入%esi</span><br><span class="line">   0x00005555555547d6 &lt;+44&gt;:	mov    %rax,%rdi  # %rax中的this指针转移到%rdi </span><br><span class="line">   0x00005555555547d9 &lt;+47&gt;:	callq  0x55555555482a &lt;CVirtual::SetNumber(int)&gt;</span><br><span class="line">   0x00005555555547de &lt;+52&gt;:	lea    -0x20(%rbp),%rax</span><br><span class="line">   0x00005555555547e2 &lt;+56&gt;:	mov    %rax,%rdi</span><br><span class="line">   0x00005555555547e5 &lt;+59&gt;:	callq  0x555555554818 &lt;CVirtual::GetNumber()&gt;</span><br><span class="line">   0x00005555555547ea &lt;+64&gt;:	mov    %eax,%esi</span><br><span class="line">   0x00005555555547ec &lt;+66&gt;:	lea    0xf1(%rip),%rdi        # 0x5555555548e4</span><br><span class="line">   0x00005555555547f3 &lt;+73&gt;:	mov    $0x0,%eax</span><br><span class="line">   0x00005555555547f8 &lt;+78&gt;:	callq  0x555555554670 &lt;printf@plt&gt;</span><br><span class="line">   0x00005555555547fd &lt;+83&gt;:	mov    $0x0,%eax</span><br><span class="line">   0x0000555555554802 &lt;+88&gt;:	mov    -0x8(%rbp),%rdx</span><br><span class="line">   0x0000555555554806 &lt;+92&gt;:	xor    %fs:0x28,%rdx</span><br><span class="line">   0x000055555555480f &lt;+101&gt;:	je     0x555555554816 &lt;main()+108&gt;</span><br><span class="line">   0x0000555555554811 &lt;+103&gt;:	callq  0x555555554680 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">   0x0000555555554816 &lt;+108&gt;:	leaveq</span><br><span class="line">   0x0000555555554817 &lt;+109&gt;:	retq</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>
<p>注意testObj.SetNumber(200)和testObj.GetNumber()的调用都是直接调用,用的<br>callq  0x55555555482a和callq  0x555555554818.</p>
<blockquote>
<p>  直接调用这样不能多态,举一个有继承的例子,override虚函数的例子?</p>
</blockquote>
<p>CVirtual::SetNumber(int)的汇编分析,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disassemble 0x55555555482a</span><br><span class="line">Dump of assembler code for function CVirtual::SetNumber(int):</span><br><span class="line">   0x000055555555482a &lt;+0&gt;:	push   %rbp</span><br><span class="line">   0x000055555555482b &lt;+1&gt;:	mov    %rsp,%rbp</span><br><span class="line">   0x000055555555482e &lt;+4&gt;:	mov    %rdi,-0x8(%rbp)  # 第一个参数this指针放入-0x8(%rbp)</span><br><span class="line">   0x0000555555554832 &lt;+8&gt;:	mov    %esi,-0xc(%rbp)  # %esi是第二个参数,如果是</span><br><span class="line">   													  	# SetNumerber(200),%esi里面就是200</span><br><span class="line">   0x0000555555554835 &lt;+11&gt;:	mov    -0x8(%rbp),%rax  </span><br><span class="line">   0x0000555555554839 &lt;+15&gt;:	mov    -0xc(%rbp),%edx</span><br><span class="line">   0x000055555555483c &lt;+18&gt;:	mov    %edx,0x8(%rax)  # 把第二个参数里面要设置的值放入</span><br><span class="line">   												# 0x8(%rax), 即对象的首地址偏移8个字节的位置.</span><br><span class="line">   												# 即private变量_nNumber的位置.</span><br><span class="line">   0x000055555555483f &lt;+21&gt;:	nop</span><br><span class="line">   0x0000555555554840 &lt;+22&gt;:	pop    %rbp</span><br><span class="line">   0x0000555555554841 &lt;+23&gt;:	retq</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>
<h3 id="object指针-用’-gt-’-和引用-‘ref-’-调用"><a href="#object指针-用’-gt-’-和引用-‘ref-’-调用" class="headerlink" title="object指针(用’-&gt;’)和引用(‘ref.’)调用"></a>object指针(用’-&gt;’)和引用(‘ref.’)调用</h3><p>下面比较下直接对象调用(用’.’)和指针调用和引用调用的区别?</p>
<h4 id="指针调用"><a href="#指针调用" class="headerlink" title="指针调用"></a>指针调用</h4><p>先指针调用分析</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CVirtual</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">GetNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> _nNumber;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SetNumber</span><span class="params">(<span class="keyword">int</span> nNumber)</span> </span>&#123;</span><br><span class="line">      _nNumber = nNumber;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> _nNumber;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CVirtual *ptestObj = <span class="keyword">new</span> CVirtual();</span><br><span class="line">    ptestObj-&gt;SetNumber(<span class="number">200</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\r\n"</span>, ptestObj-&gt;GetNumber());</span><br><span class="line">    <span class="keyword">delete</span> ptestObj;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disassemble main</span><br><span class="line">Dump of assembler code for function main():</span><br><span class="line">   0x00005555555547fa &lt;+0&gt;:	push   %rbp</span><br><span class="line">   0x00005555555547fb &lt;+1&gt;:	mov    %rsp,%rbp</span><br><span class="line">   0x00005555555547fe &lt;+4&gt;:	push   %rbx</span><br><span class="line">   0x00005555555547ff &lt;+5&gt;:	sub    $0x18,%rsp</span><br><span class="line">=&gt; 0x0000555555554803 &lt;+9&gt;:	mov    $0x10,%edi</span><br><span class="line">   0x0000555555554808 &lt;+14&gt;:	callq  0x5555555546c0 &lt;_Znwm@plt&gt;</span><br><span class="line">   0x000055555555480d &lt;+19&gt;:	mov    %rax,%rbx</span><br><span class="line">   0x0000555555554810 &lt;+22&gt;:	movq   $0x0,(%rbx)</span><br><span class="line">   0x0000555555554817 &lt;+29&gt;:	movl   $0x0,0x8(%rbx)</span><br><span class="line">   0x000055555555481e &lt;+36&gt;:	mov    %rbx,%rdi</span><br><span class="line">   0x0000555555554821 &lt;+39&gt;:	callq  0x5555555548b4 &lt;CVirtual::CVirtual()&gt;</span><br><span class="line">   0x0000555555554826 &lt;+44&gt;:	mov    %rbx,-0x18(%rbp)   # this指针</span><br><span class="line">   0x000055555555482a &lt;+48&gt;:	mov    -0x18(%rbp),%rax	  # %rax现在存的是对象的首地址</span><br><span class="line">   0x000055555555482e &lt;+52&gt;:	mov    (%rax),%rax		  # 把对象首地址指向的东西(即vptr)放入rax</span><br><span class="line">   0x0000555555554831 &lt;+55&gt;:	add    $0x8,%rax		  # vptr + 8, </span><br><span class="line">   # 原因在于SetNumber(int)类中声明顺序在GetNumber()后面,所以在vtbl里在GetNumber()后面,</span><br><span class="line">   # 而vtbl是一个个函数指针组成的列表.x86-64一个指针占8字节,所以vptr + 8</span><br><span class="line">   0x0000555555554835 &lt;+59&gt;:	mov    (%rax),%rax		  # 找到位置了,然后把vptr + 8这个位置的对应的函数指针取出来放入rax</span><br><span class="line">   0x0000555555554838 &lt;+62&gt;:	mov    -0x18(%rbp),%rdx</span><br><span class="line">   0x000055555555483c &lt;+66&gt;:	mov    $0xc8,%esi		  # 第二个参数200即0xc8</span><br><span class="line">   0x0000555555554841 &lt;+71&gt;:	mov    %rdx,%rdi		  # this指针送入%rdi</span><br><span class="line">   0x0000555555554844 &lt;+74&gt;:	callq  *%rax # 调用SetNumber(int)</span><br><span class="line">   0x0000555555554846 &lt;+76&gt;:	mov    -0x18(%rbp),%rax</span><br><span class="line">   0x000055555555484a &lt;+80&gt;:	mov    (%rax),%rax   # 把对象首地址指向的东西(即vptr)放入rax</span><br><span class="line">   0x000055555555484d &lt;+83&gt;:	mov    (%rax),%rax   # 把vptr + 0这个位置的对应的函数指针取出来放入rax, 即GetNumber()</span><br><span class="line">   0x0000555555554850 &lt;+86&gt;:	mov    -0x18(%rbp),%rdx</span><br><span class="line">   0x0000555555554854 &lt;+90&gt;:	mov    %rdx,%rdi</span><br><span class="line">   0x0000555555554857 &lt;+93&gt;:	callq  *%rax</span><br><span class="line">   0x0000555555554859 &lt;+95&gt;:	mov    %eax,%esi</span><br><span class="line">   0x000055555555485b &lt;+97&gt;:	lea    0xf2(%rip),%rdi        # 0x555555554954</span><br><span class="line">   0x0000555555554862 &lt;+104&gt;:	mov    $0x0,%eax</span><br><span class="line">   0x0000555555554867 &lt;+109&gt;:	callq  0x5555555546b0 &lt;printf@plt&gt;</span><br><span class="line">   0x000055555555486c &lt;+114&gt;:	mov    -0x18(%rbp),%rax</span><br><span class="line">   0x0000555555554870 &lt;+118&gt;:	mov    $0x10,%esi</span><br><span class="line">   0x0000555555554875 &lt;+123&gt;:	mov    %rax,%rdi</span><br><span class="line">   0x0000555555554878 &lt;+126&gt;:	callq  0x5555555546d0 &lt;_ZdlPvm@plt&gt;</span><br><span class="line">   0x000055555555487d &lt;+131&gt;:	mov    $0x0,%eax</span><br><span class="line">   0x0000555555554882 &lt;+136&gt;:	add    $0x18,%rsp</span><br><span class="line">   0x0000555555554886 &lt;+140&gt;:	pop    %rbx</span><br><span class="line">   0x0000555555554887 &lt;+141&gt;:	pop    %rbp</span><br><span class="line">   0x0000555555554888 &lt;+142&gt;:	retq</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>
<h4 id="引用调用"><a href="#引用调用" class="headerlink" title="引用调用"></a>引用调用</h4><p>引用调用分析,</p>
<p>本来以为这样就会像指针那样间接调用了.没想到不是…C++代码如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CVirtual</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">GetNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> _nNumber;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SetNumber</span><span class="params">(<span class="keyword">int</span> nNumber)</span> </span>&#123;</span><br><span class="line">      _nNumber = nNumber;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> _nNumber;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CVirtual testObj;</span><br><span class="line">    CVirtual &amp;rtestObj = testObj;</span><br><span class="line">    rtestObj.SetNumber(<span class="number">200</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\r\n"</span>, rtestObj.GetNumber());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>反汇编之后,发现这不和object直接调用(用’.’)几乎一样吗…<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disassemble main</span><br><span class="line">Dump of assembler code for function main():</span><br><span class="line">   0x00005555555547aa &lt;+0&gt;:	push   %rbp</span><br><span class="line">   0x00005555555547ab &lt;+1&gt;:	mov    %rsp,%rbp</span><br><span class="line">   0x00005555555547ae &lt;+4&gt;:	sub    $0x30,%rsp</span><br><span class="line">=&gt; 0x00005555555547b2 &lt;+8&gt;:	mov    %fs:0x28,%rax  # ?</span><br><span class="line">   0x00005555555547bb &lt;+17&gt;:	mov    %rax,-0x8(%rbp)</span><br><span class="line">   0x00005555555547bf &lt;+21&gt;:	xor    %eax,%eax</span><br><span class="line">   0x00005555555547c1 &lt;+23&gt;:	lea    -0x20(%rbp),%rax</span><br><span class="line">   0x00005555555547c5 &lt;+27&gt;:	mov    %rax,%rdi</span><br><span class="line">   0x00005555555547c8 &lt;+30&gt;:	callq  0x55555555484a &lt;CVirtual::CVirtual()&gt;</span><br><span class="line">   0x00005555555547cd &lt;+35&gt;:	lea    -0x20(%rbp),%rax  # object地址送入rax</span><br><span class="line">   0x00005555555547d1 &lt;+39&gt;:	mov    %rax,-0x28(%rbp)  # 建立引用rtestObj,即-0x28(%rbp)</span><br><span class="line">   0x00005555555547d5 &lt;+43&gt;:	mov    -0x28(%rbp),%rax  # 下面的代码等同于直接对象调用(用&apos;.&apos;的那种)</span><br><span class="line">   0x00005555555547d9 &lt;+47&gt;:	mov    $0xc8,%esi</span><br><span class="line">   0x00005555555547de &lt;+52&gt;:	mov    %rax,%rdi</span><br><span class="line">   0x00005555555547e1 &lt;+55&gt;:	callq  0x555555554832 &lt;CVirtual::SetNumber(int)&gt;</span><br><span class="line">   0x00005555555547e6 &lt;+60&gt;:	mov    -0x28(%rbp),%rax</span><br><span class="line">   0x00005555555547ea &lt;+64&gt;:	mov    %rax,%rdi</span><br><span class="line">   0x00005555555547ed &lt;+67&gt;:	callq  0x555555554820 &lt;CVirtual::GetNumber()&gt;</span><br><span class="line">   0x00005555555547f2 &lt;+72&gt;:	mov    %eax,%esi</span><br><span class="line">   0x00005555555547f4 &lt;+74&gt;:	lea    0xf9(%rip),%rdi        # 0x5555555548f4</span><br><span class="line">   0x00005555555547fb &lt;+81&gt;:	mov    $0x0,%eax</span><br><span class="line">   0x0000555555554800 &lt;+86&gt;:	callq  0x555555554670 &lt;printf@plt&gt;</span><br><span class="line">   0x0000555555554805 &lt;+91&gt;:	mov    $0x0,%eax</span><br><span class="line">   0x000055555555480a &lt;+96&gt;:	mov    -0x8(%rbp),%rdx</span><br><span class="line">   0x000055555555480e &lt;+100&gt;:	xor    %fs:0x28,%rdx</span><br><span class="line">   0x0000555555554817 &lt;+109&gt;:	je     0x55555555481e &lt;main()+116&gt;</span><br><span class="line">   0x0000555555554819 &lt;+111&gt;:	callq  0x555555554680 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">   0x000055555555481e &lt;+116&gt;:	leaveq</span><br><span class="line">   0x000055555555481f &lt;+117&gt;:	retq</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure></p>
<p>但是改成堆对象后</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CVirtual</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">GetNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> _nNumber;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SetNumber</span><span class="params">(<span class="keyword">int</span> nNumber)</span> </span>&#123;</span><br><span class="line">      _nNumber = nNumber;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> _nNumber;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CVirtual *ptestObj = <span class="keyword">new</span> CVirtual();</span><br><span class="line">    CVirtual &amp;rtestObj = *ptestObj;</span><br><span class="line">    rtestObj.SetNumber(<span class="number">200</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\r\n"</span>, rtestObj.GetNumber());</span><br><span class="line">    <span class="keyword">delete</span> ptestObj;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>反汇编之后,这种和指针调用虚函数的方法一样,都是间接调用,拿到对象的vptr指向的函数指针表里面的某一项.然后调用它.(callq  *%rax)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disassemble main</span><br><span class="line">Dump of assembler code for function main():</span><br><span class="line">   0x00005555555547fa &lt;+0&gt;:	push   %rbp</span><br><span class="line">   0x00005555555547fb &lt;+1&gt;:	mov    %rsp,%rbp</span><br><span class="line">   0x00005555555547fe &lt;+4&gt;:	push   %rbx</span><br><span class="line">   0x00005555555547ff &lt;+5&gt;:	sub    $0x18,%rsp</span><br><span class="line">=&gt; 0x0000555555554803 &lt;+9&gt;:	mov    $0x10,%edi</span><br><span class="line">   0x0000555555554808 &lt;+14&gt;:	callq  0x5555555546c0 &lt;_Znwm@plt&gt; # 这里应该是分配堆内存的那个函数</span><br><span class="line">   0x000055555555480d &lt;+19&gt;:	mov    %rax,%rbx  # 返回的指针存在了%rax,然后送入%rbx</span><br><span class="line">   0x0000555555554810 &lt;+22&gt;:	movq   $0x0,(%rbx)</span><br><span class="line">   0x0000555555554817 &lt;+29&gt;:	movl   $0x0,0x8(%rbx)</span><br><span class="line">   0x000055555555481e &lt;+36&gt;:	mov    %rbx,%rdi</span><br><span class="line">   0x0000555555554821 &lt;+39&gt;:	callq  0x5555555548bc &lt;CVirtual::CVirtual()&gt; # 调用构造函数</span><br><span class="line">   0x0000555555554826 &lt;+44&gt;:	mov    %rbx,-0x20(%rbp)  # rbx存的即是ptestObj指针吧.</span><br><span class="line">   								# -0x20(%rbp)是rtestObj这个引用占的8字节的首地址?</span><br><span class="line">   0x000055555555482a &lt;+48&gt;:	mov    -0x20(%rbp),%rax</span><br><span class="line">   0x000055555555482e &lt;+52&gt;:	mov    %rax,-0x18(%rbp)  </span><br><span class="line">   								# 下面的逻辑和指针调用分析的一样了...本质是因为引用和指针在汇编这个层面看,引用由指针实现(感觉这句话不严谨?汇编层面的指针就是一个8字节的地址,关键看反汇编的代码吧.一下就明白了).</span><br><span class="line">   0x0000555555554832 &lt;+56&gt;:	mov    -0x18(%rbp),%rax</span><br><span class="line">   0x0000555555554836 &lt;+60&gt;:	mov    (%rax),%rax</span><br><span class="line">   0x0000555555554839 &lt;+63&gt;:	add    $0x8,%rax</span><br><span class="line">   0x000055555555483d &lt;+67&gt;:	mov    (%rax),%rax</span><br><span class="line">   0x0000555555554840 &lt;+70&gt;:	mov    -0x18(%rbp),%rdx</span><br><span class="line">   0x0000555555554844 &lt;+74&gt;:	mov    $0xc8,%esi</span><br><span class="line">   0x0000555555554849 &lt;+79&gt;:	mov    %rdx,%rdi</span><br><span class="line">   0x000055555555484c &lt;+82&gt;:	callq  *%rax</span><br><span class="line">   0x000055555555484e &lt;+84&gt;:	mov    -0x18(%rbp),%rax</span><br><span class="line">   0x0000555555554852 &lt;+88&gt;:	mov    (%rax),%rax</span><br><span class="line">   0x0000555555554855 &lt;+91&gt;:	mov    (%rax),%rax</span><br><span class="line">   0x0000555555554858 &lt;+94&gt;:	mov    -0x18(%rbp),%rdx</span><br><span class="line">   0x000055555555485c &lt;+98&gt;:	mov    %rdx,%rdi</span><br><span class="line">   0x000055555555485f &lt;+101&gt;:	callq  *%rax</span><br><span class="line">   0x0000555555554861 &lt;+103&gt;:	mov    %eax,%esi</span><br><span class="line">   0x0000555555554863 &lt;+105&gt;:	lea    0xfa(%rip),%rdi        # 0x555555554964</span><br><span class="line">   0x000055555555486a &lt;+112&gt;:	mov    $0x0,%eax</span><br><span class="line">   0x000055555555486f &lt;+117&gt;:	callq  0x5555555546b0 &lt;printf@plt&gt;</span><br><span class="line">   0x0000555555554874 &lt;+122&gt;:	mov    -0x20(%rbp),%rax</span><br><span class="line">   0x0000555555554878 &lt;+126&gt;:	mov    $0x10,%esi</span><br><span class="line">   0x000055555555487d &lt;+131&gt;:	mov    %rax,%rdi</span><br><span class="line">   0x0000555555554880 &lt;+134&gt;:	callq  0x5555555546d0 &lt;_ZdlPvm@plt&gt; # delete</span><br><span class="line">   0x0000555555554885 &lt;+139&gt;:	mov    $0x0,%eax</span><br><span class="line">   0x000055555555488a &lt;+144&gt;:	add    $0x18,%rsp</span><br><span class="line">   0x000055555555488e &lt;+148&gt;:	pop    %rbx</span><br><span class="line">   0x000055555555488f &lt;+149&gt;:	pop    %rbp</span><br><span class="line">   0x0000555555554890 &lt;+150&gt;:	retq</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>
<p>最终就两种调用方式.</p>
<p>callq  0x555555554832 和 callq  *%rax</p>
<p>分别是直接调用和间接调用,只有callq  *%rax这种间接方式是查vptr指向的虚函数表,然后找到函数指针后调用相应函数的,也就是虚函数实现C++多态的关键…(有个问题,这么做的话,性能上打折扣吗???)</p>
<hr>
<h3 id="析构函数与vptr"><a href="#析构函数与vptr" class="headerlink" title="析构函数与vptr"></a>析构函数与vptr</h3><blockquote>
<p>  反汇编与逆向分析技术揭秘11.1节P261最后几段话,没太明白,关键应该是要结合继承来分析…待看吧…</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CVirtual</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">GetNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> _nNumber;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SetNumber</span><span class="params">(<span class="keyword">int</span> nNumber)</span> </span>&#123;</span><br><span class="line">      _nNumber = nNumber;</span><br><span class="line">  &#125;</span><br><span class="line">  ~CVirtual() &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"~CVirtual()\n"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> _nNumber;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CVirtual testObj;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disassemble main</span><br><span class="line">Dump of assembler code for function main():</span><br><span class="line">   0x00005555555547ea &lt;+0&gt;:	push   %rbp</span><br><span class="line">   0x00005555555547eb &lt;+1&gt;:	mov    %rsp,%rbp</span><br><span class="line">   0x00005555555547ee &lt;+4&gt;:	push   %rbx</span><br><span class="line">   0x00005555555547ef &lt;+5&gt;:	sub    $0x28,%rsp</span><br><span class="line">=&gt; 0x00005555555547f3 &lt;+9&gt;:	mov    %fs:0x28,%rax</span><br><span class="line">   0x00005555555547fc &lt;+18&gt;:	mov    %rax,-0x18(%rbp)</span><br><span class="line">   0x0000555555554800 &lt;+22&gt;:	xor    %eax,%eax</span><br><span class="line">   0x0000555555554802 &lt;+24&gt;:	lea    -0x30(%rbp),%rax</span><br><span class="line">   0x0000555555554806 &lt;+28&gt;:	mov    %rax,%rdi</span><br><span class="line">   0x0000555555554809 &lt;+31&gt;:	callq  0x555555554890 &lt;CVirtual::CVirtual()&gt;</span><br><span class="line">   0x000055555555480e &lt;+36&gt;:	mov    $0x0,%ebx</span><br><span class="line">   0x0000555555554813 &lt;+41&gt;:	lea    -0x30(%rbp),%rax</span><br><span class="line">   0x0000555555554817 &lt;+45&gt;:	mov    %rax,%rdi  # this指针</span><br><span class="line">   0x000055555555481a &lt;+48&gt;:	callq  0x555555554866 &lt;CVirtual::~CVirtual()&gt;</span><br><span class="line">   0x000055555555481f &lt;+53&gt;:	mov    %ebx,%eax</span><br><span class="line">   0x0000555555554821 &lt;+55&gt;:	mov    -0x18(%rbp),%rdx  # 后面的这些什么作用?</span><br><span class="line">   0x0000555555554825 &lt;+59&gt;:	xor    %fs:0x28,%rdx</span><br><span class="line">   0x000055555555482e &lt;+68&gt;:	je     0x555555554835 &lt;main()+75&gt;</span><br><span class="line">   0x0000555555554830 &lt;+70&gt;:	callq  0x5555555546b0 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">   0x0000555555554835 &lt;+75&gt;:	add    $0x28,%rsp</span><br><span class="line">   0x0000555555554839 &lt;+79&gt;:	pop    %rbx</span><br><span class="line">   0x000055555555483a &lt;+80&gt;:	pop    %rbp</span><br><span class="line">   0x000055555555483b &lt;+81&gt;:	retq</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disassemble 0x555555554866  # callq  0x555555554866 &lt;CVirtual::~CVirtual()&gt;</span><br><span class="line">Dump of assembler code for function CVirtual::~CVirtual():</span><br><span class="line">   0x0000555555554866 &lt;+0&gt;:	push   %rbp</span><br><span class="line">   0x0000555555554867 &lt;+1&gt;:	mov    %rsp,%rbp</span><br><span class="line">   0x000055555555486a &lt;+4&gt;:	sub    $0x10,%rsp</span><br><span class="line">   0x000055555555486e &lt;+8&gt;:	mov    %rdi,-0x8(%rbp)  # this指针存入-0x8(%rbp)</span><br><span class="line">   0x0000555555554872 &lt;+12&gt;:	lea    0x200517(%rip),%rdx        # 0x555555754d90 &lt;_ZTV8CVirtual+16&gt;									   # 虚表地址放入%rdx</span><br><span class="line">   														# 0x555555754d90是虚表地址</span><br><span class="line">   0x0000555555554879 &lt;+19&gt;:	mov    -0x8(%rbp),%rax</span><br><span class="line">   0x000055555555487d &lt;+23&gt;:	mov    %rdx,(%rax)		# 虚表地址放入this指针指的那个对象的vptr?啥?那岂不是和构造函数干了一样的事情?</span><br><span class="line">   # 又是把虚表首地址赋值到对应对象的虚表指针中</span><br><span class="line">   0x0000555555554880 &lt;+26&gt;:	lea    0xad(%rip),%rdi        # 0x555555554934</span><br><span class="line">   0x0000555555554887 &lt;+33&gt;:	callq  0x5555555546c0 &lt;puts@plt&gt;</span><br><span class="line">   0x000055555555488c &lt;+38&gt;:	nop</span><br><span class="line">   0x000055555555488d &lt;+39&gt;:	leaveq</span><br><span class="line">   0x000055555555488e &lt;+40&gt;:	retq</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>
<p>这个析构的汇编分析尤其是写入虚表指针那里,不明白!!!这里的弄清楚的线索在反汇编与逆向分析技术揭秘11.1节最后几段话.关键应该是要结合继承来分析…</p>
<p>有合成的析构函数吧?有,见C++Primer13.1.3.之前见过,记不得了…<br>如果改成</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CVirtual</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">GetNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> _nNumber;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SetNumber</span><span class="params">(<span class="keyword">int</span> nNumber)</span> </span>&#123;</span><br><span class="line">      _nNumber = nNumber;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//~CVirtual() &#123;</span></span><br><span class="line">  <span class="comment">//    printf("~CVirtual()\n");</span></span><br><span class="line">  <span class="comment">//&#125;</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> _nNumber;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CVirtual testObj;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>回到不显式定义析构函数的时候.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disassemble main</span><br><span class="line">Dump of assembler code for function main():</span><br><span class="line">   0x000055555555475a &lt;+0&gt;:	push   %rbp</span><br><span class="line">   0x000055555555475b &lt;+1&gt;:	mov    %rsp,%rbp</span><br><span class="line">   0x000055555555475e &lt;+4&gt;:	sub    $0x20,%rsp</span><br><span class="line">=&gt; 0x0000555555554762 &lt;+8&gt;:	mov    %fs:0x28,%rax</span><br><span class="line">   0x000055555555476b &lt;+17&gt;:	mov    %rax,-0x8(%rbp)</span><br><span class="line">   0x000055555555476f &lt;+21&gt;:	xor    %eax,%eax</span><br><span class="line">   0x0000555555554771 &lt;+23&gt;:	lea    -0x20(%rbp),%rax</span><br><span class="line">   0x0000555555554775 &lt;+27&gt;:	mov    %rax,%rdi</span><br><span class="line">   0x0000555555554778 &lt;+30&gt;:	callq  0x5555555547c2 &lt;CVirtual::CVirtual()&gt;</span><br><span class="line">   0x000055555555477d &lt;+35&gt;:	mov    $0x0,%eax</span><br><span class="line">   0x0000555555554782 &lt;+40&gt;:	mov    -0x8(%rbp),%rdx</span><br><span class="line">   0x0000555555554786 &lt;+44&gt;:	xor    %fs:0x28,%rdx</span><br><span class="line">   0x000055555555478f &lt;+53&gt;:	je     0x555555554796 &lt;main()+60&gt;</span><br><span class="line">   0x0000555555554791 &lt;+55&gt;:	callq  0x555555554630 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">   0x0000555555554796 &lt;+60&gt;:	leaveq</span><br><span class="line">   0x0000555555554797 &lt;+61&gt;:	retq</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>
<p>在main里面没调用析构函数?被编译器优化了???关优化试试.<br>析构这里有没有类似构造的RVO的g++ -fno-elide-constructors这样的东西?强制不优化,执行析构函数.<br>这里结合Effective Modern C++的有一小节来看(讲编译器在背后帮你实现了哪些copy control函数那节,主要这里有C++11的,而Effective C++里面只没有移动版本copy control函数的分析).先放着吧…</p>
<p>参考:</p>
<p>1.反汇编与逆向分析技术揭秘</p>

      
    </div>
    
    
    

    

    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>Post author:</strong>
    mojiajun
  </li>
  <li class="post-copyright-link">
    <strong>Post link:</strong>
    <a href="https://mojiajun.github.io/post/a24c8ee4.html" title="C++-虚函数机制-02">https://mojiajun.github.io/post/a24c8ee4.html</a>
  </li>
  <li class="post-copyright-license">
    <strong>Copyright Notice: </strong>
    All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0</a> unless stating additionally.
  </li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/C/" rel="tag"># C++</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/post/18ee0c7.html" rel="next" title="mit6828-内联汇编-xv6-xchg-spinlock">
                <i class="fa fa-chevron-left"></i> mit6828-内联汇编-xv6-xchg-spinlock
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/post/3b45df5e.html" rel="prev" title="C++-虚函数机制-01">
                C++-虚函数机制-01 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">mojiajun</p>
              <p class="site-description motion-element" itemprop="description">莫佳骏学习笔记</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#构造函数和vptr"><span class="nav-number">1.</span> <span class="nav-text">构造函数和vptr</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#object直接调用-用’-’"><span class="nav-number">2.</span> <span class="nav-text">object直接调用(用’.’)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#object指针-用’-gt-’-和引用-‘ref-’-调用"><span class="nav-number">3.</span> <span class="nav-text">object指针(用’-&gt;’)和引用(‘ref.’)调用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#指针调用"><span class="nav-number">3.1.</span> <span class="nav-text">指针调用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#引用调用"><span class="nav-number">3.2.</span> <span class="nav-text">引用调用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#析构函数与vptr"><span class="nav-number">4.</span> <span class="nav-text">析构函数与vptr</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">mojiajun</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>








        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
