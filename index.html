<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="莫佳骏学习笔记">
<meta property="og:type" content="website">
<meta property="og:title" content="mojiajun">
<meta property="og:url" content="https://mojiajun.github.io/index.html">
<meta property="og:site_name" content="mojiajun">
<meta property="og:description" content="莫佳骏学习笔记">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="mojiajun">
<meta name="twitter:description" content="莫佳骏学习笔记">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://mojiajun.github.io/">





  <title>mojiajun</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">mojiajun</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://mojiajun.github.io/post/4a75fa2f.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mojiajun">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mojiajun">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/post/4a75fa2f.html" itemprop="url">mit6824-lab1-part-V</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-10-10T00:00:00+08:00">
                2019-10-10
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/分布式/" itemprop="url" rel="index">
                    <span itemprop="name">分布式</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/分布式/mit6824/" itemprop="url" rel="index">
                    <span itemprop="name">mit6824</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>[TOC]</p>
<h2 id="lab1-Part-V-Inverted-index-generation"><a href="#lab1-Part-V-Inverted-index-generation" class="headerlink" title="lab1-Part V Inverted index generation"></a>lab1-Part V Inverted index generation</h2><p>Inverted index倒排索引.从关键词到url的索引.(文件名也可以看做一种url吧.)</p>
<p>那就是在word count的基础上加点东西?和word count还是不同的.看后面的代码即知.</p>
<p>不仅统计词数,还要附带出现的url位置.</p>
<p>这个partV不难,还是挺有意思的.</p>
<p>先用go run ii.go master sequential pg-*.txt测试.</p>
<h3 id="mapF"><a href="#mapF" class="headerlink" title="mapF"></a>mapF</h3><p>感觉mapF函数几乎和lab2-wc.go里面的mapF差不多啊</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapF</span><span class="params">(document <span class="keyword">string</span>, value <span class="keyword">string</span>)</span> <span class="params">(res []mapreduce.KeyValue)</span></span> &#123;</span><br><span class="line">	<span class="comment">// Your code here (Part V).</span></span><br><span class="line">	<span class="comment">// 划分词</span></span><br><span class="line">	<span class="comment">// 划分词这里得搞明白...</span></span><br><span class="line">	<span class="comment">// words := strings.Fields(contents)</span></span><br><span class="line">	words := strings.FieldsFunc(contents, <span class="function"><span class="keyword">func</span><span class="params">(c <span class="keyword">rune</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">		<span class="keyword">return</span> !unicode.IsLetter(c)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 先构造一个map</span></span><br><span class="line">	mapping := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>) <span class="comment">// 有溢出的风险</span></span><br><span class="line">	<span class="keyword">for</span> _, w := <span class="keyword">range</span> words &#123;</span><br><span class="line">		mapping[w]++</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//把map的数据写入res</span></span><br><span class="line">	<span class="keyword">var</span> res []mapreduce.KeyValue</span><br><span class="line">	<span class="keyword">for</span> key, val := <span class="keyword">range</span> mapping &#123;</span><br><span class="line">		res = <span class="built_in">append</span>(res, mapreduce.KeyValue&#123;Key: key, Value: strconv.Itoa(val) + document&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="reduceF"><a href="#reduceF" class="headerlink" title="reduceF"></a>reduceF</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reduceF</span><span class="params">(key <span class="keyword">string</span>, values []<span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="comment">// Your code here (Part V).</span></span><br><span class="line">	<span class="keyword">var</span> valInt <span class="keyword">int</span></span><br><span class="line">	<span class="keyword">var</span> invertedIndex <span class="keyword">string</span></span><br><span class="line">	<span class="keyword">for</span> _, val := <span class="keyword">range</span> values &#123;</span><br><span class="line">		<span class="comment">// fmt.Println(val)</span></span><br><span class="line">		splitRes := strings.FieldsFunc(val, <span class="function"><span class="keyword">func</span><span class="params">(c <span class="keyword">rune</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">			<span class="keyword">return</span> unicode.IsSpace(c)  <span class="comment">// 为true则删除,而且会作为界限，在这里即是空格space</span></span><br><span class="line">		&#125;)</span><br><span class="line">		<span class="comment">// fmt.Println(splitRes)</span></span><br><span class="line">		valIntTemp, err := strconv.Atoi(splitRes[<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Fatal(<span class="string">"reduceF() fail "</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">		valInt += valIntTemp</span><br><span class="line">		<span class="keyword">if</span> invertedIndex != <span class="string">""</span> &#123;</span><br><span class="line">			invertedIndex += <span class="string">","</span></span><br><span class="line">		&#125;</span><br><span class="line">		invertedIndex += splitRes[<span class="number">1</span>]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> strconv.Itoa(valInt) + <span class="string">" "</span> + invertedIndex <span class="comment">// 这么写的话也可能溢出.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样的话前面的那个数字会把所有出现的次数都算进来了.等于是wc count了…?<br>但是应该不是这样的.改成下面这就好了,因为要在mapF阶段去重.所以这么写</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapF</span><span class="params">(document <span class="keyword">string</span>, value <span class="keyword">string</span>)</span> []<span class="title">mapreduce</span>.<span class="title">KeyValue</span></span> &#123;</span><br><span class="line">	<span class="comment">// Your code here (Part V).</span></span><br><span class="line">	<span class="comment">// 划分词</span></span><br><span class="line">	<span class="comment">// 划分词这里得搞明白...</span></span><br><span class="line">	<span class="comment">// words := strings.Fields(contents)</span></span><br><span class="line">	words := strings.FieldsFunc(value, <span class="function"><span class="keyword">func</span><span class="params">(c <span class="keyword">rune</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">		<span class="keyword">return</span> !unicode.IsLetter(c)  <span class="comment">// 不是字母的地方得删除,而且会作为界限</span></span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 先构造一个map</span></span><br><span class="line">	mapping := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>) <span class="comment">// 有溢出的风险</span></span><br><span class="line">	<span class="keyword">for</span> _, w := <span class="keyword">range</span> words &#123;</span><br><span class="line">		mapping[w]++</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//把map的数据写入res</span></span><br><span class="line">	<span class="keyword">var</span> res []mapreduce.KeyValue</span><br><span class="line">	<span class="keyword">for</span> key, _ := <span class="keyword">range</span> mapping &#123;</span><br><span class="line">		res = <span class="built_in">append</span>(res, mapreduce.KeyValue&#123;Key: key, Value: strconv.Itoa(<span class="number">1</span>) + <span class="string">" "</span> + document&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="master-worker分布式模式来运行"><a href="#master-worker分布式模式来运行" class="headerlink" title="master-worker分布式模式来运行"></a>master-worker分布式模式来运行</h3><p>类似lab1-part-II那样太麻烦了…</p>
<p>直接改代码吧,改成test-test.go里面的那样.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   mr := mapreduce.Distributed(<span class="string">"iiseq"</span>, os.Args[<span class="number">1</span>:], <span class="number">3</span>, <span class="string">"localhost:7700"</span>)</span><br><span class="line">   <span class="comment">// Start 2 workers that fail after 10 tasks</span></span><br><span class="line">   <span class="keyword">go</span> mapreduce.RunWorker(<span class="string">"localhost:7700"</span>, <span class="string">"localhost:7701"</span>,</span><br><span class="line">      mapF, reduceF, <span class="number">2</span>, <span class="literal">nil</span>)</span><br><span class="line">   <span class="keyword">go</span> mapreduce.RunWorker(<span class="string">"localhost:7700"</span>, <span class="string">"localhost:7702"</span>,</span><br><span class="line">      mapF, reduceF, <span class="number">-1</span>, <span class="literal">nil</span>)</span><br><span class="line">   <span class="keyword">go</span> mapreduce.RunWorker(<span class="string">"localhost:7700"</span>, <span class="string">"localhost:7703"</span>,</span><br><span class="line">      mapF, reduceF, <span class="number">3</span>, <span class="literal">nil</span>)</span><br><span class="line">   <span class="keyword">go</span> mapreduce.RunWorker(<span class="string">"localhost:7700"</span>, <span class="string">"localhost:7704"</span>,</span><br><span class="line">      mapF, reduceF, <span class="number">-1</span>, <span class="literal">nil</span>)</span><br><span class="line">   mr.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> sequential.mrtmp.iiseq为 sequential模式下的最后输出mrtmp.iiseq,用来进行对比.结果发现是一样的.doMap()不管怎么执行,hash进哪个文件都是确定的.然后doReduce()会对key进行排序后写入输出文件.所以是一样的.等效的.</p>
<p>go run ii.go pg-*.txt<br>diff mrtmp.iiseq sequential.mrtmp.iiseq</p>
<h3 id="最后总结-完成lab1的part-I至V-5个part之后"><a href="#最后总结-完成lab1的part-I至V-5个part之后" class="headerlink" title="最后总结(完成lab1的part-I至V,5个part之后)"></a>最后总结(完成lab1的part-I至V,5个part之后)</h3><p>part-I,实现doMap()和doReduce().</p>
<p>part-II,实现mapF和reduceF(这个相当于是mapreduce框架提供给用户业务代码的接口).lab2有word count任务.<br>lab5有Inverted index任务,在理解清楚真个mapreduce框架的流程后,并不难.</p>
<p>part-III,实现schedule().这一部分应该是最难的一个part了…把序列式的执行改成基于rpc的分布式执行.这一部分需要仔细理解清楚整个流程中的每个细节.</p>
<p>part-IV,在part-III的基础上增加worker崩了也没事的容错机制.</p>
<p>part-V.针对Inverted index任务写业务代码</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://mojiajun.github.io/post/36cb5d71.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mojiajun">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mojiajun">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/post/36cb5d71.html" itemprop="url">mit6824-lab1-part-IV</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-10-09T00:00:00+08:00">
                2019-10-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/分布式/" itemprop="url" rel="index">
                    <span itemprop="name">分布式</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/分布式/mit6824/" itemprop="url" rel="index">
                    <span itemprop="name">mit6824</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>[TOC]</p>
<h2 id="lab1-Part-I-Map-Reduce-input-and-output-part-IV"><a href="#lab1-Part-I-Map-Reduce-input-and-output-part-IV" class="headerlink" title="lab1-Part-I-Map/Reduce input and output-part-IV"></a>lab1-Part-I-Map/Reduce input and output-part-IV</h2><p>MapReduce makes this relatively easy because workers don’t have persistent state.<br>什么是persistent state?</p>
<p>Two invocations of a map or reduce function are required to generate the same output for a given input (i.e. the map and reduce functions are “functional”)[这里应该指的是只要输入一样,也就是给的task一样,不同map,reduce函数的输出是完全一样的.输出即输出文件.], so there won’t be inconsistencies[不一致] if subsequent processing sometimes reads one output and sometimes the other(读的时候不就是读同一个文件吗???). In addition, the MapReduce framework ensures that map and reduce function output appears atomically: the output file will either not exist, or will contain the entire output of a single execution of the map or reduce function (the lab code doesn’t actually implement this[这个实验里确实没实现这个], but instead only fails workers at the end of a task, so there aren’t concurrent executions of a task[一个task并发执行???不行吧.一个task只能被分配给一个worker]).???啥意思?</p>
<p>1.某个worker失效后,也就是没有在进行监听了,那么master怎么知晓这件事?然后接下来的任务就跳过它.在后续可能还会把任务分配给这个worker,但是在call()的内部rpc.Dial()时,会timeout.然后检测到错误.</p>
<p>2.worker可能是中途由于不明原因终止的.这也要能处理好.这种情况虽然官方给的测试用例里面对这种情况没测,但是应该也是可以的,因为那样最终还是会导致call()rpc调用的时候timeout.那样的话输出文件如果已经创建了怎么办?直接覆盖吧.</p>
<p>3.多个worker可能会执行相同的task.所以会出现什么问题?如果是两个worker往同一个文件里面写入呢?这种情况还是可能出现的吧?甚至3个,4个…worker往同一个输出文件里面写入,假设在备用的第2个worker又执行那个失败任务的时候这个备用的worker也故障了(可能超时之后第2个worker调用的rpc还是正在执行),那么就会出现第3个worker来执行这个任务.就有可能出现同时3个worker它们对应的rpc都在执行同一个task.以此类推4个,5个…<br>因为假设worker在写入,但是rpc timeout了,此时master端直接返回了,然后就会把任务分配给其他worker了.此时其他worker就可能在工作了.但是应该没啥影响吧?往同一个文件里写.因为它们的文件偏移不一样.后面的这个会覆盖前面的那个的写入.<strong>而假设两个worker如果假设都正确写入的话,他们写入的结果应该是完全一样的.</strong>所以哪怕前一个正在写入,后一个worker又进行工作了,也在写入,也不会出问题.??是这么回事吗?</p>
<p>只在lab1-part-III的基础上稍微改了一点点.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">schedule</span><span class="params">(jobName <span class="keyword">string</span>, mapFiles []<span class="keyword">string</span>, nReduce <span class="keyword">int</span>, phase jobPhase, registerChan <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> ntasks <span class="keyword">int</span></span><br><span class="line">	<span class="keyword">var</span> n_other <span class="keyword">int</span> <span class="comment">// number of inputs (for reduce) or outputs (for map)</span></span><br><span class="line">	<span class="keyword">switch</span> phase &#123;</span><br><span class="line">	<span class="keyword">case</span> mapPhase:</span><br><span class="line">		ntasks = <span class="built_in">len</span>(mapFiles)</span><br><span class="line">		n_other = nReduce</span><br><span class="line">	<span class="keyword">case</span> reducePhase:</span><br><span class="line">		ntasks = nReduce</span><br><span class="line">		n_other = <span class="built_in">len</span>(mapFiles)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">"Schedule: %v %v tasks (%d I/Os)\n"</span>, ntasks, phase, n_other)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// All ntasks tasks have to be scheduled on workers. Once all tasks</span></span><br><span class="line">	<span class="comment">// have completed successfully, schedule() should return.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Your code here (Part III, Part IV).</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// worker设成工作池模式.模仿Go-by-example的worker-pools例子[https://gobyexample.com/worker-pools]</span></span><br><span class="line">	<span class="comment">// 新来的worker怎么办? 使用另外一个协程阻塞在registerChan这个channel上面,一旦有新来的worker,再启动一个新的协程来进行同步rpc调用</span></span><br><span class="line">	<span class="comment">// 最终目标是把ntasks个任务分配给若干个worker,在schedule()的尾部,需要等待所有任务处理完.</span></span><br><span class="line"></span><br><span class="line">	taskPool := <span class="built_in">make</span>(<span class="keyword">chan</span> DoTaskArgs, ntasks)</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 不开一个新的协程去负责接收registerChan里面的worker好像不行,因为不知道会有多少个worker会来,以及多久来.而registerChan</span></span><br><span class="line">	<span class="comment">// 又是unbuffer的,接收不到就会阻塞</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="comment">// 这个for循环一定要有,否则!!!后面的代码执行一次之后就退出了,也就是会导致只会创建出一个worker协程,这不是我们想要的结果.</span></span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="comment">// 从forwardRegistration收到一个worker的地址</span></span><br><span class="line">			worker := &lt;-registerChan</span><br><span class="line">			<span class="comment">//fmt.Println("launch a new worker goroutine", worker)</span></span><br><span class="line">			<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">				<span class="keyword">for</span> taskArgs := <span class="keyword">range</span> taskPool &#123; <span class="comment">// 参考Go-by-example的worker-pools例子[https://gobyexample.com/worker-pools]</span></span><br><span class="line">					boolval := call(worker, <span class="string">"Worker.DoTask"</span>, taskArgs, <span class="literal">nil</span>)</span><br><span class="line">					<span class="keyword">if</span> boolval == <span class="literal">false</span> &#123;</span><br><span class="line">						<span class="comment">// 没做完这个task,直接退出,不用调用wg.Done(),因为它没完成指定任务</span></span><br><span class="line">						<span class="comment">// 然后得把任务重新加入任务池</span></span><br><span class="line">						taskPool &lt;- taskArgs</span><br><span class="line">						<span class="keyword">break</span></span><br><span class="line">					&#125;</span><br><span class="line">					wg.Done()</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建每个任务对应的DoTaskArgs结构体,然后放入taskPool</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; ntasks; i++ &#123;</span><br><span class="line">		<span class="keyword">var</span> doTaskArgs DoTaskArgs;</span><br><span class="line">		doTaskArgs.JobName = jobName</span><br><span class="line">		doTaskArgs.TaskNumber = i</span><br><span class="line">		doTaskArgs.NumOtherPhase = n_other</span><br><span class="line">		<span class="keyword">switch</span> phase &#123;</span><br><span class="line">		<span class="keyword">case</span> mapPhase:</span><br><span class="line">			doTaskArgs.Phase = mapPhase</span><br><span class="line">			doTaskArgs.File = mapFiles[i]</span><br><span class="line">		<span class="keyword">case</span> reducePhase:</span><br><span class="line">			doTaskArgs.Phase = reducePhase</span><br><span class="line">		&#125;</span><br><span class="line">		taskPool &lt;- doTaskArgs</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">"Schedule: %v done\n"</span>, phase)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RunWorker协程启动后就一直在监听.(会检测当前做的task数目是否已经达到阈值,达到之后则这个协程退出.不再监听.)<br>如果是在监听状态,当有任务到来,比如master的schedule()发起rpc调用call(worker, “Worker.DoTask”, taskArgs, nil),RunWorker协程会go rpcs.ServeConn(conn)</p>
<p>测试用例里面用的是设定nRPC的值,然后做完指定数量的后.在RunWorker中会把wk.nRPC减到0,然后go rpcs.ServeConn(conn)处理最后一次task.当RunWorker协程再次循环的时候即退出.此时,下一次task来的时候,若分配给了这个退出的worker.然后这个RunWorker协程调用call().估计在rpc.Dial()失败?所以不会继续,timeout,然后检测失败.</p>
<blockquote>
<p>???<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;c, errx := rpc.Dial(<span class="string">"unix"</span>, srv)</span><br><span class="line">&gt;<span class="comment">// 在lab2的最后,换用localhost 7777这样的tcp连接去这么调用也可以?</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://mojiajun.github.io/post/376c92d0.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mojiajun">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mojiajun">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/post/376c92d0.html" itemprop="url">mit6824-lab1-part-III</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-10-08T00:00:00+08:00">
                2019-10-08
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/分布式/" itemprop="url" rel="index">
                    <span itemprop="name">分布式</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/分布式/mit6824/" itemprop="url" rel="index">
                    <span itemprop="name">mit6824</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>[TOC]</p>
<h2 id="lab1-Part-I-Map-Reduce-input-and-output-part-III"><a href="#lab1-Part-I-Map-Reduce-input-and-output-part-III" class="headerlink" title="lab1-Part-I-Map/Reduce input and output-part-III"></a>lab1-Part-I-Map/Reduce input and output-part-III</h2><p> There will usually be more tasks than worker threads, so <code>schedule()</code> must give each worker a sequence of tasks, one at a time. <code>schedule()</code> should wait until all tasks have completed, and then return.</p>
<p>part3需要实现schedule()函数</p>
<h3 id="先理解整体执行流程"><a href="#先理解整体执行流程" class="headerlink" title="先理解整体执行流程"></a>先理解整体执行流程</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestParallelBasic</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	mr := setup()</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123; <span class="comment">// 1个master+2个worker?</span></span><br><span class="line">		<span class="keyword">go</span> RunWorker(mr.address, port(<span class="string">"worker"</span>+strconv.Itoa(i)),</span><br><span class="line">			MapFunc, ReduceFunc, <span class="number">-1</span>, <span class="literal">nil</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	mr.Wait()</span><br><span class="line">	check(t, mr.files)</span><br><span class="line"></span><br><span class="line">	cleanup(mr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两个worker,都是由RunWorker()创建,考虑其中任意一个worker的创建过程.<br>在RunWorker()运行的时候,master rpc server已经在listen了.master rpc server阻塞在Accept()上.当worker有关的struct的已经构造好了之后.使用Worker的method,调用wk.register(MasterAddress).然后worker发起rpc调用.<br>master rpc server监听goroutine收到请求后,go一个新的goroutine执行rpcs.ServeConn(conn),处理request,然后在worker goroutine里因为是Synchronous call[见go-rpc文档,因为是.Call调用方式],所以会等待结果.然后分两块来看的话:</p>
<p>1.worker</p>
<p>收到rpc调用的结果返回后(结果是什么?),正常情况下进入监听状态.然后进入准备接收任务的状态.任务怎么派发过来的?<br>去哪执行?</p>
<p>2.master rpc server</p>
<p>go一个新的goroutine执行rpcs.ServeConn(conn),之后:<br>其实就做了两件事,<br>一是把worker的address,即worker.name,也即是它即将监听的Unix domain socket放入master.workers.<br>二是对当前wait在newCond条件变量上的goroutine(这些goroutine处于block状态)调用mr.newCond.Broadcast()<br>处于wait状态的goroutine是forwardRegistrations()(一个还是两个??schedule()中间的block怎么设置?通过ch := make(chan string)???),然后forwardRegistrations()解除block,启一个新的goroutine去把新收的worker的address送给channel.然后这个新的goroutine处于block直到channel的另一端即schedule goroutine收到这个worker的地址,然后schedule goroutine收到这个新的worker address.解除block.进行schedule?如果是map阶段的话,会分配map任务给这个新来的worker吧?然后schedule调度完了之后,进行rpc调用Worker.DoTask.</p>
<p>再之后,worker处理这个rpc请求,它又启一个goroutine,去执行Worker.DoTask.然后里面就会调用lab1-part-I里的doMap()或doReduce()了.再经过和lab1-part-I相同的过程,处理完它应该处理的任务.</p>
<h3 id="尝试实现schedule"><a href="#尝试实现schedule" class="headerlink" title="尝试实现schedule()"></a>尝试实现schedule()</h3><p>从registerChan接收worker.(这一步并不容易),然后指派task</p>
<p>下面是需要实现的关键点:</p>
<p>1.worker数目一般小于task数目,每个worker可能会执行若干个task.但是对于每个worker,rpc调用worker.DoTask的时候,同一时刻,只能被调用一次,一个worker协程同步调用(用rpc包的.Call方法)worker.DoTask.必须得等它返回了,才能进行下一次rpc调用.(官方暗示用channel)</p>
<p>2.schedule()应该使用所有的worker.(复杂点是不是还可能有负载均衡.),包括在schedule()运行之后才得到的worker</p>
<p>第一版-有问题的代码.请忽略.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">schedule</span><span class="params">(jobName <span class="keyword">string</span>, mapFiles []<span class="keyword">string</span>, nReduce <span class="keyword">int</span>, phase jobPhase, registerChan <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> ntasks <span class="keyword">int</span></span><br><span class="line">	<span class="keyword">var</span> n_other <span class="keyword">int</span> <span class="comment">// number of inputs (for reduce) or outputs (for map)</span></span><br><span class="line">	<span class="keyword">switch</span> phase &#123;</span><br><span class="line">	<span class="keyword">case</span> mapPhase:</span><br><span class="line">		ntasks = <span class="built_in">len</span>(mapFiles)</span><br><span class="line">		n_other = nReduce</span><br><span class="line">	<span class="keyword">case</span> reducePhase:</span><br><span class="line">		ntasks = nReduce</span><br><span class="line">		n_other = <span class="built_in">len</span>(mapFiles)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">"Schedule: %v %v tasks (%d I/Os)\n"</span>, ntasks, phase, n_other)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// All ntasks tasks have to be scheduled on workers. Once all tasks</span></span><br><span class="line">	<span class="comment">// have completed successfully, schedule() should return.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Your code here (Part III, Part IV).</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// worker设成工作池模式?新来的worker怎么办?</span></span><br><span class="line">	<span class="comment">// 监视一个工作池?然后这个工作池随时可能会增加worker</span></span><br><span class="line">	<span class="comment">// 对工作池遍历指派任务?</span></span><br><span class="line">	<span class="comment">// 把ntasks个任务指配完</span></span><br><span class="line">	<span class="comment">// 最终目标是把ntasks个任务分配给若干个worker</span></span><br><span class="line"></span><br><span class="line">	workerPool := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">100</span>) <span class="comment">// 这个buffer的尺寸设多大合适?</span></span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 从forwardRegistration收到一个worker的地址</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="comment">// 不开一个新的协程去负责接收registerChan里面的worker好像不行,因为不知道会有多少个worker会来,以及多久来.而registerChan</span></span><br><span class="line">		<span class="comment">// 又是unbuffer的,接收不到就会阻塞</span></span><br><span class="line">		worker := &lt;-registerChan <span class="comment">// 怎么设置成有元素就接收,没有元素就跳过的模式?放在某一个task进行之前检查吗?</span></span><br><span class="line">		workerPool &lt;- worker</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ntasks个task对应n个协程?,然后每个协程内部阻塞在向workerPool获得worker上?获取完worker之后又阻塞在rpc的同步调用上?</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; ntasks; i++ &#123; <span class="comment">// 必须等待workerPool有可用的worker,否则阻塞?</span></span><br><span class="line">		<span class="comment">// 从workerPool中获取一个可用的worker,否则阻塞在这里,阻塞的时候要保证workerPool能接收新的worker</span></span><br><span class="line">		<span class="keyword">var</span> doTaskArgs DoTaskArgs;</span><br><span class="line">		doTaskArgs.JobName = jobName</span><br><span class="line">		doTaskArgs.TaskNumber = i</span><br><span class="line">		doTaskArgs.NumOtherPhase = n_other</span><br><span class="line">		<span class="keyword">switch</span> phase &#123;</span><br><span class="line">		<span class="keyword">case</span> mapPhase:</span><br><span class="line">			doTaskArgs.Phase = mapPhase</span><br><span class="line">			doTaskArgs.File = mapFiles[i]</span><br><span class="line">		<span class="keyword">case</span> reducePhase:</span><br><span class="line">			doTaskArgs.Phase = reducePhase</span><br><span class="line">		&#125;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">for</span> worker := <span class="keyword">range</span> workerPool &#123;</span><br><span class="line">				call(worker, <span class="string">"Worker.DoTask"</span>, doTaskArgs, <span class="literal">nil</span>) <span class="comment">// 同步调用?用新的协程来执行它,会阻塞在新的协程里面</span></span><br><span class="line">				workerPool &lt;- worker                                     <span class="comment">// 用完之后又放回workerPool</span></span><br><span class="line">				wg.Done()  <span class="comment">// 这里的逻辑可能有问题...</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">	fmt.Printf(<span class="string">"Schedule: %v done\n"</span>, phase)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="一些bug"><a href="#一些bug" class="headerlink" title="一些bug"></a>一些bug</h3><h4 id="rpc-Register-method-“CleanupFiles”-has-1-input-parameters-needs-exactly-three"><a href="#rpc-Register-method-“CleanupFiles”-has-1-input-parameters-needs-exactly-three" class="headerlink" title="rpc.Register: method “CleanupFiles” has 1 input parameters; needs exactly three"></a>rpc.Register: method “CleanupFiles” has 1 input parameters; needs exactly three</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Distributed()调用mr.startRPCServer()的时候会报错.</span><br><span class="line"></span><br><span class="line"><span class="number">2019</span>/<span class="number">10</span>/<span class="number">08</span> <span class="number">14</span>:<span class="number">31</span>:<span class="number">03</span> rpc.Register: method <span class="string">"CleanupFiles"</span> has <span class="number">1</span> input parameters; needs exactly three</span><br><span class="line"><span class="number">2019</span>/<span class="number">10</span>/<span class="number">08</span> <span class="number">14</span>:<span class="number">31</span>:<span class="number">03</span> rpc.Register: method <span class="string">"Lock"</span> has <span class="number">1</span> input parameters; needs exactly three</span><br><span class="line"><span class="number">2019</span>/<span class="number">10</span>/<span class="number">08</span> <span class="number">14</span>:<span class="number">31</span>:<span class="number">03</span> rpc.Register: method <span class="string">"Unlock"</span> has <span class="number">1</span> input parameters; needs exactly three</span><br><span class="line"><span class="number">2019</span>/<span class="number">10</span>/<span class="number">08</span> <span class="number">14</span>:<span class="number">31</span>:<span class="number">03</span> rpc.Register: method <span class="string">"Wait"</span> has <span class="number">1</span> input parameters; needs exactly three</span><br></pre></td></tr></table></figure>
<p>原因是因为像下面这样的函数其实不应该被注册进master的rpc method里的.却被误以为是rpc method</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mr *Master)</span> <span class="title">CleanupFiles</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> mr.files &#123;</span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; mr.nReduce; j++ &#123;</span><br><span class="line">			removeFile(reduceName(mr.jobName, i, j))</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; mr.nReduce; i++ &#123;</span><br><span class="line">		removeFile(mergeName(mr.jobName, i))</span><br><span class="line">	&#125;</span><br><span class="line">	removeFile(<span class="string">"mrtmp."</span> + mr.jobName)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>怎么解决这个问题,问题的本质是对net.rpc这个go package不太熟.先放着.貌似没事…</p>
<h4 id="Worker-DoTask-more-than-one-DoTask-sent-concurrently-to-a-single-worker"><a href="#Worker-DoTask-more-than-one-DoTask-sent-concurrently-to-a-single-worker" class="headerlink" title="Worker.DoTask: more than one DoTask sent concurrently to a single worker"></a>Worker.DoTask: more than one DoTask sent concurrently to a single worker</h4><p>估计是调用函数写的有问题吧.调度的核心逻辑写的不对.<br>改成下面这样.</p>
<p>第二版-没法并行.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">schedule</span><span class="params">(jobName <span class="keyword">string</span>, mapFiles []<span class="keyword">string</span>, nReduce <span class="keyword">int</span>, phase jobPhase, registerChan <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> ntasks <span class="keyword">int</span></span><br><span class="line">	<span class="keyword">var</span> n_other <span class="keyword">int</span> <span class="comment">// number of inputs (for reduce) or outputs (for map)</span></span><br><span class="line">	<span class="keyword">switch</span> phase &#123;</span><br><span class="line">	<span class="keyword">case</span> mapPhase:</span><br><span class="line">		ntasks = <span class="built_in">len</span>(mapFiles)</span><br><span class="line">		n_other = nReduce</span><br><span class="line">	<span class="keyword">case</span> reducePhase:</span><br><span class="line">		ntasks = nReduce</span><br><span class="line">		n_other = <span class="built_in">len</span>(mapFiles)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">"Schedule: %v %v tasks (%d I/Os)\n"</span>, ntasks, phase, n_other)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// All ntasks tasks have to be scheduled on workers. Once all tasks</span></span><br><span class="line">	<span class="comment">// have completed successfully, schedule() should return.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Your code here (Part III, Part IV).</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// worker设成工作池模式?新来的worker怎么办?</span></span><br><span class="line">	<span class="comment">// 监视一个工作池?然后这个工作池随时可能会增加worker</span></span><br><span class="line">	<span class="comment">// 对工作池遍历指派任务?</span></span><br><span class="line">	<span class="comment">// 把ntasks个任务指配完</span></span><br><span class="line">	<span class="comment">// 最终目标是把ntasks个任务分配给若干个worker</span></span><br><span class="line"></span><br><span class="line">	taskPool := <span class="built_in">make</span>(<span class="keyword">chan</span> DoTaskArgs, ntasks)</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 从forwardRegistration收到一个worker的地址</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="comment">// 不开一个新的协程去负责接收registerChan里面的worker好像不行,因为不知道会有多少个worker会来,以及多久来.而registerChan</span></span><br><span class="line">		<span class="comment">// 又是unbuffer的,接收不到就会阻塞</span></span><br><span class="line">		worker := &lt;-registerChan <span class="comment">// 怎么设置成有元素就接收,没有元素就跳过的模式?放在某一个task进行之前检查吗?</span></span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">for</span> taskArgs := <span class="keyword">range</span> taskPool &#123;</span><br><span class="line">				call(worker, <span class="string">"Worker.DoTask"</span>, taskArgs, <span class="literal">nil</span>)</span><br><span class="line">				wg.Done()</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ntasks个task对应n个协程?,然后每个协程内部阻塞在向workerPool获得worker上?获取完worker之后又阻塞在rpc的同步调用上?</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; ntasks; i++ &#123; <span class="comment">// 必须等待workerPool有可用的worker,否则阻塞?</span></span><br><span class="line">		<span class="comment">// 从workerPool中获取一个可用的worker,否则阻塞在这里,阻塞的时候要保证workerPool能接收新的worker</span></span><br><span class="line">		<span class="keyword">var</span> doTaskArgs DoTaskArgs;</span><br><span class="line">		doTaskArgs.JobName = jobName</span><br><span class="line">		doTaskArgs.TaskNumber = i</span><br><span class="line">		doTaskArgs.NumOtherPhase = n_other</span><br><span class="line">		<span class="keyword">switch</span> phase &#123;</span><br><span class="line">		<span class="keyword">case</span> mapPhase:</span><br><span class="line">			doTaskArgs.Phase = mapPhase</span><br><span class="line">			doTaskArgs.File = mapFiles[i]</span><br><span class="line">		<span class="keyword">case</span> reducePhase:</span><br><span class="line">			doTaskArgs.Phase = reducePhase</span><br><span class="line">		&#125;</span><br><span class="line">		taskPool &lt;- doTaskArgs</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	wg.Wait()</span><br><span class="line">	fmt.Printf(<span class="string">"Schedule: %v done\n"</span>, phase)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>能通过TestParallelBasic().但是TestParallelCheck()失败.</p>
<h3 id="TestParallelCheck-失败为什么"><a href="#TestParallelCheck-失败为什么" class="headerlink" title="TestParallelCheck()失败为什么???"></a>TestParallelCheck()失败为什么???</h3><p>还是核心逻辑不对…这样会导致只有一个worker在实际工作.其他worker在歇着…没干活???这是一个可能原因…<br>(还有另外一个可能原因,就是代码里面只创建了一个worker协程…应该是这个原因了.在启一个新的协程之前加一条fmt.Println(“launch a new worker 协程”, worker),然后观察输出…)</p>
<p>解决办法:加个死循环…?</p>
<hr>
<p>wk.parallelism这一项和wk.concurrent的区别?</p>
<blockquote>
<p>  wk.concurrent用来记录当前worker在某一时刻执行的任务数量,官方的test里给的只能是1,否则会报错.而wk.parallelism是一个指针,多个worker共享一部分存储,其中wk.parallelism.max用来记录运行过程中出现过的最大worker并行数量.</p>
</blockquote>
<p>继续改代码.</p>
<p>第三版-最后的提交结果</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">schedule</span><span class="params">(jobName <span class="keyword">string</span>, mapFiles []<span class="keyword">string</span>, nReduce <span class="keyword">int</span>, phase jobPhase, registerChan <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> ntasks <span class="keyword">int</span></span><br><span class="line">	<span class="keyword">var</span> n_other <span class="keyword">int</span> <span class="comment">// number of inputs (for reduce) or outputs (for map)</span></span><br><span class="line">	<span class="keyword">switch</span> phase &#123;</span><br><span class="line">	<span class="keyword">case</span> mapPhase:</span><br><span class="line">		ntasks = <span class="built_in">len</span>(mapFiles)</span><br><span class="line">		n_other = nReduce</span><br><span class="line">	<span class="keyword">case</span> reducePhase:</span><br><span class="line">		ntasks = nReduce</span><br><span class="line">		n_other = <span class="built_in">len</span>(mapFiles)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">"Schedule: %v %v tasks (%d I/Os)\n"</span>, ntasks, phase, n_other)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// All ntasks tasks have to be scheduled on workers. Once all tasks</span></span><br><span class="line">	<span class="comment">// have completed successfully, schedule() should return.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Your code here (Part III, Part IV).</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// worker设成工作池模式.模仿Go-by-example的worker-pools例子[https://gobyexample.com/worker-pools]</span></span><br><span class="line">	<span class="comment">// 新来的worker怎么办? 使用另外一个协程阻塞在registerChan这个channel上面,一旦有新来的worker,再启动一个新的协程来进行同步rpc调用</span></span><br><span class="line">	<span class="comment">// 最终目标是把ntasks个任务分配给若干个worker,在schedule()的尾部,需要等待所有任务处理完.</span></span><br><span class="line"></span><br><span class="line">	taskPool := <span class="built_in">make</span>(<span class="keyword">chan</span> DoTaskArgs, ntasks)</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 不开一个新的协程去负责接收registerChan里面的worker好像不行,因为不知道会有多少个worker会来,以及多久来.而registerChan</span></span><br><span class="line">	<span class="comment">// 又是unbuffer的,接收不到就会阻塞</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="comment">// 这个for循环一定要有,否则!!!后面的代码执行一次之后就退出了,也就是会导致只会创建出一个worker协程,这不是我们想要的结果.</span></span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="comment">// 从forwardRegistration收到一个worker的地址</span></span><br><span class="line">			worker := &lt;-registerChan</span><br><span class="line">			<span class="comment">//fmt.Println("launch a new worker goroutine", worker)</span></span><br><span class="line">			<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">				<span class="keyword">for</span> taskArgs := <span class="keyword">range</span> taskPool &#123; <span class="comment">// 参考Go-by-example的worker-pools例子[https://gobyexample.com/worker-pools]</span></span><br><span class="line">					call(worker, <span class="string">"Worker.DoTask"</span>, taskArgs, <span class="literal">nil</span>)</span><br><span class="line">					wg.Done()</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建每个任务对应的DoTaskArgs结构体,然后放入taskPool</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; ntasks; i++ &#123;</span><br><span class="line">		<span class="keyword">var</span> doTaskArgs DoTaskArgs;</span><br><span class="line">		doTaskArgs.JobName = jobName</span><br><span class="line">		doTaskArgs.TaskNumber = i</span><br><span class="line">		doTaskArgs.NumOtherPhase = n_other</span><br><span class="line">		<span class="keyword">switch</span> phase &#123;</span><br><span class="line">		<span class="keyword">case</span> mapPhase:</span><br><span class="line">			doTaskArgs.Phase = mapPhase</span><br><span class="line">			doTaskArgs.File = mapFiles[i]</span><br><span class="line">		<span class="keyword">case</span> reducePhase:</span><br><span class="line">			doTaskArgs.Phase = reducePhase</span><br><span class="line">		&#125;</span><br><span class="line">		taskPool &lt;- doTaskArgs</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">"Schedule: %v done\n"</span>, phase)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://mojiajun.github.io/post/bbc35084.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mojiajun">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mojiajun">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/post/bbc35084.html" itemprop="url">mit6824-lab1-part-II</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-27T00:00:00+08:00">
                2019-09-27
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/分布式/" itemprop="url" rel="index">
                    <span itemprop="name">分布式</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/分布式/mit6824/" itemprop="url" rel="index">
                    <span itemprop="name">mit6824</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>[TOC]</p>
<h2 id="lab1-Part-I-Map-Reduce-input-and-output-part-II"><a href="#lab1-Part-I-Map-Reduce-input-and-output-part-II" class="headerlink" title="lab1-Part-I-Map/Reduce input and output-part-II"></a>lab1-Part-I-Map/Reduce input and output-part-II</h2><h3 id="实现mapF和reduceF"><a href="#实现mapF和reduceF" class="headerlink" title="实现mapF和reduceF"></a>实现mapF和reduceF</h3><p>有一个坑.在mapF里面</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapF</span><span class="params">(filename <span class="keyword">string</span>, contents <span class="keyword">string</span>)</span> []<span class="title">mapreduce</span>.<span class="title">KeyValue</span></span> &#123;</span><br><span class="line">	<span class="comment">// Your code here (Part II).</span></span><br><span class="line">	<span class="comment">// 划分词</span></span><br><span class="line">	<span class="comment">// 划分词这里得搞明白...</span></span><br><span class="line">	<span class="comment">// words := strings.Fields(contents)  // 不行.为什么待研究.</span></span><br><span class="line">	words := strings.FieldsFunc(contents, <span class="function"><span class="keyword">func</span><span class="params">(c <span class="keyword">rune</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">		<span class="keyword">return</span> !unicode.IsLetter(c)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 先构造一个map</span></span><br><span class="line">	mapping := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>) <span class="comment">// 有溢出的风险</span></span><br><span class="line">	<span class="keyword">for</span> _, w := <span class="keyword">range</span> words &#123;</span><br><span class="line">		mapping[w]++</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//把map的数据写入res</span></span><br><span class="line">	<span class="keyword">var</span> res []mapreduce.KeyValue</span><br><span class="line">	<span class="keyword">for</span> key, val := <span class="keyword">range</span> mapping &#123;</span><br><span class="line">		res = <span class="built_in">append</span>(res, mapreduce.KeyValue&#123;Key: key, Value: strconv.Itoa(val)&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reduceF</span><span class="params">(key <span class="keyword">string</span>, values []<span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="comment">// Your code here (Part II).</span></span><br><span class="line">	<span class="keyword">var</span> valInt <span class="keyword">int</span></span><br><span class="line">	<span class="keyword">for</span> _, val := <span class="keyword">range</span> values &#123;</span><br><span class="line">		valIntTemp, err := strconv.Atoi(val);</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Fatal(<span class="string">"reduceF() fail "</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">		valInt += valIntTemp</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> strconv.Itoa(valInt) <span class="comment">// 这么写的话也可能溢出.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="存疑的"><a href="#存疑的" class="headerlink" title="存疑的"></a>存疑的</h3><p>1.merge阶段的merge() {}并不能解决重复key的问题.写了个测试这个merge()可能会出问题的代码.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"bufio"</span></span><br><span class="line">	<span class="string">"encoding/json"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"log"</span></span><br><span class="line">	<span class="string">"os"</span></span><br><span class="line">	<span class="string">"sort"</span></span><br><span class="line">	<span class="string">"strconv"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> nReduceTest = <span class="number">3</span></span><br><span class="line"><span class="keyword">const</span> jobName = <span class="string">"wcseq"</span>  <span class="comment">// 根据实际测试情况修改.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> KeyValue <span class="keyword">struct</span> &#123;</span><br><span class="line">	Key   <span class="keyword">string</span></span><br><span class="line">	Value <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> prefix = <span class="string">"$填入你的路径/6.824/src/main/"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeName</span><span class="params">(jobName <span class="keyword">string</span>, reduceTask <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> prefix + <span class="string">"mrtmp."</span> + jobName + <span class="string">"-res-"</span> + strconv.Itoa(reduceTask)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeTestFuntion</span><span class="params">()</span></span> &#123;</span><br><span class="line">	kvs := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; nReduceTest; i++ &#123;</span><br><span class="line">		p := mergeName(jobName, i)</span><br><span class="line">		fmt.Printf(<span class="string">"Merge: read %s\n"</span>, p)</span><br><span class="line">		file, err := os.Open(p)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Fatal(<span class="string">"Merge: "</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">		dec := json.NewDecoder(file)</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="keyword">var</span> kv KeyValue</span><br><span class="line">			err = dec.Decode(&amp;kv)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">			kvs[kv.Key] = kv.Value</span><br><span class="line">		&#125;</span><br><span class="line">		file.Close()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> keys []<span class="keyword">string</span></span><br><span class="line">	<span class="keyword">for</span> k := <span class="keyword">range</span> kvs &#123;</span><br><span class="line">		keys = <span class="built_in">append</span>(keys, k)</span><br><span class="line">	&#125;</span><br><span class="line">	sort.Strings(keys)</span><br><span class="line"></span><br><span class="line">	file, err := os.Create(prefix + <span class="string">"mrtmp."</span> + jobName + <span class="string">"-MergeTest"</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(<span class="string">"Merge: create "</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	w := bufio.NewWriter(file)</span><br><span class="line">	<span class="keyword">for</span> _, k := <span class="keyword">range</span> keys &#123;</span><br><span class="line">		fmt.Fprintf(w, <span class="string">"%s: %s\n"</span>, k, kvs[k])</span><br><span class="line">	&#125;</span><br><span class="line">	w.Flush()</span><br><span class="line">	file.Close()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	mergeTestFuntion()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后把mrtmp.wcseq-res-0,mrtmp.wcseq-res-1,mrtmp.wcseq-res-2这些文件里面故意设的至少有两个key一样的情况.因为kvs[kv.Key] = kv.Value这一行代码,所以结果会出问题.统计出来的数字不对.</p>
<p>但是为什么统计词数是正确的呢???</p>
<p>原因在于doMap()阶段的ihash(kv.Key)%nReduce.</p>
<blockquote>
<p>反证法:要想在merge()阶段出现&gt;=2个相同的key.必须在至少两个不同的mrtmp.xxx-res-…,mrtmp.wcseq-res-…文件里面出现出现重复的key.而假设这两个文件分别是mrtmp.xxx-res-X,mrtmp.xxx-res-Y,<br>而来自于<br>mrtmp.test-0-X<br>mrtmp.test-1-X<br>mrtmp.test-2-X<br>…</p>
<p>mrtmp.xxx-res-Y来自于<br>mrtmp.test-0-Y<br>mrtmp.test-1-Y<br>mrtmp.test-2-Y<br>…</p>
<p>所以重复的key来自于mrtmp.test-0-X,mrtmp.test-1-Y这种情况.所以在reduce这个维度的索引的X!=Y.<br>而重复的key必定ihash(kv.Key)%nReduce一样,也就是会放置到同一个[reduce这个维度的索引].出现矛盾!!!</p>
<p>所以哪怕用mit-6824里master_splitmerge.go里的merge()阶段的代码,在比如word count这样的问题里也不会出现问题.而用户可以传入的函数只有mapF和reduceF.分别对应map阶段和reduce阶段,用户对merge阶段无控制权.</p>
</blockquote>
<p>2.strings.FieldsFunc和strings.Fields的区别</p>
<p>FieldsFunc额外要传入一个函数.为什么用Fields会出问题?</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  words := strings.Fields(contents)  // 不行.为什么待研究.</span></span><br><span class="line">	words := strings.FieldsFunc(contents, <span class="function"><span class="keyword">func</span><span class="params">(c <span class="keyword">rune</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">		<span class="keyword">return</span> !unicode.IsLetter(c)</span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>
<p>3.sort -n -k2 mrtmp.wcseq-MergeTest | diff - mrtmp.wcseq.sort &gt; diff.out</p>
<p>sort命令学习一下.</p>
<h3 id="master-worker分布式运行-做完part-III之后再回来看这里"><a href="#master-worker分布式运行-做完part-III之后再回来看这里" class="headerlink" title="master-worker分布式运行(做完part-III之后再回来看这里)"></a>master-worker分布式运行(做完part-III之后再回来看这里)</h3><p>2) Master (e.g., go run wc.go master localhost:7777 x1.txt .. xN.txt)</p>
<p>这种方式只是启动了server端.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Can be run in 3 ways:</span></span><br><span class="line"><span class="comment">// 1) Sequential (e.g., go run wc.go master sequential x1.txt .. xN.txt)</span></span><br><span class="line"><span class="comment">// 2) Master (e.g., go run wc.go master localhost:7777 x1.txt .. xN.txt)</span></span><br><span class="line"><span class="comment">// 3) Worker (e.g., go run wc.go worker localhost:7777 localhost:7778 &amp;)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(os.Args) &lt; <span class="number">4</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"%s: see usage comments in file\n"</span>, os.Args[<span class="number">0</span>])</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> os.Args[<span class="number">1</span>] == <span class="string">"master"</span> &#123;</span><br><span class="line">		<span class="keyword">var</span> mr *mapreduce.Master</span><br><span class="line">		<span class="keyword">if</span> os.Args[<span class="number">2</span>] == <span class="string">"sequential"</span> &#123;</span><br><span class="line">			mr = mapreduce.Sequential(<span class="string">"wcseq"</span>, os.Args[<span class="number">3</span>:], <span class="number">3</span>, mapF, reduceF)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			mr = mapreduce.Distributed(<span class="string">"wcseq"</span>, os.Args[<span class="number">3</span>:], <span class="number">3</span>, os.Args[<span class="number">2</span>])</span><br><span class="line">		&#125;</span><br><span class="line">		mr.Wait()</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		mapreduce.RunWorker(os.Args[<span class="number">2</span>], os.Args[<span class="number">3</span>], mapF, reduceF, <span class="number">100</span>, <span class="literal">nil</span>)</span><br><span class="line">		<span class="comment">// 第一个参数是master address. 第二个参数是worker address</span></span><br><span class="line">		<span class="comment">// 第一个参数谁给它?单独启动?试试</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>启动master,用一个shell</p>
<p>GOPATH=/Users/***/go/src/6824-course-project/6.824 go run wc.go master localhost:7777 pg-wc-testfile-custom.txt pg-wc-testfile-custom-02.txt</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mr = mapreduce.Distributed(<span class="string">"wcseq"</span>, os.Args[<span class="number">3</span>:], <span class="number">3</span>, os.Args[<span class="number">2</span>])</span><br><span class="line"><span class="comment">// 第二个参数,即输入文件列表</span></span><br><span class="line"><span class="comment">// 第三个参数,reduce-3个reduce task</span></span><br><span class="line"><span class="comment">// 第四个参数指定了,master监听的地址.</span></span><br><span class="line"></span><br><span class="line">Args[*]对应的参数:</span><br><span class="line"><span class="keyword">go</span> run wc.<span class="keyword">go</span> /<span class="keyword">var</span>/tmp/<span class="number">824</span><span class="number">-501</span>/mr90843-master</span><br><span class="line"></span><br><span class="line">Args[<span class="number">0</span>]:</span><br><span class="line">/<span class="keyword">var</span>/folders/vh/hz32rv8x2fzfdsqc7xpqq2640000gn/T/<span class="keyword">go</span>-build105600263/b001/exe/wc</span><br><span class="line">Args[<span class="number">1</span>]:</span><br><span class="line">/<span class="keyword">var</span>/tmp/<span class="number">824</span><span class="number">-501</span>/mr90843-master</span><br><span class="line">然后以此类推</span><br><span class="line"></span><br><span class="line">在test_test.<span class="keyword">go</span>里面的使用范例:</span><br><span class="line">	master := port(<span class="string">"master"</span>)</span><br><span class="line">	mr := Distributed(<span class="string">"test"</span>, files, nReduce, master)</span><br></pre></td></tr></table></figure>
<p>启动worker.用另外一个shell</p>
<p>GOPATH=/Users/***/go/src/6824-course-project/6.824 go run wc.go worker localhost:7777 localhost:7778</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mapreduce.RunWorker(os.Args[<span class="number">2</span>], os.Args[<span class="number">3</span>], mapF, reduceF, <span class="number">100</span>, <span class="literal">nil</span>)</span><br><span class="line"><span class="comment">// 第一个参数是master的监听地址</span></span><br><span class="line"><span class="comment">// 第二个参数是worker自己即将监听的地址</span></span><br><span class="line"><span class="comment">// 100代表这个worker只能做100个task</span></span><br><span class="line"></span><br><span class="line">在test_test.<span class="keyword">go</span>里面的使用范例:</span><br><span class="line">		<span class="keyword">go</span> RunWorker(mr.address, port(<span class="string">"worker"</span>+strconv.Itoa(i)),</span><br><span class="line">			MapFunc, ReduceFunc, <span class="number">-1</span>, <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>
<p>为什么测试源里面有数字不行???没统计是和划分有关系吗,估计是,反正是map阶段有问题</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://mojiajun.github.io/post/c77df7da.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mojiajun">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mojiajun">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/post/c77df7da.html" itemprop="url">mit6824-lab1-part-I</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-25T00:00:00+08:00">
                2019-09-25
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/分布式/" itemprop="url" rel="index">
                    <span itemprop="name">分布式</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/分布式/mit6824/" itemprop="url" rel="index">
                    <span itemprop="name">mit6824</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>[TOC]</p>
<h2 id="lab1-Part-I-Map-Reduce-input-and-output-part-I"><a href="#lab1-Part-I-Map-Reduce-input-and-output-part-I" class="headerlink" title="lab1-Part-I-Map/Reduce input and output-part-I"></a>lab1-Part-I-Map/Reduce input and output-part-I</h2><p>目标:实现doMap()和doReduce(),lab2-Part-II才会去写MapFunc和ReduceFunc这两个函数.通过写lab2-Part-I,可以熟悉map-reduce的基本流程.非常重要.在lab1-part-I里,因为执行的是Sequential(),所以master直接把doMap()和doReduce()的具体任务都做了…分布式情况下不是这样的,见</p>
<blockquote>
<p>  The master considers each input file to be one map task, and calls <code>doMap()</code> [<code>common_map.go</code>] at least once for each map task. It does so either directly (when using <code>Sequential()</code>) or by issuing the <code>DoTask</code> RPC to a worker [<code>worker.go</code>].</p>
</blockquote>
<p>doReduce()函数类似.在这里也是由master直接做了.</p>
<h3 id="直接运行会存在一个bug"><a href="#直接运行会存在一个bug" class="headerlink" title="直接运行会存在一个bug"></a>直接运行会存在一个bug</h3><p>./master_rpc.go:48:10: debug call has arguments but no formatting directives</p>
<p><a href="https://segmentfault.com/q/1010000017341154" target="_blank" rel="noopener">6.824执行用例报错debug call has arguments but no formatting directives</a></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">				debug(<span class="string">"RegistrationServer: accept error"</span>, err)</span><br><span class="line"><span class="comment">// 其实现:</span></span><br><span class="line"><span class="comment">// debug() will only print if debugEnabled is true</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">debug</span><span class="params">(format <span class="keyword">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> debugEnabled &#123;</span><br><span class="line">		n, err = fmt.Printf(format, a...)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>改成</p>
<p>error用%v可以吗?</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">debug(<span class="string">"RegistrationServer: accept error, %v"</span>, err)</span><br></pre></td></tr></table></figure>
<h3 id="Master-run-和Sequential"><a href="#Master-run-和Sequential" class="headerlink" title="Master.run()和Sequential()"></a>Master.run()和Sequential()</h3><p>一个关键的技巧,传递函数进去…!!!</p>
<p>写了个例子.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PrintType <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	print1 PrintType = <span class="string">"print1"</span></span><br><span class="line">	print2           = <span class="string">"print2"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">(customPrint <span class="keyword">func</span>(printType PrintType)</span>)</span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"Prelude..."</span>)</span><br><span class="line"></span><br><span class="line">	customPrint(print2)</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">"Finale..."</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	run(<span class="function"><span class="keyword">func</span><span class="params">(printType PrintType)</span></span> &#123;</span><br><span class="line">		<span class="keyword">switch</span> printType &#123;</span><br><span class="line">		<span class="keyword">case</span> print1:</span><br><span class="line">			fmt.Println(<span class="string">"print1"</span>)</span><br><span class="line">		<span class="keyword">case</span> print2:</span><br><span class="line">			fmt.Println(<span class="string">"print2"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>带返回值<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PrintType <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	print1 PrintType = <span class="string">"print1"</span></span><br><span class="line">	print2           = <span class="string">"print2"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">(customPrint <span class="keyword">func</span>(printType PrintType)</span> <span class="params">(<span class="keyword">bool</span>, error)</span>)</span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"Prelude..."</span>)</span><br><span class="line"></span><br><span class="line">	boolval, err := customPrint(print2)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(boolval)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">"Finale..."</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	run(<span class="function"><span class="keyword">func</span><span class="params">(printType PrintType)</span> <span class="params">(<span class="keyword">bool</span>, error)</span></span> &#123;</span><br><span class="line">		<span class="keyword">switch</span> printType &#123;</span><br><span class="line">		<span class="keyword">case</span> print1:</span><br><span class="line">			fmt.Println(<span class="string">"print1"</span>)</span><br><span class="line">		<span class="keyword">case</span> print2:</span><br><span class="line">			fmt.Println(<span class="string">"print2"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">nil</span></span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其他技巧…</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   res1, _ := <span class="function"><span class="keyword">func</span><span class="params">(n1 <span class="keyword">int</span>, n2 <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">      <span class="keyword">return</span> n1 + n2, <span class="literal">nil</span></span><br><span class="line">   &#125;(<span class="number">10</span>, <span class="number">30</span>) <span class="comment">//括号里的10,30 就相当于参数列表，分别对应n1和n2</span></span><br><span class="line"></span><br><span class="line">   fmt.Println(<span class="string">"res1="</span>, res1)</span><br><span class="line">&#125;</span><br><span class="line">如果是<span class="keyword">go</span> 匿名函数</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//fmt.Println("res1=", res1)</span></span><br><span class="line">	done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(n1 <span class="keyword">int</span>, n2 <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">		res := n1 + n2</span><br><span class="line">		fmt.Println(<span class="string">"res1="</span>, res)</span><br><span class="line">		done&lt;-<span class="literal">true</span></span><br><span class="line">		<span class="keyword">return</span> res  <span class="comment">// 如果return的话会返回给谁?</span></span><br><span class="line">	&#125;(<span class="number">24</span>, <span class="number">30</span>)</span><br><span class="line">	&lt;-done</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后是制造输入文件的函数makeInputs(),没啥好说的.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Make input file</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeInputs</span><span class="params">(num <span class="keyword">int</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> names []<span class="keyword">string</span></span><br><span class="line">	<span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> f := <span class="number">0</span>; f &lt; num; f++ &#123;</span><br><span class="line">		names = <span class="built_in">append</span>(names, fmt.Sprintf(<span class="string">"824-mrinput-%d.txt"</span>, f))</span><br><span class="line">		file, err := os.Create(names[f])</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Fatal(<span class="string">"mkInput: "</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">		w := bufio.NewWriter(file)</span><br><span class="line">		<span class="keyword">for</span> i &lt; (f+<span class="number">1</span>)*(nNumber/num) &#123;  <span class="comment">// 10万/num</span></span><br><span class="line">			fmt.Fprintf(w, <span class="string">"%d\n"</span>, i)</span><br><span class="line">			i++</span><br><span class="line">		&#125;</span><br><span class="line">		w.Flush()</span><br><span class="line">		file.Close()  <span class="comment">// 什么情况用这种什么情况用defer?</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> names</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The master considers <strong>each input file</strong> to be <strong>one map task</strong>, and calls <code>doMap()</code> [<code>common_map.go</code>] <strong>at least once for each map task.</strong></p>
<h3 id="hash函数"><a href="#hash函数" class="headerlink" title="hash函数"></a>hash函数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先不管这个hash函数.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ihash</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	h := fnv.New32a()  <span class="comment">// 其实返回的是个整型指针</span></span><br><span class="line">	h.Write([]<span class="keyword">byte</span>(s))</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">int</span>(h.Sum32() &amp; <span class="number">0x7fffffff</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="string-Field"><a href="#string-Field" class="headerlink" title="string.Field"></a>string.Field</h3><p>其实就是进行分词,把一个s分成若干个词,以空格为界限,返回[]</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fields</span><span class="params">(s <span class="keyword">string</span>)</span> []<span class="title">string</span></span></span><br></pre></td></tr></table></figure>
<p>为了理解,写了个测试程序<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> KeyValue <span class="keyword">struct</span> &#123;</span><br><span class="line">	key   <span class="keyword">string</span></span><br><span class="line">	value <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kv *KeyValue)</span> <span class="title">PrintKV</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"key: "</span>, kv.key)</span><br><span class="line">	fmt.Println(<span class="string">"value: "</span>, kv.value)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">partitionWord</span><span class="params">(value <span class="keyword">string</span>)</span> <span class="params">(res []KeyValue)</span></span> &#123;</span><br><span class="line">	words := strings.Fields(value) <span class="comment">// 输入string,返回[]string 进行分词??</span></span><br><span class="line">	<span class="keyword">for</span> _, w := <span class="keyword">range</span> words &#123;</span><br><span class="line">		kv := KeyValue&#123;w, <span class="string">"3"</span>&#125;</span><br><span class="line">		res = <span class="built_in">append</span>(res, kv)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	teststr := <span class="string">"abfsdf fsf ifsfen 1324234 fsdkf djkfsjfs"</span></span><br><span class="line">	res := partitionWord(teststr)</span><br><span class="line">	fmt.Println(res)</span><br><span class="line">	<span class="keyword">for</span> _, kv := <span class="keyword">range</span> res &#123;</span><br><span class="line">		err := kv.PrintKV();</span><br><span class="line">		<span class="keyword">if</span> (err == <span class="literal">nil</span>) &#123;</span><br><span class="line">			<span class="comment">//</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="User-Define-map和reduce函数"><a href="#User-Define-map和reduce函数" class="headerlink" title="User-Define map和reduce函数"></a>User-Define map和reduce函数</h3><p>这个是Sequential()这个测试函数要用的.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Split in words</span></span><br><span class="line"><span class="comment">// @input: value string,</span></span><br><span class="line"><span class="comment">// @ouput: 键值对的slice</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MapFunc</span><span class="params">(file <span class="keyword">string</span>, value <span class="keyword">string</span>)</span> <span class="params">(res []KeyValue)</span></span> &#123;</span><br><span class="line">	debug(<span class="string">"Map %v\n"</span>, value)</span><br><span class="line">	words := strings.Fields(value)  <span class="comment">// 输入string,返回[]string 进行分词</span></span><br><span class="line">	<span class="keyword">for</span> _, w := <span class="keyword">range</span> words &#123;</span><br><span class="line">		kv := KeyValue&#123;w, <span class="string">""</span>&#125;  <span class="comment">// 每个词的value部分是空的,即""</span></span><br><span class="line">		res = <span class="built_in">append</span>(res, kv)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="写doMap"><a href="#写doMap" class="headerlink" title="写doMap()"></a>写doMap()</h3><p>先看MapFunc()这个User-Define的作用,然后看注释,</p>
<h4 id="byte和string转换"><a href="#byte和string转换" class="headerlink" title="[]byte和string转换"></a>[]byte和string转换</h4><p><a href="https://blog.csdn.net/a64180190/article/details/76528063" target="_blank" rel="noopener">https://blog.csdn.net/a64180190/article/details/76528063</a></p>
<p>string 不能直接和byte数组转换<br>string可以和byte的切片转换<br> []byte(str),string(data[:])</p>
<h4 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h4><p>json.Marshal(kv)和encode那种方法的区别?</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doMap</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	jobName <span class="keyword">string</span>,                                         // the name of the MapReduce job</span></span></span><br><span class="line"><span class="function"><span class="params">	mapTask <span class="keyword">int</span>,                                            // which <span class="keyword">map</span> task this is  // 其实就是个索引而已.</span></span></span><br><span class="line"><span class="function"><span class="params">	inFile <span class="keyword">string</span>,                                          // 输入文件名</span></span></span><br><span class="line">	nReduce int,                                            // the number of reduce task that will be run ("R" in the paper)</span><br><span class="line">	mapF <span class="function"><span class="keyword">func</span><span class="params">(filename <span class="keyword">string</span>, contents <span class="keyword">string</span>)</span> []<span class="title">KeyValue</span>, // 参数为什么要命名?不命名也可以吧.测试了下，形参不命名也可以呀</span></span><br><span class="line"><span class="function">)</span> &#123;</span><br><span class="line">	<span class="comment">// 读取文件</span></span><br><span class="line">	data, err := ioutil.ReadFile(inFile)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(<span class="string">"doMap readFile fail"</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// []byte -&gt; string</span></span><br><span class="line">	fileContent := <span class="keyword">string</span>(data[:]) <span class="comment">// 文件过大怎么办?</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 1. 分词</span></span><br><span class="line">	<span class="comment">// 2. 为每个词建立key-value, 然后得到kvResults</span></span><br><span class="line">	kvResults := mapF(inFile, fileContent) <span class="comment">// 第一个参数其实不用</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 然后进行划分</span></span><br><span class="line">	<span class="comment">// 划分结果放入intermediate file</span></span><br><span class="line">	<span class="comment">// 生成intermediate file name</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> r := <span class="number">0</span>; r &lt; nReduce; r++ &#123;</span><br><span class="line">		intermediateFileName := reduceName(jobName, mapTask, r)</span><br><span class="line">		file, err := os.Create(intermediateFileName)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Fatal(<span class="string">"doMap() call os.Create() fail"</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">		w := bufio.NewWriter(file)</span><br><span class="line">		<span class="keyword">for</span> _, kv := <span class="keyword">range</span> kvResults &#123; <span class="comment">// 这种解法的话得做重复的很多次遍历，不好...暂时也想不到更好的办法...</span></span><br><span class="line">			<span class="keyword">if</span> ihash(kv.Key)%nReduce == r &#123;</span><br><span class="line">				<span class="keyword">if</span> data, err := json.Marshal(kv); err == <span class="literal">nil</span> &#123;</span><br><span class="line">					<span class="keyword">if</span> _, err := fmt.Fprintf(w, <span class="string">"%s\n"</span>, data); err != <span class="literal">nil</span> &#123;</span><br><span class="line">						log.Fatal(<span class="string">"doMap() fmt.Fprintf() error"</span>)</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err := w.Flush(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Fatal(<span class="string">"doMap() w.Flush() error"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err := file.Close(); err != <span class="literal">nil</span> &#123; <span class="comment">// 什么情况用这种什么情况用defer?在for结束的时候会关闭吗???</span></span><br><span class="line">			log.Fatal(<span class="string">"doMap() file.Close() error"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="写doReduce"><a href="#写doReduce" class="headerlink" title="写doReduce()"></a>写doReduce()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doReduce</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	jobName <span class="keyword">string</span>, // the name of the whole MapReduce job</span></span></span><br><span class="line"><span class="function"><span class="params">	reduceTask <span class="keyword">int</span>, // which reduce task this is,即reduce的索引,表示当前doReduce是第几个</span></span></span><br><span class="line"><span class="function"><span class="params">	outFile <span class="keyword">string</span>, // write the output here,和doMap()</span>不同,这个是由上一级函数传进来的文件名,由<span class="title">mergeName</span><span class="params">()</span>生成的文件名.</span></span><br><span class="line"><span class="function">	// 得在<span class="title">doReduce</span>里面创建它</span></span><br><span class="line">	nMap int,       // the number of map tasks that were run ("M" in the paper),即doMap()的总个数</span><br><span class="line">	reduceF <span class="function"><span class="keyword">func</span><span class="params">(key <span class="keyword">string</span>, values []<span class="keyword">string</span>)</span> <span class="title">string</span>,</span></span><br><span class="line"><span class="function">)</span> &#123;</span><br><span class="line">	<span class="comment">// doReduce会执行nReduce次,所以每次执行的时候都需要处理nMap个intermediate文件,</span></span><br><span class="line">	<span class="comment">// 也就是把这nMap个intermediate文件朝一个文件outFile里面写入</span></span><br><span class="line">	outFileStream, err := os.Create(outFile)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"doReduce Create outFile fail "</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//defer outFileStream.Close()</span></span><br><span class="line"></span><br><span class="line">	w := bufio.NewWriter(outFileStream)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 用于存放各个doMap()生成的intermediate文件中的kv,把value改成[]string,是因为可以有多个共同的key，对应不同的value</span></span><br><span class="line">	keyValuesCollect := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">string</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 读取intermediate文件,类似mrtmp.test-0-1这种格式</span></span><br><span class="line">	<span class="comment">// 读取文件，存入keyValuesCollect</span></span><br><span class="line">	<span class="keyword">for</span> m := <span class="number">0</span>; m &lt; nMap; m++ &#123;</span><br><span class="line">		file, err := os.Open(reduceName(jobName, m, reduceTask))</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Fatal(<span class="string">"doReduce open intermediate fail"</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">		dec := json.NewDecoder(file)</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="keyword">var</span> kv KeyValue</span><br><span class="line">			err = dec.Decode(&amp;kv)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">			keyValuesCollect[kv.Key] = <span class="built_in">append</span>(keyValuesCollect[kv.Key], kv.Value)</span><br><span class="line">			<span class="comment">// 这样的话不能有两个一样的key了. 重复的话怎么办? value设置成[]string...</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err := file.Close(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Fatal(<span class="string">"doReduce close file fail "</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 根据键值排序</span></span><br><span class="line">	<span class="keyword">var</span> keys []<span class="keyword">string</span></span><br><span class="line">	<span class="keyword">for</span> key := <span class="keyword">range</span> keyValuesCollect &#123; <span class="comment">// 得到的是key string</span></span><br><span class="line">		keys = <span class="built_in">append</span>(keys, key)</span><br><span class="line">	&#125;</span><br><span class="line">	sort.Strings(keys)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 构造json encoder对outFileStream</span></span><br><span class="line">	enc := json.NewEncoder(outFileStream)</span><br><span class="line">	<span class="keyword">for</span> _, key := <span class="keyword">range</span> keys &#123; <span class="comment">// _ 得到的是索引</span></span><br><span class="line">		res := reduceF(key, keyValuesCollect[key])</span><br><span class="line">		<span class="keyword">if</span> err := enc.Encode(KeyValue&#123;key, res&#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Fatal(<span class="string">"doReduce enc.Encode() fail "</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err := w.Flush(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(<span class="string">"doReduce w.Flush() fail "</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err := outFileStream.Close(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(<span class="string">"doReduce outFileStream.Close() fail "</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>当已经对整体有个大概了解,而且doMap()和doReduce()函数都已经实现完成之后,分析一下:</p>
<h4 id="生成的中间文件"><a href="#生成的中间文件" class="headerlink" title="生成的中间文件"></a>生成的中间文件</h4><blockquote>
<p>  824-mrinput-0.txt -&gt;mrtmp.test-0-0-&gt;mrtmp.test-res-0-&gt;mrtmp.test<br>  三个箭头分别对应map-reduce-merge三个处理阶段.</p>
</blockquote>
<p>当通过func TestSequentialSingle(t <em>testing.T) {}和func TestSequentialMany(t </em>testing.T) {}之后,我们可以来看下生成的中间文件,在test_test.go里面,注释掉cleanup(mr),这个函数会把中间生成的文件删除掉.为了看到中间文件,先注释掉这一行.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSequentialMany</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	mr := Sequential(<span class="string">"test"</span>, makeInputs(<span class="number">5</span>), <span class="number">3</span>, MapFunc, ReduceFunc)</span><br><span class="line">	mr.Wait()</span><br><span class="line">	check(t, mr.files)</span><br><span class="line">	checkWorker(t, mr.stats)</span><br><span class="line">	<span class="comment">//cleanup(mr)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查看输入文件.ls 824*</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">824-mrinput-0.txt </span><br><span class="line">824-mrinput-1.txt </span><br><span class="line">824-mrinput-2.txt </span><br><span class="line">824-mrinput-3.txt </span><br><span class="line">824-mrinput-4.txt</span><br></pre></td></tr></table></figure>
<p>5个文件,由makeInputs(5)生成.</p>
<p>mapreduce论文里说会生成M*R个中间文件,代码注释里也说了,那么来看一下:</p>
<p>在6.824/src/mapreduce目录下,执行ls -l mrtmp*能看到</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">mrtmp.test   // mr.merge()里面制造.</span><br><span class="line">mrtmp.test-0-0   // doMap()生成  // 每一个doMap会生成nReduce个mrtmp.xxx-*-*这样的文件</span><br><span class="line">mrtmp.test-0-1</span><br><span class="line">mrtmp.test-0-2</span><br><span class="line">mrtmp.test-1-0</span><br><span class="line">mrtmp.test-1-1</span><br><span class="line">mrtmp.test-1-2</span><br><span class="line">mrtmp.test-2-0</span><br><span class="line">mrtmp.test-2-1</span><br><span class="line">mrtmp.test-2-2</span><br><span class="line">mrtmp.test-3-0</span><br><span class="line">mrtmp.test-3-1</span><br><span class="line">mrtmp.test-3-2</span><br><span class="line">mrtmp.test-4-0</span><br><span class="line">mrtmp.test-4-1</span><br><span class="line">mrtmp.test-4-2     // 这15个文件分别由5个doMap()函数生成.</span><br><span class="line">mrtmp.test-res-0   // 每个doReduce()生成一个mrtmp.test-res-*</span><br><span class="line">mrtmp.test-res-1   </span><br><span class="line">mrtmp.test-res-2</span><br></pre></td></tr></table></figure>
<p>总体来说,比如824-mrinput-2.txt,被第三个doMap()读入,它会生成,<br>mrtmp.test-2-0<br>mrtmp.test-2-1<br>mrtmp.test-2-2<br>这三个文件,以此类推其他的doMap()读入了什么,又输出了什么.第一个数字2代表的刚好就是第三个doMap()</p>
<p>再看第二个doReduce().读入5个文件<br>mrtmp.test-0-1<br>mrtmp.test-1-1<br>mrtmp.test-2-1<br>mrtmp.test-3-1<br>mrtmp.test-4-1<br>然后输出一个文件:mrtmp.test-res-1,其他以此类推</p>
<p>最后的mr.merge()阶段.<br>读入<br>mrtmp.test-res-0<br>mrtmp.test-res-1<br>mrtmp.test-res-2</p>
<p>输出mrtmp.test</p>
<h3 id="存疑的"><a href="#存疑的" class="headerlink" title="存疑的"></a>存疑的</h3><p>1.JSON的decoder和.Decode()和unmar这种的区别?doMap()用的不是Encode().也没啥影响啊</p>
<p>2.check()代码没读.</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://mojiajun.github.io/post/d800d427.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mojiajun">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mojiajun">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/post/d800d427.html" itemprop="url">Leecode-BinaryTree前序中序后序(非递归+stack)和(MorrisTraversal)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-08-08T00:00:00+08:00">
                2019-08-08
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Leecode/" itemprop="url" rel="index">
                    <span itemprop="name">Leecode</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>分别是Leecode94-144-145三道题,这里不讨论递归调用(很简单).</p>
<h2 id="非递归-stack"><a href="#非递归-stack" class="headerlink" title="非递归+stack"></a>非递归+stack</h2><p>时间复杂度O(n),空间复杂度O(h),h是树的高度</p>
<p>中序前序代码结构差不多,后序在它们的基础上稍微改改.(后序稍微麻烦点)</p>
<h3 id="中序"><a href="#中序" class="headerlink" title="中序"></a>中序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> result;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; bufstack;</span><br><span class="line">        TreeNode *cur = root;</span><br><span class="line">        <span class="keyword">while</span> (!bufstack.empty() || cur) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur) &#123;</span><br><span class="line">                bufstack.push(cur);</span><br><span class="line">                cur = cur-&gt;left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = bufstack.top();</span><br><span class="line">                result.push_back(cur-&gt;val);</span><br><span class="line">                bufstack.pop();</span><br><span class="line">                cur = cur-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="前序"><a href="#前序" class="headerlink" title="前序"></a>前序</h3><p>和中序遍历只差一行.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> result;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; bufstack;</span><br><span class="line">        TreeNode *cur = root;</span><br><span class="line">        <span class="keyword">while</span> (!bufstack.empty() || cur) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur) &#123;</span><br><span class="line">                bufstack.push(cur);</span><br><span class="line">                result.push_back(cur-&gt;val);</span><br><span class="line">                cur = cur-&gt;left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = bufstack.top();</span><br><span class="line">                bufstack.pop();</span><br><span class="line">                cur = cur-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="后序"><a href="#后序" class="headerlink" title="后序"></a>后序</h3><p>这次的写法还是与前序中序的写法有些接近的.好记点.在前序中序的基础上稍微改改.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; postorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> result;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; bufstack;</span><br><span class="line">        TreeNode *cur = root;</span><br><span class="line">        TreeNode *lastcur;  <span class="comment">// 记住cur的上一个位置</span></span><br><span class="line">        <span class="keyword">while</span> (!bufstack.empty() || cur) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur) &#123;</span><br><span class="line">                bufstack.push(cur);</span><br><span class="line">                cur = cur-&gt;left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                cur = bufstack.top();</span><br><span class="line">                bufstack.pop();</span><br><span class="line">                <span class="keyword">if</span> (!cur-&gt;right || cur-&gt;right == lastcur) &#123;</span><br><span class="line">                    result.push_back(cur-&gt;val);  </span><br><span class="line">                    <span class="comment">//如果上一次访问的是右节点,或者右节点为空,才可以访问这个节点. </span></span><br><span class="line">                    lastcur = cur;</span><br><span class="line">                    cur = <span class="literal">NULL</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    bufstack.push(cur);  </span><br><span class="line">                    <span class="comment">//如果是这种情况,右节点存在且还没访问右节点,那么根节点要再次入栈.// 两次进栈</span></span><br><span class="line">                    cur = cur-&gt;right;     </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>针对二次进栈的优化.见下面👇</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; postorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> result;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; bufstack;</span><br><span class="line">        TreeNode *cur = root;</span><br><span class="line">        TreeNode *lastcur;  <span class="comment">// 记住cur的上一个位置</span></span><br><span class="line">        <span class="keyword">while</span> (!bufstack.empty() || cur) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur) &#123;</span><br><span class="line">                bufstack.push(cur);</span><br><span class="line">                cur = cur-&gt;left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                cur = bufstack.top();</span><br><span class="line">                <span class="keyword">if</span> (!cur-&gt;right || cur-&gt;right == lastcur) &#123;</span><br><span class="line">                    result.push_back(cur-&gt;val);  <span class="comment">//如果上一次访问的是右节点,或者右节点为空,才可以访问这个节点. </span></span><br><span class="line">                    lastcur = cur;</span><br><span class="line">                    cur = <span class="literal">NULL</span>;</span><br><span class="line">                    bufstack.pop();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    cur = cur-&gt;right;     </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="MorrisTraversal"><a href="#MorrisTraversal" class="headerlink" title="MorrisTraversal"></a>MorrisTraversal</h2><p>时间复杂度O(n),空间复杂度O(1)</p>
<p>这个算法里面蕴含的思想就是利用leaf-&gt;left和leaf-&gt;right实现”线索化”,不利用栈从而找到相应的父节点.在这三种Morris遍历里面,都只用了leaf-&gt;right,充分利用已有的资源!降低了空间复杂度,变成O(1),很厉害!</p>
<ul>
<li>三种MorrisTraversal实现(前序中序后序)都只用了leaf-&gt;right</li>
<li>利用leaf的右孩子作为线索,指向在这个leaf之后的父节点的位置,和本科数据结构书(比如严蔚敏数据结构)讲的那种线索二叉树类似,但是!MorrisTraversal这里的节点是下面这样定义的,并没有多出ltag和rtag,而严蔚敏数据结构的节点定义有这两个,所以这个MorrisTraversal方法是真的厉害.本质思想差不多,都是”线索化”.</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x) : val(x), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>这种方法[前序中序后序代码实现的基本结构差不多]是在Leecode这样的TreeNode定义的基础上,在遍历过程中,对leaf-&gt;right添加父节点位置,然后在第二次cur又回来的时候,用pre-&gt;right = NULL;进行还原,所以只在遍历的过程中会使得这棵树的leaf-&gt;right产生些许变化.遍历完了又恢复过来.[会导致树在遍历过程中被改变.这是和递归解法,非递归-stack解法不同的一点.]</p>
</li>
<li><p>这种方法最大的优点是空间复杂度是O(1),constant级的空间复杂度</p>
</li>
</ul>
<h3 id="中序-Morris-inorder-traversal"><a href="#中序-Morris-inorder-traversal" class="headerlink" title="中序-Morris inorder traversal"></a>中序-Morris inorder traversal</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> result;</span><br><span class="line">        TreeNode *cur, *pre;</span><br><span class="line">        cur = root;</span><br><span class="line">        <span class="keyword">while</span>(cur) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;left) &#123;</span><br><span class="line">                pre = cur-&gt;left;</span><br><span class="line">                <span class="keyword">while</span> (pre-&gt;right &amp;&amp; pre-&gt;right != cur) pre = pre-&gt;right;</span><br><span class="line">                <span class="keyword">if</span> (!pre-&gt;right) &#123;</span><br><span class="line">                    pre-&gt;right = cur;</span><br><span class="line">                    cur = cur-&gt;left;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;  <span class="comment">// pre-&gt;right不为空,代表被第一次到这时填充过了,然后去掉它(还原)</span></span><br><span class="line">                    pre-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">                    result.push_back(cur-&gt;val);</span><br><span class="line">                    cur = cur-&gt;right;</span><br><span class="line">                &#125;   </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result.push_back(cur-&gt;val);</span><br><span class="line">                cur = cur-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>实现及理解trick:例如在纸上画一颗这样的树:[1,2,3,4,5,6,null]-(类似leecode里的题那么表示树),然后思考cur和pre的位置变化情况,结合输出结果,[425163]最好形象理解.想象这颗树底下还有很多节点也是一样的.代码都是起作用的,然后多写几遍就明白了…重点是对整个过程在脑海中形象理解.然后体会cur和pre节点的作用</p>
<h3 id="前序-Morris-preorder-traversal"><a href="#前序-Morris-preorder-traversal" class="headerlink" title="前序-Morris preorder traversal"></a>前序-Morris preorder traversal</h3><p>从前序版本的Morris traversal代码改过来的,代码只差了一行</p>
<p>彻底理解上面中序的过程后,然后思考下,把result.push_back(cur-&gt;val);这样的代码删除,改成前序的关键就是把result.push_back(cur-&gt;val);的位置变到cur第一次碰到(!pre-&gt;right)的时候那里.</p>
<p>也就是</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> result;</span><br><span class="line">        TreeNode *cur, *pre;</span><br><span class="line">        cur = root;</span><br><span class="line">        <span class="keyword">while</span>(cur) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;left) &#123;</span><br><span class="line">                pre = cur-&gt;left;</span><br><span class="line">                <span class="keyword">while</span> (pre-&gt;right &amp;&amp; pre-&gt;right != cur) pre = pre-&gt;right;</span><br><span class="line">                <span class="keyword">if</span> (!pre-&gt;right) &#123;</span><br><span class="line">                    result.push_back(cur-&gt;val);</span><br><span class="line">                    pre-&gt;right = cur;</span><br><span class="line">                    cur = cur-&gt;left;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;  <span class="comment">// pre-&gt;right不为空,代表被第一次到这时填充过了,然后去掉它(还原)</span></span><br><span class="line">                    pre-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">                    cur = cur-&gt;right;</span><br><span class="line">                &#125;   </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result.push_back(cur-&gt;val);</span><br><span class="line">                cur = cur-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>只有一行代码不同.剩下的result.push_back(cur-&gt;val);思考下为什么不用改变位置?<br>这种cur节点不存在cur到这里两次,只到这里一次,所以在前序中序都是在这里result.push_back(cur-&gt;val);<br>这种节点就是树:[1,2,3,4,5,6,null]里的节点4这样的节点.</p>
<p>这种节点有什么特点?cur-&gt;left为NULL!</p>
<h3 id="后序-Morris-postorder-traversal"><a href="#后序-Morris-postorder-traversal" class="headerlink" title="后序-Morris postorder traversal"></a>后序-Morris postorder traversal</h3><p>Morris postorder traversal实现比前序中序麻烦在多了个reverseAddNodes()和一个dummy节点</p>
<p>程序主体和Morris in-order traversal,Morris pre-order traversal差不多.多了个reverseAddNodes(cur-&gt;left, pre, result);这里最好结合图来看…下面👇这位朋友后序的图画的不错,可以作为Morris postorder traversal理解的参考</p>
<p><a href="https://www.cnblogs.com/AnnieKim/archive/2013/06/15/MorrisTraversal.html" target="_blank" rel="noopener">Annie Kim’s Blog-Morris Traversal方法遍历二叉树（非递归，不用栈，O(1)空间）</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; postorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> result;</span><br><span class="line">        <span class="function">TreeNode <span class="title">dummy</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        dummy.left = root;</span><br><span class="line">        TreeNode *cur = &amp;dummy, *pre;</span><br><span class="line">        <span class="keyword">while</span>(cur) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;left) &#123;</span><br><span class="line">                pre = cur-&gt;left;</span><br><span class="line">                <span class="keyword">while</span> (pre-&gt;right &amp;&amp; pre-&gt;right != cur) pre = pre-&gt;right;</span><br><span class="line">                <span class="keyword">if</span> (!pre-&gt;right) &#123;</span><br><span class="line">                    pre-&gt;right = cur;</span><br><span class="line">                    cur = cur-&gt;left;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;  <span class="comment">// pre-&gt;right不为空,代表被第一次到这时填充过了,然后去掉它(还原)</span></span><br><span class="line">                    reverseAddNodes(cur-&gt;left, pre, result);</span><br><span class="line">                    pre-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">                    cur = cur-&gt;right;</span><br><span class="line">                &#125;   </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reverseNodes</span><span class="params">(TreeNode* start, TreeNode* end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start == end) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* x = start;</span><br><span class="line">        TreeNode* y = start-&gt;right;</span><br><span class="line">        TreeNode* z;</span><br><span class="line">        <span class="keyword">while</span> (x != end) &#123;</span><br><span class="line">            z = y-&gt;right;</span><br><span class="line">            y-&gt;right = x;</span><br><span class="line">            x = y;</span><br><span class="line">            y = z;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reverseAddNodes</span><span class="params">(TreeNode* start, TreeNode* end, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; result)</span> </span>&#123;</span><br><span class="line">        reverseNodes(start, end);</span><br><span class="line">        TreeNode* node = end;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            result.push_back(node-&gt;val);</span><br><span class="line">            <span class="keyword">if</span> (node == start) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        reverseNodes(end, start);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>reverseAddNodes()这个过程,可以不reverse吗???</p>
<p>修改成用一个临时vector代替reverseNodes函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; postorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> result;</span><br><span class="line">        <span class="function">TreeNode <span class="title">dummy</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        dummy.left = root;</span><br><span class="line">        TreeNode *cur = &amp;dummy, *pre;</span><br><span class="line">        <span class="keyword">while</span>(cur) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;left) &#123;</span><br><span class="line">                pre = cur-&gt;left;</span><br><span class="line">                <span class="keyword">while</span> (pre-&gt;right &amp;&amp; pre-&gt;right != cur) pre = pre-&gt;right;</span><br><span class="line">                <span class="keyword">if</span> (!pre-&gt;right) &#123;</span><br><span class="line">                    pre-&gt;right = cur;</span><br><span class="line">                    cur = cur-&gt;left;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;  <span class="comment">// pre-&gt;right不为空,代表被第一次到这时填充过了,然后去掉它(还原)</span></span><br><span class="line">                    reverseAddNodes(cur-&gt;left, pre, result);</span><br><span class="line">                    pre-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">                    cur = cur-&gt;right;</span><br><span class="line">                &#125;   </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reverseAddNodes</span><span class="params">(TreeNode* start, TreeNode* end, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; result)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">        TreeNode* node = start;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            temp.push_back(node-&gt;val);</span><br><span class="line">            <span class="keyword">if</span> (node == end) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> iter = temp.rbegin(); iter != temp.rend(); ++iter) &#123;</span><br><span class="line">            result.push_back(*iter);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<p>morris是谁?</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://mojiajun.github.io/post/3b45df5e.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mojiajun">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mojiajun">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/post/3b45df5e.html" itemprop="url">C++-虚函数机制-01</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-07-22T00:00:00+08:00">
                2019-07-22
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>[TOC]</p>
<p>这篇是虚函数表vtbl和虚表指针vptr的基础.基本认知,采用的是调试器反汇编看底层的方式.额外提了下空类.</p>
<p>测试环境:<br>x86-64<br>Ubuntu 18.04.2 LTS<br>cat /proc/version</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Linux version 4.15.0-48-generic (buildd@lgw01-amd64-036) (gcc version 7.3.0 (Ubuntu 7.3.0-16ubuntu3)) <span class="comment">#51-Ubuntu SMP Wed Apr 3 08:28:49 UTC 2019</span></span><br></pre></td></tr></table></figure>
<h3 id="虚函数表"><a href="#虚函数表" class="headerlink" title="虚函数表"></a>虚函数表</h3><p>虚函数机制(没分析继承)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">virtual_func_test01.cc</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CVirtual</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">GetNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> _nNumber;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SetNumber</span><span class="params">(<span class="keyword">int</span> nNumber)</span> </span>&#123;</span><br><span class="line">      _nNumber = nNumber;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> _nNumber;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nSizeOfCVirtual = <span class="keyword">sizeof</span>(CVirtual);</span><br><span class="line">    <span class="keyword">int</span> nSizeOfPointer = <span class="keyword">sizeof</span>(<span class="keyword">int</span> *);</span><br><span class="line">    <span class="comment">//printf("the size of CVirtual (in BYTE) is : %d\n", nSizeOfCVirtual);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译:g++ -g -o virtual_func_test01 virtual_func_test01.cc<br>调试:lldb ./virtual_func_test01</p>
<p>main这里打个断点.然后反汇编一下.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(lldb) dis</span><br><span class="line">virtual_func_test01`main:</span><br><span class="line">    0x5555555545fa &lt;+0&gt;:  pushq  %rbp</span><br><span class="line">    0x5555555545fb &lt;+1&gt;:  movq   %rsp, %rbp</span><br><span class="line">    0x5555555545fe &lt;+4&gt;:  movl   $0x10, -0x8(%rbp)</span><br><span class="line">    0x555555554605 &lt;+11&gt;: movl   $0x8, -0x4(%rbp)</span><br><span class="line">-&gt;  0x55555555460c &lt;+18&gt;: movl   $0x0, %eax</span><br><span class="line">    0x555555554611 &lt;+23&gt;: popq   %rbp</span><br><span class="line">    0x555555554612 &lt;+24&gt;: retq</span><br></pre></td></tr></table></figure>
<p>结果分别是(十进制)16和8<br>涉及 rbp,rsp 栈向低地址生长,eax(返回值常用的寄存器,见CSAPP第三章),ATT格式汇编等基础.这里不提了.</p>
<hr>
<p>修改一下代码,创建一个栈上的对象testObj.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">CVirtual <span class="title">testObj</span><span class="params">(<span class="number">10324</span>)</span></span>;</span><br><span class="line">    testObj.SetNumber(<span class="number">200</span>);</span><br><span class="line">    testObj.GetNumber();</span><br><span class="line">    CVirtual *ptestObj = &amp;testObj;</span><br><span class="line">    <span class="keyword">int</span> nSizeOfCVirtual = <span class="keyword">sizeof</span>(CVirtual);</span><br><span class="line">    <span class="keyword">int</span> nSizeOfPointer = <span class="keyword">sizeof</span>(<span class="keyword">int</span> *);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>貌似lldb没找到gdb info vtbl类似的命令,所以在这里用gdb查看一下vtbl(要等CVirtual的构造函数执行完,否则vtbl里面的地址不对,相当于还没初始化好.).</p>
<p>然后反汇编main函数,顺便用info vtbl testObj查看一下虚函数表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disassemble main</span><br><span class="line">Dump of assembler code for function main():</span><br><span class="line">   0x000055555555475a &lt;+0&gt;:	push   %rbp</span><br><span class="line">   0x000055555555475b &lt;+1&gt;:	mov    %rsp,%rbp</span><br><span class="line">   0x000055555555475e &lt;+4&gt;:	sub    $0x30,%rsp</span><br><span class="line">   0x0000555555554762 &lt;+8&gt;:	mov    %fs:0x28,%rax</span><br><span class="line">   0x000055555555476b &lt;+17&gt;:	mov    %rax,-0x8(%rbp)</span><br><span class="line">   0x000055555555476f &lt;+21&gt;:	xor    %eax,%eax</span><br><span class="line">   0x0000555555554771 &lt;+23&gt;:	lea    -0x20(%rbp),%rax</span><br><span class="line">   0x0000555555554775 &lt;+27&gt;:	mov    $0x2854,%esi</span><br><span class="line">   0x000055555555477a &lt;+32&gt;:	mov    %rax,%rdi</span><br><span class="line">   0x000055555555477d &lt;+35&gt;:	callq  0x5555555547d0 &lt;CVirtual::CVirtual(int)&gt;</span><br><span class="line">   0x0000555555554782 &lt;+40&gt;:	lea    -0x20(%rbp),%rax</span><br><span class="line">   0x0000555555554786 &lt;+44&gt;:	mov    $0xc8,%esi</span><br><span class="line">   0x000055555555478b &lt;+49&gt;:	mov    %rax,%rdi</span><br><span class="line">   0x000055555555478e &lt;+52&gt;:	callq  0x555555554808 &lt;CVirtual::SetNumber(int)&gt;</span><br><span class="line">   0x0000555555554793 &lt;+57&gt;:	lea    -0x20(%rbp),%rax</span><br><span class="line">   0x0000555555554797 &lt;+61&gt;:	mov    %rax,%rdi</span><br><span class="line">   0x000055555555479a &lt;+64&gt;:	callq  0x5555555547f6 &lt;CVirtual::GetNumber()&gt;</span><br><span class="line">   0x000055555555479f &lt;+69&gt;:	lea    -0x20(%rbp),%rax</span><br><span class="line">   0x00005555555547a3 &lt;+73&gt;:	mov    %rax,-0x28(%rbp)</span><br><span class="line">   0x00005555555547a7 &lt;+77&gt;:	movl   $0x10,-0x30(%rbp)</span><br><span class="line">   0x00005555555547ae &lt;+84&gt;:	movl   $0x8,-0x2c(%rbp)</span><br><span class="line">=&gt; 0x00005555555547b5 &lt;+91&gt;:	mov    $0x0,%eax</span><br><span class="line">   0x00005555555547ba &lt;+96&gt;:	mov    -0x8(%rbp),%rdx</span><br><span class="line">   0x00005555555547be &lt;+100&gt;:	xor    %fs:0x28,%rdx</span><br><span class="line">   0x00005555555547c7 &lt;+109&gt;:	je     0x5555555547ce &lt;main()+116&gt;</span><br><span class="line">   0x00005555555547c9 &lt;+111&gt;:	callq  0x555555554630 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">   0x00005555555547ce &lt;+116&gt;:	leaveq</span><br><span class="line">   0x00005555555547cf &lt;+117&gt;:	retq</span><br><span class="line">End of assembler dump.</span><br><span class="line"></span><br><span class="line">(gdb) info vtbl testObj</span><br><span class="line">vtable for &apos;CVirtual&apos; @ 0x555555754d98 (subobject @ 0x7fffffffe470):</span><br><span class="line">[0]: 0x5555555547f6 &lt;CVirtual::GetNumber()&gt;</span><br><span class="line">[1]: 0x555555554808 &lt;CVirtual::SetNumber(int)&gt;</span><br><span class="line">刚好就是main里面callq的函数地址.// subobject @ 0x7fffffffe470 gdb打印的testObj对象的地址</span><br></pre></td></tr></table></figure>
<hr>
<p>然后看一下这个testObj占多大?对象的地址在哪?</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x ptestObj</span><br><span class="line"> :	0x55754d98</span><br><span class="line">//ptestObj指针在main帧里面,栈上面的变量.这个指针的值是0x7fffffffe470,也就是testObj的地址.注意后面的0x55754d98是0x7fffffffe470指向的位置的内容(也就是vtbl的值)</span><br></pre></td></tr></table></figure>
<p>又因为testObj在栈上占16字节<br>然后读一下这块内存的内容,注意输出是小端.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/16xb 0x7fffffffe470</span><br><span class="line">0x7fffffffe470:	0x98	0x4d	0x75	0x55	0x55	0x55	0x00	0x00</span><br><span class="line">0x7fffffffe478:	0xc8	0x00	0x00	0x00	0x55	0x55	0x00	0x00</span><br></pre></td></tr></table></figure>
<p>因为sizeof(int) == 4字节.在目前的机器的实现上前8个字节存的是指向vtbl的vptr.<br>vptr存的地址是0x00005555 55754d98.<br>0xc8 0x00 0x00 0x00是后面调用testObj.SetNumber(200);存入的200,还有四个字节估计和对齐有关?</p>
<p>然后把虚函数表里面的内容读出来看看</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/32xb 0x0000555555754d98</span><br><span class="line">0x555555754d98 &lt;_ZTV8CVirtual+16&gt;:	0xf6	0x47	0x55	0x55	0x55	0x55	0x00	0x00</span><br><span class="line">0x555555754da0 &lt;_ZTV8CVirtual+24&gt;:	0x08	0x48	0x55	0x55	0x55	0x55	0x00	0x00</span><br><span class="line">0x555555754da8 &lt;_ZTI8CVirtual&gt;:	0xf8	0x67	0xdc	0xf7	0xff	0x7f	0x00	0x00</span><br><span class="line">0x555555754db0 &lt;_ZTI8CVirtual+8&gt;:	0xa8	0x48	0x55	0x55	0x55	0x55	0x00	0x00</span><br></pre></td></tr></table></figure>
<p>前两项输出和gdb info vtal结果一样.</p>
<p>最后看看</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[0]: 0x5555555547f6 &lt;CVirtual::GetNumber()&gt;</span><br><span class="line">[1]: 0x555555554808 &lt;CVirtual::SetNumber(int)&gt;</span><br><span class="line">这两个函数的内容存在哪了.</span><br></pre></td></tr></table></figure>
<p>disassemble 0x5555555547f6 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/64x 0x5555555547f6</span><br><span class="line">0x5555555547f6 &lt;CVirtual::GetNumber()&gt;:	0x55	0x48	0x89	0xe5	0x48	0x89	0x7d	0xf8</span><br><span class="line">0x5555555547fe &lt;CVirtual::GetNumber()+8&gt;:	0x48	0x8b	0x45	0xf8	0x8b	0x40	0x08	0x5d</span><br><span class="line">0x555555554806 &lt;CVirtual::GetNumber()+16&gt;:	0xc3	0x90	0x55	0x48	0x89	0xe5	0x48	0x89</span><br><span class="line">0x55555555480e &lt;CVirtual::SetNumber(int)+6&gt;:	0x7d	0xf8	0x89	0x75	0xf4	0x48	0x8b	0x45</span><br><span class="line">0x555555554816 &lt;CVirtual::SetNumber(int)+14&gt;:	0xf8	0x8b	0x55	0xf4	0x89	0x50	0x08	0x90</span><br><span class="line">0x55555555481e &lt;CVirtual::SetNumber(int)+22&gt;:	0x5d	0xc3	0x41	0x57	0x41	0x56	0x49	0x89</span><br><span class="line">0x555555554826 &lt;__libc_csu_init+6&gt;:	0xd7	0x41	0x55	0x41	0x54	0x4c	0x8d	0x25</span><br><span class="line">0x55555555482e &lt;__libc_csu_init+14&gt;:	0x46	0x05	0x20	0x00	0x55	0x48	0x8d	0x2d</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disassemble 0x5555555547f6</span><br><span class="line">Dump of assembler code for function CVirtual::GetNumber():</span><br><span class="line">   0x00005555555547f6 &lt;+0&gt;:		push   %rbp</span><br><span class="line">   0x00005555555547f7 &lt;+1&gt;:		mov    %rsp,%rbp</span><br><span class="line">   0x00005555555547fa &lt;+4&gt;:		mov    %rdi,-0x8(%rbp)</span><br><span class="line">   0x00005555555547fe &lt;+8&gt;:		mov    -0x8(%rbp),%rax</span><br><span class="line">   0x0000555555554802 &lt;+12&gt;:	mov    0x8(%rax),%eax</span><br><span class="line">   0x0000555555554805 &lt;+15&gt;:	pop    %rbp</span><br><span class="line">   0x0000555555554806 &lt;+16&gt;:	retq</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>
<p>同理[1]: 0x555555554808 <a href="CVirtual::SetNumber(int)" target="_blank" rel="noopener">CVirtual::SetNumber(int)</a>不在这里列举了.<br>最后的最后,看看在ELF文件里面这两函数在哪.readelf命令看,但是显示的加载地址都比较小.与调试器里面的不符.1.<a href="https://www.martinkysel.com/demystifying-virtual-tables-in-c-part-1-trivial-constructors/" target="_blank" rel="noopener">Demystifying Virtual Tables In C++</a>这个人分析却是一样的.老版本的不是这样的啊.什么情况…加载器都干了些什么…算了,先不分析这里了.后续再看了.</p>
<h3 id="空类"><a href="#空类" class="headerlink" title="空类"></a>空类</h3><p>参考<a href="http://www.stroustrup.com/bs_faq2.html#sizeof-empty" target="_blank" rel="noopener">Bjarne Stroustrup-Why is the size of an empty class not zero?</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Empty</span> &#123;</span> &#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Empty a, b;</span><br><span class="line">	Empty *pa = &amp;a;</span><br><span class="line">	Empty *pb = &amp;b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    f();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(lldb) frame variable</span><br><span class="line">(Empty) a = &#123;&#125;</span><br><span class="line">(Empty) b = &#123;&#125;</span><br><span class="line">(Empty *) pa = 0x00007fffffffe4a6</span><br><span class="line">(Empty *) pb = 0x00007fffffffe4a7</span><br><span class="line">(lldb) expression &amp;a</span><br><span class="line">(Empty *) <span class="variable">$0</span> = 0x00007fffffffe4a6</span><br><span class="line">(lldb) expression &amp;b</span><br><span class="line">(Empty *) <span class="variable">$1</span> = 0x00007fffffffe4a7</span><br><span class="line">(lldb) memory <span class="built_in">read</span> --size 1 --format x --count 1 0x00007fffffffe4a6</span><br><span class="line">0x7fffffffe4a6: 0x00</span><br><span class="line">(lldb) memory <span class="built_in">read</span> --size 1 --format x --count 1 0x00007fffffffe4a7</span><br><span class="line">0x7fffffffe4a7: 0x00</span><br></pre></td></tr></table></figure>
<p>在我的这台机器上空类的对象占一个字节.字节内容查看是0x00.<br>很奇怪的一点是,没有Empty <em>pa = &a;Empty </em>pb = &b;这两行的话用调试器看expression &amp;a和expression &amp;b是一样的?</p>
<p>1.如果是吧地址取出来Empty <em>pa = &a;Empty </em>pb = &b;像这样,不管调试器还是直接打印出来,pa和pb都会是不同的地址.<br>2.如果按Bjarne Stroustrup给的例子,进行if测试,也是不会相同的.</p>
<hr>
<p>但是如果是empty base class,那么会有一个编译器的优化,叫做empty base class optimization</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Empty</span> &#123;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X</span> :</span> Empty &#123;</span><br><span class="line">        <span class="keyword">int</span> a;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(X* p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">void</span>* p1 = p;</span><br><span class="line">        <span class="keyword">void</span>* p2 = &amp;p-&gt;a;</span><br><span class="line">        <span class="keyword">if</span> (p1 == p2) <span class="built_in">cout</span> &lt;&lt; <span class="string">"nice: good optimizer\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    X testObj;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"sizeof X %d\n"</span>, <span class="keyword">sizeof</span>(X));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"sizeof testObj %d\n"</span>, <span class="keyword">sizeof</span>(testObj));</span><br><span class="line">    f(&amp;testObj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出:</p>
<p>sizeof X 4<br>sizeof testObj 4<br>nice: good optimizer</p>
<hr>
<p>参考:</p>
<p>1.<a href="https://www.martinkysel.com/demystifying-virtual-tables-in-c-part-1-trivial-constructors/" target="_blank" rel="noopener">Demystifying Virtual Tables In C++</a></p>
<p>2.<a href="http://www.stroustrup.com/bs_faq2.html#sizeof-empty" target="_blank" rel="noopener">Bjarne Stroustrup-Why is the size of an empty class not zero?</a></p>
<p>3.反汇编与逆向分析技术揭秘</p>
<p>4.深入探索C++对象模型</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://mojiajun.github.io/post/a24c8ee4.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mojiajun">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mojiajun">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/post/a24c8ee4.html" itemprop="url">C++-虚函数机制-02</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-07-22T00:00:00+08:00">
                2019-07-22
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>反汇编与逆向分析技术揭秘第十一章虚函数<br>阅读及用x86-64-g++平台分析</p>
<p>这篇主要是构造函数和析构函数和vtbl,vptr的联系.(就是把反汇编与逆向分析技术揭秘第十一章虚函数11.1节用x86-64 linux ATT汇编格式过了一遍…)</p>
<p>这篇还没涉及继承…</p>
<p>[TOC]</p>
<h3 id="构造函数和vptr"><a href="#构造函数和vptr" class="headerlink" title="构造函数和vptr"></a>构造函数和vptr</h3><hr>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CVirtual</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">GetNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> _nNumber;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SetNumber</span><span class="params">(<span class="keyword">int</span> nNumber)</span> </span>&#123;</span><br><span class="line">      _nNumber = nNumber;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> _nNumber;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CVirtual testObj;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disassemble main</span><br><span class="line">Dump of assembler code for function main():</span><br><span class="line">   0x000055555555475a &lt;+0&gt;:	push   %rbp</span><br><span class="line">   0x000055555555475b &lt;+1&gt;:	mov    %rsp,%rbp</span><br><span class="line">   0x000055555555475e &lt;+4&gt;:	sub    $0x20,%rsp</span><br><span class="line">   0x0000555555554762 &lt;+8&gt;:	mov    %fs:0x28,%rax</span><br><span class="line">   0x000055555555476b &lt;+17&gt;:	mov    %rax,-0x8(%rbp)</span><br><span class="line">   0x000055555555476f &lt;+21&gt;:	xor    %eax,%eax</span><br><span class="line">   0x0000555555554771 &lt;+23&gt;:	lea    -0x20(%rbp),%rax</span><br><span class="line">=&gt; 0x0000555555554775 &lt;+27&gt;:	mov    %rax,%rdi</span><br><span class="line">   0x0000555555554778 &lt;+30&gt;:	callq  0x5555555547c2 &lt;CVirtual::CVirtual()&gt;</span><br><span class="line">   0x000055555555477d &lt;+35&gt;:	mov    $0x0,%eax</span><br><span class="line">   0x0000555555554782 &lt;+40&gt;:	mov    -0x8(%rbp),%rdx</span><br><span class="line">   0x0000555555554786 &lt;+44&gt;:	xor    %fs:0x28,%rdx</span><br><span class="line">   0x000055555555478f &lt;+53&gt;:	je     0x555555554796 &lt;main()+60&gt;</span><br><span class="line">   0x0000555555554791 &lt;+55&gt;:	callq  0x555555554630 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">   0x0000555555554796 &lt;+60&gt;:	leaveq</span><br><span class="line">   0x0000555555554797 &lt;+61&gt;:	retq</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x $rax  # testObj对象地址</span><br><span class="line">0x7fffffffe470:	0xe0</span><br><span class="line">(gdb) info vtbl testObj</span><br><span class="line">vtable for &apos;CVirtual&apos; @ 0x5555555547e0 (subobject @ 0x7fffffffe470):</span><br><span class="line">[0]: 0x41d7894956415741</span><br><span class="line">[1]: 0x586258d4c544155</span><br><span class="line"># @ 0x5555555547e0是不能用的.因为还没有执行完callq  0x5555555547c2 &lt;CVirtual::CVirtual()&gt;,</span><br><span class="line"># 只有当执行完&lt;CVirtual::CVirtual()&gt;,才算是完整的构造好了对象.否则,别用gdb info vtbl.</span><br><span class="line"># 构造完成之后调用info vtbl testObj的结果,发现@ 0x555555754d98才是vptr正确的值!!!</span><br><span class="line">(gdb) info vtbl testObj</span><br><span class="line">vtable for &apos;CVirtual&apos; @ 0x555555754d98 (subobject @ 0x7fffffffe470):</span><br><span class="line">[0]: 0x555555554798 &lt;CVirtual::GetNumber()&gt;</span><br><span class="line">[1]: 0x5555555547aa &lt;CVirtual::SetNumber(int)&gt;</span><br></pre></td></tr></table></figure>
<p>在callq  0x5555555547c2 <a href="CVirtual::CVirtual()" target="_blank" rel="noopener">CVirtual::CVirtual()</a>之前,需要把testObj的地址(处于对象已经有内存了,但是vptr还没初始化的状态,即[半完成品]对象)放入%rdi.这个地方调用的合成的默认构造函数.也就是在callq CVirtual::CVirtual(),需要先拿到this指针送到%rdi寄存器.</p>
<p>然后是合成的默认构造函数内容:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disassemble 0x5555555547c2</span><br><span class="line">Dump of assembler code for function CVirtual::CVirtual():</span><br><span class="line">   0x00005555555547c2 &lt;+0&gt;:	push   %rbp</span><br><span class="line">   0x00005555555547c3 &lt;+1&gt;:	mov    %rsp,%rbp</span><br><span class="line">   0x00005555555547c6 &lt;+4&gt;:	mov    %rdi,-0x8(%rbp)  #把%rdi里面的this指针存到-0x8(%rbp)</span><br><span class="line">   0x00005555555547ca &lt;+8&gt;:	lea    0x2005c7(%rip),%rdx        # 0x555555754d98 &lt;_ZTV8CVirtual+16&gt;          # 把0x555555754d98这个虚函数表的地址送到%rdx</span><br><span class="line">   0x00005555555547d1 &lt;+15&gt;:	mov    -0x8(%rbp),%rax</span><br><span class="line">   0x00005555555547d5 &lt;+19&gt;:	mov    %rdx,(%rax)  # 把虚函数表地址0x555555754d98填入this指针的对象的前8个字节(也即存入虚表指针里).</span><br><span class="line">   0x00005555555547d8 &lt;+22&gt;:	nop</span><br><span class="line">   0x00005555555547d9 &lt;+23&gt;:	pop    %rbp</span><br><span class="line">   0x00005555555547da &lt;+24&gt;:	retq</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>
<p>这个合成的默认构造函数只干了一件事,那就是把class CVirtual的虚表地址填入对象的vptr指针.</p>
<p>不管testObj对象创建不创建.class CVirtual的虚表在程序加载好了之后就在内存里了.<br>通过x/16xb 0x555555754d98(虚表地址)就能查看虚表的内容.一个类的多个不同对象是共享同一张虚表的.只需要在调用构造函数的时候把虚表地址填入对象的vptr即可.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/16xb 0x555555754d98</span><br><span class="line">0x555555754d98 &lt;_ZTV8CVirtual+16&gt;:	0x98	0x47	0x55	0x55	0x55	0x55	0x00	0x00</span><br><span class="line">0x555555754da0 &lt;_ZTV8CVirtual+24&gt;:	0xaa	0x47	0x55	0x55	0x55	0x55	0x00	0x00</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="object直接调用-用’-’"><a href="#object直接调用-用’-’" class="headerlink" title="object直接调用(用’.’)"></a>object直接调用(用’.’)</h3><p>如果是testObj.SetNumber(200)和testObj.GetNumber()</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CVirtual testObj;</span><br><span class="line">    testObj.SetNumber(<span class="number">200</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\r\n"</span>, testObj.GetNumber());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disassemble main</span><br><span class="line">Dump of assembler code for function main():</span><br><span class="line">   0x00005555555547aa &lt;+0&gt;:	push   %rbp</span><br><span class="line">   0x00005555555547ab &lt;+1&gt;:	mov    %rsp,%rbp</span><br><span class="line">   0x00005555555547ae &lt;+4&gt;:	sub    $0x20,%rsp</span><br><span class="line">=&gt; 0x00005555555547b2 &lt;+8&gt;:	mov    %fs:0x28,%rax</span><br><span class="line">   0x00005555555547bb &lt;+17&gt;:	mov    %rax,-0x8(%rbp)</span><br><span class="line">   0x00005555555547bf &lt;+21&gt;:	xor    %eax,%eax</span><br><span class="line">   0x00005555555547c1 &lt;+23&gt;:	lea    -0x20(%rbp),%rax</span><br><span class="line">   0x00005555555547c5 &lt;+27&gt;:	mov    %rax,%rdi</span><br><span class="line">   0x00005555555547c8 &lt;+30&gt;:	callq  0x555555554842 &lt;CVirtual::CVirtual()&gt;</span><br><span class="line">   0x00005555555547cd &lt;+35&gt;:	lea    -0x20(%rbp),%rax  # this指针放入%rax</span><br><span class="line">   0x00005555555547d1 &lt;+39&gt;:	mov    $0xc8,%esi  # 200放入%esi</span><br><span class="line">   0x00005555555547d6 &lt;+44&gt;:	mov    %rax,%rdi  # %rax中的this指针转移到%rdi </span><br><span class="line">   0x00005555555547d9 &lt;+47&gt;:	callq  0x55555555482a &lt;CVirtual::SetNumber(int)&gt;</span><br><span class="line">   0x00005555555547de &lt;+52&gt;:	lea    -0x20(%rbp),%rax</span><br><span class="line">   0x00005555555547e2 &lt;+56&gt;:	mov    %rax,%rdi</span><br><span class="line">   0x00005555555547e5 &lt;+59&gt;:	callq  0x555555554818 &lt;CVirtual::GetNumber()&gt;</span><br><span class="line">   0x00005555555547ea &lt;+64&gt;:	mov    %eax,%esi</span><br><span class="line">   0x00005555555547ec &lt;+66&gt;:	lea    0xf1(%rip),%rdi        # 0x5555555548e4</span><br><span class="line">   0x00005555555547f3 &lt;+73&gt;:	mov    $0x0,%eax</span><br><span class="line">   0x00005555555547f8 &lt;+78&gt;:	callq  0x555555554670 &lt;printf@plt&gt;</span><br><span class="line">   0x00005555555547fd &lt;+83&gt;:	mov    $0x0,%eax</span><br><span class="line">   0x0000555555554802 &lt;+88&gt;:	mov    -0x8(%rbp),%rdx</span><br><span class="line">   0x0000555555554806 &lt;+92&gt;:	xor    %fs:0x28,%rdx</span><br><span class="line">   0x000055555555480f &lt;+101&gt;:	je     0x555555554816 &lt;main()+108&gt;</span><br><span class="line">   0x0000555555554811 &lt;+103&gt;:	callq  0x555555554680 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">   0x0000555555554816 &lt;+108&gt;:	leaveq</span><br><span class="line">   0x0000555555554817 &lt;+109&gt;:	retq</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>
<p>注意testObj.SetNumber(200)和testObj.GetNumber()的调用都是直接调用,用的<br>callq  0x55555555482a和callq  0x555555554818.</p>
<blockquote>
<p>  直接调用这样不能多态,举一个有继承的例子,override虚函数的例子?</p>
</blockquote>
<p>CVirtual::SetNumber(int)的汇编分析,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disassemble 0x55555555482a</span><br><span class="line">Dump of assembler code for function CVirtual::SetNumber(int):</span><br><span class="line">   0x000055555555482a &lt;+0&gt;:	push   %rbp</span><br><span class="line">   0x000055555555482b &lt;+1&gt;:	mov    %rsp,%rbp</span><br><span class="line">   0x000055555555482e &lt;+4&gt;:	mov    %rdi,-0x8(%rbp)  # 第一个参数this指针放入-0x8(%rbp)</span><br><span class="line">   0x0000555555554832 &lt;+8&gt;:	mov    %esi,-0xc(%rbp)  # %esi是第二个参数,如果是</span><br><span class="line">   													  	# SetNumerber(200),%esi里面就是200</span><br><span class="line">   0x0000555555554835 &lt;+11&gt;:	mov    -0x8(%rbp),%rax  </span><br><span class="line">   0x0000555555554839 &lt;+15&gt;:	mov    -0xc(%rbp),%edx</span><br><span class="line">   0x000055555555483c &lt;+18&gt;:	mov    %edx,0x8(%rax)  # 把第二个参数里面要设置的值放入</span><br><span class="line">   												# 0x8(%rax), 即对象的首地址偏移8个字节的位置.</span><br><span class="line">   												# 即private变量_nNumber的位置.</span><br><span class="line">   0x000055555555483f &lt;+21&gt;:	nop</span><br><span class="line">   0x0000555555554840 &lt;+22&gt;:	pop    %rbp</span><br><span class="line">   0x0000555555554841 &lt;+23&gt;:	retq</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>
<h3 id="object指针-用’-gt-’-和引用-‘ref-’-调用"><a href="#object指针-用’-gt-’-和引用-‘ref-’-调用" class="headerlink" title="object指针(用’-&gt;’)和引用(‘ref.’)调用"></a>object指针(用’-&gt;’)和引用(‘ref.’)调用</h3><p>下面比较下直接对象调用(用’.’)和指针调用和引用调用的区别?</p>
<h4 id="指针调用"><a href="#指针调用" class="headerlink" title="指针调用"></a>指针调用</h4><p>先指针调用分析</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CVirtual</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">GetNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> _nNumber;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SetNumber</span><span class="params">(<span class="keyword">int</span> nNumber)</span> </span>&#123;</span><br><span class="line">      _nNumber = nNumber;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> _nNumber;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CVirtual *ptestObj = <span class="keyword">new</span> CVirtual();</span><br><span class="line">    ptestObj-&gt;SetNumber(<span class="number">200</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\r\n"</span>, ptestObj-&gt;GetNumber());</span><br><span class="line">    <span class="keyword">delete</span> ptestObj;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disassemble main</span><br><span class="line">Dump of assembler code for function main():</span><br><span class="line">   0x00005555555547fa &lt;+0&gt;:	push   %rbp</span><br><span class="line">   0x00005555555547fb &lt;+1&gt;:	mov    %rsp,%rbp</span><br><span class="line">   0x00005555555547fe &lt;+4&gt;:	push   %rbx</span><br><span class="line">   0x00005555555547ff &lt;+5&gt;:	sub    $0x18,%rsp</span><br><span class="line">=&gt; 0x0000555555554803 &lt;+9&gt;:	mov    $0x10,%edi</span><br><span class="line">   0x0000555555554808 &lt;+14&gt;:	callq  0x5555555546c0 &lt;_Znwm@plt&gt;</span><br><span class="line">   0x000055555555480d &lt;+19&gt;:	mov    %rax,%rbx</span><br><span class="line">   0x0000555555554810 &lt;+22&gt;:	movq   $0x0,(%rbx)</span><br><span class="line">   0x0000555555554817 &lt;+29&gt;:	movl   $0x0,0x8(%rbx)</span><br><span class="line">   0x000055555555481e &lt;+36&gt;:	mov    %rbx,%rdi</span><br><span class="line">   0x0000555555554821 &lt;+39&gt;:	callq  0x5555555548b4 &lt;CVirtual::CVirtual()&gt;</span><br><span class="line">   0x0000555555554826 &lt;+44&gt;:	mov    %rbx,-0x18(%rbp)   # this指针</span><br><span class="line">   0x000055555555482a &lt;+48&gt;:	mov    -0x18(%rbp),%rax	  # %rax现在存的是对象的首地址</span><br><span class="line">   0x000055555555482e &lt;+52&gt;:	mov    (%rax),%rax		  # 把对象首地址指向的东西(即vptr)放入rax</span><br><span class="line">   0x0000555555554831 &lt;+55&gt;:	add    $0x8,%rax		  # vptr + 8, </span><br><span class="line">   # 原因在于SetNumber(int)类中声明顺序在GetNumber()后面,所以在vtbl里在GetNumber()后面,</span><br><span class="line">   # 而vtbl是一个个函数指针组成的列表.x86-64一个指针占8字节,所以vptr + 8</span><br><span class="line">   0x0000555555554835 &lt;+59&gt;:	mov    (%rax),%rax		  # 找到位置了,然后把vptr + 8这个位置的对应的函数指针取出来放入rax</span><br><span class="line">   0x0000555555554838 &lt;+62&gt;:	mov    -0x18(%rbp),%rdx</span><br><span class="line">   0x000055555555483c &lt;+66&gt;:	mov    $0xc8,%esi		  # 第二个参数200即0xc8</span><br><span class="line">   0x0000555555554841 &lt;+71&gt;:	mov    %rdx,%rdi		  # this指针送入%rdi</span><br><span class="line">   0x0000555555554844 &lt;+74&gt;:	callq  *%rax # 调用SetNumber(int)</span><br><span class="line">   0x0000555555554846 &lt;+76&gt;:	mov    -0x18(%rbp),%rax</span><br><span class="line">   0x000055555555484a &lt;+80&gt;:	mov    (%rax),%rax   # 把对象首地址指向的东西(即vptr)放入rax</span><br><span class="line">   0x000055555555484d &lt;+83&gt;:	mov    (%rax),%rax   # 把vptr + 0这个位置的对应的函数指针取出来放入rax, 即GetNumber()</span><br><span class="line">   0x0000555555554850 &lt;+86&gt;:	mov    -0x18(%rbp),%rdx</span><br><span class="line">   0x0000555555554854 &lt;+90&gt;:	mov    %rdx,%rdi</span><br><span class="line">   0x0000555555554857 &lt;+93&gt;:	callq  *%rax</span><br><span class="line">   0x0000555555554859 &lt;+95&gt;:	mov    %eax,%esi</span><br><span class="line">   0x000055555555485b &lt;+97&gt;:	lea    0xf2(%rip),%rdi        # 0x555555554954</span><br><span class="line">   0x0000555555554862 &lt;+104&gt;:	mov    $0x0,%eax</span><br><span class="line">   0x0000555555554867 &lt;+109&gt;:	callq  0x5555555546b0 &lt;printf@plt&gt;</span><br><span class="line">   0x000055555555486c &lt;+114&gt;:	mov    -0x18(%rbp),%rax</span><br><span class="line">   0x0000555555554870 &lt;+118&gt;:	mov    $0x10,%esi</span><br><span class="line">   0x0000555555554875 &lt;+123&gt;:	mov    %rax,%rdi</span><br><span class="line">   0x0000555555554878 &lt;+126&gt;:	callq  0x5555555546d0 &lt;_ZdlPvm@plt&gt;</span><br><span class="line">   0x000055555555487d &lt;+131&gt;:	mov    $0x0,%eax</span><br><span class="line">   0x0000555555554882 &lt;+136&gt;:	add    $0x18,%rsp</span><br><span class="line">   0x0000555555554886 &lt;+140&gt;:	pop    %rbx</span><br><span class="line">   0x0000555555554887 &lt;+141&gt;:	pop    %rbp</span><br><span class="line">   0x0000555555554888 &lt;+142&gt;:	retq</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>
<h4 id="引用调用"><a href="#引用调用" class="headerlink" title="引用调用"></a>引用调用</h4><p>引用调用分析,</p>
<p>本来以为这样就会像指针那样间接调用了.没想到不是…C++代码如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CVirtual</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">GetNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> _nNumber;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SetNumber</span><span class="params">(<span class="keyword">int</span> nNumber)</span> </span>&#123;</span><br><span class="line">      _nNumber = nNumber;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> _nNumber;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CVirtual testObj;</span><br><span class="line">    CVirtual &amp;rtestObj = testObj;</span><br><span class="line">    rtestObj.SetNumber(<span class="number">200</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\r\n"</span>, rtestObj.GetNumber());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>反汇编之后,发现这不和object直接调用(用’.’)几乎一样吗…<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disassemble main</span><br><span class="line">Dump of assembler code for function main():</span><br><span class="line">   0x00005555555547aa &lt;+0&gt;:	push   %rbp</span><br><span class="line">   0x00005555555547ab &lt;+1&gt;:	mov    %rsp,%rbp</span><br><span class="line">   0x00005555555547ae &lt;+4&gt;:	sub    $0x30,%rsp</span><br><span class="line">=&gt; 0x00005555555547b2 &lt;+8&gt;:	mov    %fs:0x28,%rax  # ?</span><br><span class="line">   0x00005555555547bb &lt;+17&gt;:	mov    %rax,-0x8(%rbp)</span><br><span class="line">   0x00005555555547bf &lt;+21&gt;:	xor    %eax,%eax</span><br><span class="line">   0x00005555555547c1 &lt;+23&gt;:	lea    -0x20(%rbp),%rax</span><br><span class="line">   0x00005555555547c5 &lt;+27&gt;:	mov    %rax,%rdi</span><br><span class="line">   0x00005555555547c8 &lt;+30&gt;:	callq  0x55555555484a &lt;CVirtual::CVirtual()&gt;</span><br><span class="line">   0x00005555555547cd &lt;+35&gt;:	lea    -0x20(%rbp),%rax  # object地址送入rax</span><br><span class="line">   0x00005555555547d1 &lt;+39&gt;:	mov    %rax,-0x28(%rbp)  # 建立引用rtestObj,即-0x28(%rbp)</span><br><span class="line">   0x00005555555547d5 &lt;+43&gt;:	mov    -0x28(%rbp),%rax  # 下面的代码等同于直接对象调用(用&apos;.&apos;的那种)</span><br><span class="line">   0x00005555555547d9 &lt;+47&gt;:	mov    $0xc8,%esi</span><br><span class="line">   0x00005555555547de &lt;+52&gt;:	mov    %rax,%rdi</span><br><span class="line">   0x00005555555547e1 &lt;+55&gt;:	callq  0x555555554832 &lt;CVirtual::SetNumber(int)&gt;</span><br><span class="line">   0x00005555555547e6 &lt;+60&gt;:	mov    -0x28(%rbp),%rax</span><br><span class="line">   0x00005555555547ea &lt;+64&gt;:	mov    %rax,%rdi</span><br><span class="line">   0x00005555555547ed &lt;+67&gt;:	callq  0x555555554820 &lt;CVirtual::GetNumber()&gt;</span><br><span class="line">   0x00005555555547f2 &lt;+72&gt;:	mov    %eax,%esi</span><br><span class="line">   0x00005555555547f4 &lt;+74&gt;:	lea    0xf9(%rip),%rdi        # 0x5555555548f4</span><br><span class="line">   0x00005555555547fb &lt;+81&gt;:	mov    $0x0,%eax</span><br><span class="line">   0x0000555555554800 &lt;+86&gt;:	callq  0x555555554670 &lt;printf@plt&gt;</span><br><span class="line">   0x0000555555554805 &lt;+91&gt;:	mov    $0x0,%eax</span><br><span class="line">   0x000055555555480a &lt;+96&gt;:	mov    -0x8(%rbp),%rdx</span><br><span class="line">   0x000055555555480e &lt;+100&gt;:	xor    %fs:0x28,%rdx</span><br><span class="line">   0x0000555555554817 &lt;+109&gt;:	je     0x55555555481e &lt;main()+116&gt;</span><br><span class="line">   0x0000555555554819 &lt;+111&gt;:	callq  0x555555554680 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">   0x000055555555481e &lt;+116&gt;:	leaveq</span><br><span class="line">   0x000055555555481f &lt;+117&gt;:	retq</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure></p>
<p>但是改成堆对象后</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CVirtual</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">GetNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> _nNumber;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SetNumber</span><span class="params">(<span class="keyword">int</span> nNumber)</span> </span>&#123;</span><br><span class="line">      _nNumber = nNumber;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> _nNumber;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CVirtual *ptestObj = <span class="keyword">new</span> CVirtual();</span><br><span class="line">    CVirtual &amp;rtestObj = *ptestObj;</span><br><span class="line">    rtestObj.SetNumber(<span class="number">200</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\r\n"</span>, rtestObj.GetNumber());</span><br><span class="line">    <span class="keyword">delete</span> ptestObj;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>反汇编之后,这种和指针调用虚函数的方法一样,都是间接调用,拿到对象的vptr指向的函数指针表里面的某一项.然后调用它.(callq  *%rax)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disassemble main</span><br><span class="line">Dump of assembler code for function main():</span><br><span class="line">   0x00005555555547fa &lt;+0&gt;:	push   %rbp</span><br><span class="line">   0x00005555555547fb &lt;+1&gt;:	mov    %rsp,%rbp</span><br><span class="line">   0x00005555555547fe &lt;+4&gt;:	push   %rbx</span><br><span class="line">   0x00005555555547ff &lt;+5&gt;:	sub    $0x18,%rsp</span><br><span class="line">=&gt; 0x0000555555554803 &lt;+9&gt;:	mov    $0x10,%edi</span><br><span class="line">   0x0000555555554808 &lt;+14&gt;:	callq  0x5555555546c0 &lt;_Znwm@plt&gt; # 这里应该是分配堆内存的那个函数</span><br><span class="line">   0x000055555555480d &lt;+19&gt;:	mov    %rax,%rbx  # 返回的指针存在了%rax,然后送入%rbx</span><br><span class="line">   0x0000555555554810 &lt;+22&gt;:	movq   $0x0,(%rbx)</span><br><span class="line">   0x0000555555554817 &lt;+29&gt;:	movl   $0x0,0x8(%rbx)</span><br><span class="line">   0x000055555555481e &lt;+36&gt;:	mov    %rbx,%rdi</span><br><span class="line">   0x0000555555554821 &lt;+39&gt;:	callq  0x5555555548bc &lt;CVirtual::CVirtual()&gt; # 调用构造函数</span><br><span class="line">   0x0000555555554826 &lt;+44&gt;:	mov    %rbx,-0x20(%rbp)  # rbx存的即是ptestObj指针吧.</span><br><span class="line">   								# -0x20(%rbp)是rtestObj这个引用占的8字节的首地址?</span><br><span class="line">   0x000055555555482a &lt;+48&gt;:	mov    -0x20(%rbp),%rax</span><br><span class="line">   0x000055555555482e &lt;+52&gt;:	mov    %rax,-0x18(%rbp)  </span><br><span class="line">   								# 下面的逻辑和指针调用分析的一样了...本质是因为引用和指针在汇编这个层面看,引用由指针实现(感觉这句话不严谨?汇编层面的指针就是一个8字节的地址,关键看反汇编的代码吧.一下就明白了).</span><br><span class="line">   0x0000555555554832 &lt;+56&gt;:	mov    -0x18(%rbp),%rax</span><br><span class="line">   0x0000555555554836 &lt;+60&gt;:	mov    (%rax),%rax</span><br><span class="line">   0x0000555555554839 &lt;+63&gt;:	add    $0x8,%rax</span><br><span class="line">   0x000055555555483d &lt;+67&gt;:	mov    (%rax),%rax</span><br><span class="line">   0x0000555555554840 &lt;+70&gt;:	mov    -0x18(%rbp),%rdx</span><br><span class="line">   0x0000555555554844 &lt;+74&gt;:	mov    $0xc8,%esi</span><br><span class="line">   0x0000555555554849 &lt;+79&gt;:	mov    %rdx,%rdi</span><br><span class="line">   0x000055555555484c &lt;+82&gt;:	callq  *%rax</span><br><span class="line">   0x000055555555484e &lt;+84&gt;:	mov    -0x18(%rbp),%rax</span><br><span class="line">   0x0000555555554852 &lt;+88&gt;:	mov    (%rax),%rax</span><br><span class="line">   0x0000555555554855 &lt;+91&gt;:	mov    (%rax),%rax</span><br><span class="line">   0x0000555555554858 &lt;+94&gt;:	mov    -0x18(%rbp),%rdx</span><br><span class="line">   0x000055555555485c &lt;+98&gt;:	mov    %rdx,%rdi</span><br><span class="line">   0x000055555555485f &lt;+101&gt;:	callq  *%rax</span><br><span class="line">   0x0000555555554861 &lt;+103&gt;:	mov    %eax,%esi</span><br><span class="line">   0x0000555555554863 &lt;+105&gt;:	lea    0xfa(%rip),%rdi        # 0x555555554964</span><br><span class="line">   0x000055555555486a &lt;+112&gt;:	mov    $0x0,%eax</span><br><span class="line">   0x000055555555486f &lt;+117&gt;:	callq  0x5555555546b0 &lt;printf@plt&gt;</span><br><span class="line">   0x0000555555554874 &lt;+122&gt;:	mov    -0x20(%rbp),%rax</span><br><span class="line">   0x0000555555554878 &lt;+126&gt;:	mov    $0x10,%esi</span><br><span class="line">   0x000055555555487d &lt;+131&gt;:	mov    %rax,%rdi</span><br><span class="line">   0x0000555555554880 &lt;+134&gt;:	callq  0x5555555546d0 &lt;_ZdlPvm@plt&gt; # delete</span><br><span class="line">   0x0000555555554885 &lt;+139&gt;:	mov    $0x0,%eax</span><br><span class="line">   0x000055555555488a &lt;+144&gt;:	add    $0x18,%rsp</span><br><span class="line">   0x000055555555488e &lt;+148&gt;:	pop    %rbx</span><br><span class="line">   0x000055555555488f &lt;+149&gt;:	pop    %rbp</span><br><span class="line">   0x0000555555554890 &lt;+150&gt;:	retq</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>
<p>最终就两种调用方式.</p>
<p>callq  0x555555554832 和 callq  *%rax</p>
<p>分别是直接调用和间接调用,只有callq  *%rax这种间接方式是查vptr指向的虚函数表,然后找到函数指针后调用相应函数的,也就是虚函数实现C++多态的关键…(有个问题,这么做的话,性能上打折扣吗???)</p>
<hr>
<h3 id="析构函数与vptr"><a href="#析构函数与vptr" class="headerlink" title="析构函数与vptr"></a>析构函数与vptr</h3><blockquote>
<p>  反汇编与逆向分析技术揭秘11.1节P261最后几段话,没太明白,关键应该是要结合继承来分析…待看吧…</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CVirtual</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">GetNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> _nNumber;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SetNumber</span><span class="params">(<span class="keyword">int</span> nNumber)</span> </span>&#123;</span><br><span class="line">      _nNumber = nNumber;</span><br><span class="line">  &#125;</span><br><span class="line">  ~CVirtual() &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"~CVirtual()\n"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> _nNumber;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CVirtual testObj;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disassemble main</span><br><span class="line">Dump of assembler code for function main():</span><br><span class="line">   0x00005555555547ea &lt;+0&gt;:	push   %rbp</span><br><span class="line">   0x00005555555547eb &lt;+1&gt;:	mov    %rsp,%rbp</span><br><span class="line">   0x00005555555547ee &lt;+4&gt;:	push   %rbx</span><br><span class="line">   0x00005555555547ef &lt;+5&gt;:	sub    $0x28,%rsp</span><br><span class="line">=&gt; 0x00005555555547f3 &lt;+9&gt;:	mov    %fs:0x28,%rax</span><br><span class="line">   0x00005555555547fc &lt;+18&gt;:	mov    %rax,-0x18(%rbp)</span><br><span class="line">   0x0000555555554800 &lt;+22&gt;:	xor    %eax,%eax</span><br><span class="line">   0x0000555555554802 &lt;+24&gt;:	lea    -0x30(%rbp),%rax</span><br><span class="line">   0x0000555555554806 &lt;+28&gt;:	mov    %rax,%rdi</span><br><span class="line">   0x0000555555554809 &lt;+31&gt;:	callq  0x555555554890 &lt;CVirtual::CVirtual()&gt;</span><br><span class="line">   0x000055555555480e &lt;+36&gt;:	mov    $0x0,%ebx</span><br><span class="line">   0x0000555555554813 &lt;+41&gt;:	lea    -0x30(%rbp),%rax</span><br><span class="line">   0x0000555555554817 &lt;+45&gt;:	mov    %rax,%rdi  # this指针</span><br><span class="line">   0x000055555555481a &lt;+48&gt;:	callq  0x555555554866 &lt;CVirtual::~CVirtual()&gt;</span><br><span class="line">   0x000055555555481f &lt;+53&gt;:	mov    %ebx,%eax</span><br><span class="line">   0x0000555555554821 &lt;+55&gt;:	mov    -0x18(%rbp),%rdx  # 后面的这些什么作用?</span><br><span class="line">   0x0000555555554825 &lt;+59&gt;:	xor    %fs:0x28,%rdx</span><br><span class="line">   0x000055555555482e &lt;+68&gt;:	je     0x555555554835 &lt;main()+75&gt;</span><br><span class="line">   0x0000555555554830 &lt;+70&gt;:	callq  0x5555555546b0 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">   0x0000555555554835 &lt;+75&gt;:	add    $0x28,%rsp</span><br><span class="line">   0x0000555555554839 &lt;+79&gt;:	pop    %rbx</span><br><span class="line">   0x000055555555483a &lt;+80&gt;:	pop    %rbp</span><br><span class="line">   0x000055555555483b &lt;+81&gt;:	retq</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disassemble 0x555555554866  # callq  0x555555554866 &lt;CVirtual::~CVirtual()&gt;</span><br><span class="line">Dump of assembler code for function CVirtual::~CVirtual():</span><br><span class="line">   0x0000555555554866 &lt;+0&gt;:	push   %rbp</span><br><span class="line">   0x0000555555554867 &lt;+1&gt;:	mov    %rsp,%rbp</span><br><span class="line">   0x000055555555486a &lt;+4&gt;:	sub    $0x10,%rsp</span><br><span class="line">   0x000055555555486e &lt;+8&gt;:	mov    %rdi,-0x8(%rbp)  # this指针存入-0x8(%rbp)</span><br><span class="line">   0x0000555555554872 &lt;+12&gt;:	lea    0x200517(%rip),%rdx        # 0x555555754d90 &lt;_ZTV8CVirtual+16&gt;									   # 虚表地址放入%rdx</span><br><span class="line">   														# 0x555555754d90是虚表地址</span><br><span class="line">   0x0000555555554879 &lt;+19&gt;:	mov    -0x8(%rbp),%rax</span><br><span class="line">   0x000055555555487d &lt;+23&gt;:	mov    %rdx,(%rax)		# 虚表地址放入this指针指的那个对象的vptr?啥?那岂不是和构造函数干了一样的事情?</span><br><span class="line">   # 又是把虚表首地址赋值到对应对象的虚表指针中</span><br><span class="line">   0x0000555555554880 &lt;+26&gt;:	lea    0xad(%rip),%rdi        # 0x555555554934</span><br><span class="line">   0x0000555555554887 &lt;+33&gt;:	callq  0x5555555546c0 &lt;puts@plt&gt;</span><br><span class="line">   0x000055555555488c &lt;+38&gt;:	nop</span><br><span class="line">   0x000055555555488d &lt;+39&gt;:	leaveq</span><br><span class="line">   0x000055555555488e &lt;+40&gt;:	retq</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>
<p>这个析构的汇编分析尤其是写入虚表指针那里,不明白!!!这里的弄清楚的线索在反汇编与逆向分析技术揭秘11.1节最后几段话.关键应该是要结合继承来分析…</p>
<p>有合成的析构函数吧?有,见C++Primer13.1.3.之前见过,记不得了…<br>如果改成</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CVirtual</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">GetNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> _nNumber;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SetNumber</span><span class="params">(<span class="keyword">int</span> nNumber)</span> </span>&#123;</span><br><span class="line">      _nNumber = nNumber;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//~CVirtual() &#123;</span></span><br><span class="line">  <span class="comment">//    printf("~CVirtual()\n");</span></span><br><span class="line">  <span class="comment">//&#125;</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> _nNumber;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CVirtual testObj;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>回到不显式定义析构函数的时候.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disassemble main</span><br><span class="line">Dump of assembler code for function main():</span><br><span class="line">   0x000055555555475a &lt;+0&gt;:	push   %rbp</span><br><span class="line">   0x000055555555475b &lt;+1&gt;:	mov    %rsp,%rbp</span><br><span class="line">   0x000055555555475e &lt;+4&gt;:	sub    $0x20,%rsp</span><br><span class="line">=&gt; 0x0000555555554762 &lt;+8&gt;:	mov    %fs:0x28,%rax</span><br><span class="line">   0x000055555555476b &lt;+17&gt;:	mov    %rax,-0x8(%rbp)</span><br><span class="line">   0x000055555555476f &lt;+21&gt;:	xor    %eax,%eax</span><br><span class="line">   0x0000555555554771 &lt;+23&gt;:	lea    -0x20(%rbp),%rax</span><br><span class="line">   0x0000555555554775 &lt;+27&gt;:	mov    %rax,%rdi</span><br><span class="line">   0x0000555555554778 &lt;+30&gt;:	callq  0x5555555547c2 &lt;CVirtual::CVirtual()&gt;</span><br><span class="line">   0x000055555555477d &lt;+35&gt;:	mov    $0x0,%eax</span><br><span class="line">   0x0000555555554782 &lt;+40&gt;:	mov    -0x8(%rbp),%rdx</span><br><span class="line">   0x0000555555554786 &lt;+44&gt;:	xor    %fs:0x28,%rdx</span><br><span class="line">   0x000055555555478f &lt;+53&gt;:	je     0x555555554796 &lt;main()+60&gt;</span><br><span class="line">   0x0000555555554791 &lt;+55&gt;:	callq  0x555555554630 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">   0x0000555555554796 &lt;+60&gt;:	leaveq</span><br><span class="line">   0x0000555555554797 &lt;+61&gt;:	retq</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>
<p>在main里面没调用析构函数?被编译器优化了???关优化试试.<br>析构这里有没有类似构造的RVO的g++ -fno-elide-constructors这样的东西?强制不优化,执行析构函数.<br>这里结合Effective Modern C++的有一小节来看(讲编译器在背后帮你实现了哪些copy control函数那节,主要这里有C++11的,而Effective C++里面只没有移动版本copy control函数的分析).先放着吧…</p>
<p>参考:</p>
<p>1.反汇编与逆向分析技术揭秘</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://mojiajun.github.io/post/18ee0c7.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mojiajun">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mojiajun">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/post/18ee0c7.html" itemprop="url">mit6828-内联汇编-xv6-xchg-spinlock</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-07-10T00:00:00+08:00">
                2019-07-10
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OS/" itemprop="url" rel="index">
                    <span itemprop="name">OS</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OS/xv6/" itemprop="url" rel="index">
                    <span itemprop="name">xv6</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>[TOC]</p>
<h2 id="inline-assembly"><a href="#inline-assembly" class="headerlink" title="inline assembly"></a>inline assembly</h2><p>入门:<a href="https://blog.csdn.net/slvher/article/details/8864996" target="_blank" rel="noopener">【Linux学习笔记】Linux C中内联汇编的语法格式及使用方法（Inline Assembly in Linux C）</a>这个讲的比较好了.更全面的得查类似<a href="http://www.ibiblio.org/gferg/ldp/GCC-Inline-Assembly-HOWTO.html#ss5.1" target="_blank" rel="noopener">GCC-Inline-Assembly-HOWTO</a>这种</p>
<p>inline assembly感觉细节好多…下次看估计又忘了…</p>
<hr>
<p>用1对双引号将多行命令括起来 加”;”分号?<br>clobbered register修饰寄存器?修饰?<br><a href="https://en.wikipedia.org/wiki/Inline_assembler" target="_blank" rel="noopener">Inline assembler</a>里面有个用汇编求tan(x)的例子,待看,感觉挺有趣.</p>
<hr>
<p>当我们不想通过寄存器中转，而是直接操作内存时，可以用”m”来约束。例如：<br>asm volatile ( “lock; decl %0” : “=m” (counter) : “m” (counter));<br>该指令实现原子减一操作，输入、输出操作数均直接来自内存（<strong>也正因如此，才能保证操作的原子性</strong>）。 </p>
<blockquote>
<p>  也正因如此，才能保证操作的原子性,更底层细节?这是是保证原子性的关键吗?结合后面的xv6的xchg函数实现.<br>  3个东西.1是lock前缀,2是+代表read-modify-write,3是”m”直接操作内存</p>
</blockquote>
<p>“=的意思” output operand应该有个”=”,1.说明这个是输出操作数,2.write-only</p>
<ul>
<li>“r” is a constraint on the operands. We’ll see constraints in detail later. For the time being, “r” says to GCC to use any register for storing the operands. output operand constraint should have a constraint modifier “=”. And this modifier says that it is the output operand and is write-only.</li>
</ul>
<p>“cc”的意思</p>
<p>If our instruction can alter the condition code register, we have to add “cc” to the list of clobbered registers.s</p>
<hr>
<h2 id="xv6的xchg函数"><a href="#xv6的xchg函数" class="headerlink" title="xv6的xchg函数"></a>xv6的xchg函数</h2><p>static inline uint<br>xchg(volatile uint <em>addr, uint newval)
</em>交换<em>addr和newval,然后把</em>addr的原先的值作为result返回!!!这只是从C层面可以这么从逻辑上理解.实际编译器干的有些区别,但是最终结果一致.<br>范例:见后面</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> uint</span><br><span class="line">xchg(<span class="keyword">volatile</span> uint *addr, uint newval)</span><br><span class="line">&#123;</span><br><span class="line">  uint result;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The + in "+m" denotes a read-modify-write operand.</span></span><br><span class="line">  <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">"lock; xchgl %0, %1"</span> :</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="string">"+m"</span> (*addr), <span class="string">"=a"</span> (result) :</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="string">"1"</span> (newval) :</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="string">"cc"</span>)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这个"1"感觉是代表对应前面的%1,指定位置的作用?没仔细查...猜的</span></span><br><span class="line">kernel.<span class="keyword">asm</span>:</span><br><span class="line"> <span class="number">8515</span>   <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">"lock; xchgl %0, %1"</span> :</span></span></span><br><span class="line"><span class="function"><span class="params"> <span class="number">8516</span> <span class="number">80104373</span>:       ba <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          mov    $<span class="number">0x1</span>,%edx</span></span></span><br><span class="line"><span class="function"><span class="params"> <span class="number">8517</span> <span class="number">80104378</span>:       eb <span class="number">09</span>                   jmp    <span class="number">80104383</span> &lt;acquire+<span class="number">0x33</span>&gt;</span></span></span><br><span class="line"><span class="function"><span class="params"> <span class="number">8518</span> <span class="number">8010437</span>a:       <span class="number">8</span>d b6 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       lea    <span class="number">0x0</span>(%esi),%esi</span></span></span><br><span class="line"><span class="function"><span class="params"> <span class="number">8519</span> <span class="number">80104380</span>:       <span class="number">8b</span> <span class="number">5</span>d <span class="number">08</span>                mov    <span class="number">0x8</span>(%ebp),%ebx</span></span></span><br><span class="line"><span class="function"><span class="params"> <span class="number">8520</span> <span class="number">80104383</span>:       <span class="number">89</span> d0                   mov    %edx,%eax</span></span></span><br><span class="line"><span class="function"><span class="params"> <span class="number">8521</span> <span class="number">80104385</span>:       f0 <span class="number">87</span> <span class="number">03</span>                lock xchg %eax,(%ebx)</span></span></span><br><span class="line"><span class="function"><span class="params"> <span class="number">8522</span>   <span class="keyword">while</span>(xchg(&amp;lk-&gt;locked, <span class="number">1</span>) != <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"><span class="params"> <span class="number">8523</span> <span class="number">80104388</span>:       <span class="number">85</span> c0                   test   %eax,%eax</span></span></span><br><span class="line"><span class="function"><span class="params"> <span class="number">8524</span> <span class="number">8010438</span>a:       <span class="number">75</span> f4                   jne    <span class="number">80104380</span> &lt;acquire+<span class="number">0x30</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>在实际运行的汇编代码里面为什么顺序又变了?前后的顺序?<br>猜测:这部分代码还是得根据实际运行的情况来看,test   %eax,%eax,即测试的是eax,而且”=a” (result) :<br>所以eax存的是交换之后的值,那么在交换之前,存在是newval<br>根据lock; xchgl (<em>addr), newval字面来套是这样的.因为eax得存交换后的值,所以eax交换前存的是newval<br>所以lock; xchgl (</em>addr), eax,然后就和实际运行看到的相反了…这个过程是编译器给做的.并不太清楚编译器寄存器分配<br>规则…</p>
<p>附上前后的其他东西,便于数那个&lt;acquire+0x30&gt;的位置十进制数偏移48,jne    80104380 &lt;acquire+0x30&gt;跳转到lea    0x0(%esi),%esi</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">8498</span> <span class="number">80104350</span> &lt;acquire&gt;:</span><br><span class="line"><span class="number">8499</span> &#123;</span><br><span class="line"><span class="number">8500</span> <span class="number">80104350</span>:       <span class="number">55</span>                      push   %ebp</span><br><span class="line"><span class="number">8501</span> <span class="number">80104351</span>:       <span class="number">89</span> e5                   mov    %esp,%ebp</span><br><span class="line"><span class="number">8502</span> <span class="number">80104353</span>:       <span class="number">56</span>                      push   %esi</span><br><span class="line"><span class="number">8503</span> <span class="number">80104354</span>:       <span class="number">53</span>                      push   %ebx</span><br><span class="line"><span class="number">8504</span>   pushcli(); <span class="comment">// disable interrupts to avoid deadlock.</span></span><br><span class="line"><span class="number">8505</span> <span class="number">80104355</span>:       e8 <span class="number">26</span> ff ff ff          call   <span class="number">80104280</span> &lt;pushcli&gt;</span><br><span class="line"><span class="number">8506</span>   <span class="keyword">if</span>(holding(lk))</span><br><span class="line"><span class="number">8507</span> <span class="number">8010435</span>a:       <span class="number">8b</span> <span class="number">5</span>d <span class="number">08</span>                mov    <span class="number">0x8</span>(%ebp),%ebx</span><br><span class="line"><span class="number">8508</span> <span class="number">8010435</span>d:       <span class="number">83</span> ec <span class="number">0</span>c                sub    $<span class="number">0xc</span>,%esp</span><br><span class="line"><span class="number">8509</span> <span class="number">80104360</span>:       <span class="number">53</span>                      push   %ebx</span><br><span class="line"><span class="number">8510</span> <span class="number">80104361</span>:       e8 ba ff ff ff          call   <span class="number">80104320</span> &lt;holding&gt;</span><br><span class="line"><span class="number">8511</span> <span class="number">80104366</span>:       <span class="number">83</span> c4 <span class="number">10</span>                add    $<span class="number">0x10</span>,%esp</span><br><span class="line"><span class="number">8512</span> <span class="number">80104369</span>:       <span class="number">85</span> c0                   test   %eax,%eax</span><br><span class="line"><span class="number">8513</span> <span class="number">8010436b</span>:       <span class="number">0f</span> <span class="number">85</span> <span class="number">83</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       jne    <span class="number">801043f</span>4 &lt;acquire+<span class="number">0xa4</span>&gt;</span><br><span class="line"><span class="number">8514</span> <span class="number">80104371</span>:       <span class="number">89</span> c6                   mov    %eax,%esi</span><br><span class="line"><span class="number">8515</span>   <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">"lock; xchgl %0, %1"</span> :   </span></span></span><br><span class="line"><span class="function"><span class="params"><span class="number">8516</span> <span class="number">80104373</span>:       ba <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          mov    $<span class="number">0x1</span>,%edx</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="number">8517</span> <span class="number">80104378</span>:       eb <span class="number">09</span>                   jmp    <span class="number">80104383</span> &lt;acquire+<span class="number">0x33</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<h2 id="xchg-使用案例-xv6的spinlock的acquire和release"><a href="#xchg-使用案例-xv6的spinlock的acquire和release" class="headerlink" title="xchg()使用案例,xv6的spinlock的acquire和release"></a>xchg()使用案例,xv6的spinlock的acquire和release</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">acquire(struct spinlock *lk)</span><br><span class="line">&#123;</span><br><span class="line">  pushcli(); <span class="comment">// disable interrupts to avoid deadlock.</span></span><br><span class="line">  <span class="keyword">if</span>(holding(lk))</span><br><span class="line">    panic(<span class="string">"acquire"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The xchg is atomic.</span></span><br><span class="line">  <span class="keyword">while</span>(xchg(&amp;lk-&gt;locked, <span class="number">1</span>) != <span class="number">0</span>)</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Tell the C compiler and the processor to not move loads or stores</span></span><br><span class="line">  <span class="comment">// past this point, to ensure that the critical section's memory</span></span><br><span class="line">  <span class="comment">// references happen after the lock is acquired.</span></span><br><span class="line">  __sync_synchronize();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Record info about lock acquisition for debugging.</span></span><br><span class="line">  lk-&gt;cpu = mycpu();</span><br><span class="line">  getcallerpcs(&amp;lk, lk-&gt;pcs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Release the lock.</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">release(struct spinlock *lk)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(!holding(lk))</span><br><span class="line">    panic(<span class="string">"release"</span>);</span><br><span class="line"></span><br><span class="line">  lk-&gt;pcs[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  lk-&gt;cpu = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  __sync_synchronize();</span><br><span class="line">  <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">"movl $0, %0"</span> : <span class="string">"+m"</span> (lk-&gt;locked) : )</span></span>;</span><br><span class="line"></span><br><span class="line">  popcli();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">8516</span> <span class="number">80104373</span>:       ba <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          mov    $<span class="number">0x1</span>,%edx</span><br><span class="line"> <span class="number">8517</span> <span class="number">80104378</span>:       eb <span class="number">09</span>                   jmp    <span class="number">80104383</span> &lt;acquire+<span class="number">0x33</span>&gt;</span><br><span class="line"> <span class="number">8518</span> <span class="number">8010437</span>a:       <span class="number">8</span>d b6 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       lea    <span class="number">0x0</span>(%esi),%esi</span><br><span class="line"> <span class="number">8519</span> <span class="number">80104380</span>:       <span class="number">8b</span> <span class="number">5</span>d <span class="number">08</span>                mov    <span class="number">0x8</span>(%ebp),%ebx</span><br><span class="line"> <span class="number">8520</span> <span class="number">80104383</span>:       <span class="number">89</span> d0                   mov    %edx,%eax</span><br><span class="line"> <span class="number">8521</span> <span class="number">80104385</span>:       f0 <span class="number">87</span> <span class="number">03</span>                lock xchg %eax,(%ebx)</span><br><span class="line"> <span class="number">8523</span> <span class="number">80104388</span>:       <span class="number">85</span> c0                   test   %eax,%eax</span><br><span class="line"> <span class="number">8524</span> <span class="number">8010438</span>a:       <span class="number">75</span> f4                   jne    <span class="number">80104380</span> &lt;acquire+<span class="number">0x30</span>&gt;</span><br><span class="line"><span class="comment">// 这八行汇编是底下的这个while循环被编译器编译后处理的结果,</span></span><br><span class="line"><span class="comment">// 在kernel.asm拿到的.详细的见前面的分析.jne    </span></span><br><span class="line"><span class="comment">// 80104380 &lt;acquire+0x30&gt;跳到lea    0x0(%esi),%esi</span></span><br><span class="line">  <span class="keyword">while</span>(xchg(&amp;lk-&gt;locked, <span class="number">1</span>) != <span class="number">0</span>)</span><br><span class="line">    ;</span><br><span class="line"><span class="comment">// 这个就是操作系统教材里面爱提的概念busy wait?</span></span><br><span class="line"><span class="comment">// 在汇编层面实际执行的循环是:</span></span><br><span class="line"> <span class="number">8518</span> <span class="number">8010437</span>a:       <span class="number">8</span>d b6 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       lea    <span class="number">0x0</span>(%esi),%esi</span><br><span class="line"> <span class="number">8519</span> <span class="number">80104380</span>:       <span class="number">8b</span> <span class="number">5</span>d <span class="number">08</span>                mov    <span class="number">0x8</span>(%ebp),%ebx</span><br><span class="line"> <span class="number">8520</span> <span class="number">80104383</span>:       <span class="number">89</span> d0                   mov    %edx,%eax</span><br><span class="line"> <span class="number">8521</span> <span class="number">80104385</span>:       f0 <span class="number">87</span> <span class="number">03</span>                lock xchg %eax,(%ebx)</span><br><span class="line"> <span class="number">8523</span> <span class="number">80104388</span>:       <span class="number">85</span> c0                   test   %eax,%eax</span><br><span class="line"> <span class="number">8524</span> <span class="number">8010438</span>a:       <span class="number">75</span> f4                   jne    <span class="number">80104380</span> &lt;acquire+<span class="number">0x30</span>&gt;</span><br></pre></td></tr></table></figure>
<p>没拿到锁的时候,lk-&gt;locked存的是0,拿到锁后存的是1.<br>情况A:假设lk这把spinlock的locked原来的状态是0,代表当前这把锁还没有被拿到过,然后进入acquire(),xchg()换lk-&gt;locked和1,交换后lk-&gt;locked存的变成1了,代表锁上了.然后从C层面看的话,xchg()返回的结果是lk-&gt;locked()交换之前的值.也就是0,所以while(0 != 0)条件不满足,false,while(false),那么不执行循环语句,在这里是空语句(;).然后执行__sync_synchronize();.代表拿到锁了.<br>情况B:假设lk这把spinlock的locked原来的状态是1,代表当前这把锁已经被拿过了,然后进入acquire(),xchg()换lk-&gt;locked和1,交换后lk-&gt;locked存的仍然是1(1和1交换).然后从C层面看的话,xchg()返回的结果是lk-&gt;locked()交换之前的值.也就是1,所以while(1 != 0)条件满足,true,while(true),那么执行循环语句,在这里是空语句(;)然后再次执行xchg()…还是1和1交换.然后再次执行xchg()…这个就是spinlock的本质!</p>
<h2 id="额外"><a href="#额外" class="headerlink" title="额外"></a>额外</h2><p>1.read-modify-write??</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The + in "+m" denotes a read-modify-write operand.</span></span><br><span class="line">+号在GCC-Inline-Assembly-HOWTO还没找着(没仔细找),还有这个read-modify-write operand,是原子操作的关键所在???!!!</span><br></pre></td></tr></table></figure>
<p>2.研究下busy wait和sleep<br><a href="https://stackoverflow.com/questions/1107593/what-are-trade-offs-for-busy-wait-vs-sleep" target="_blank" rel="noopener">What are trade offs for “busy wait” vs “sleep”?</a>还没看,但是待看…<br>感觉busy wait消耗cpu资源,sleep并没有消耗cpu资源(只是粗略的讲)</p>
<p>3.实际调试下,打断点.在acquire()上</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://mojiajun.github.io/post/11e7222f.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mojiajun">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mojiajun">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/post/11e7222f.html" itemprop="url">redis-项目文件概览</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-28T00:00:00+08:00">
                2019-04-28
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/源码阅读/" itemprop="url" rel="index">
                    <span itemprop="name">源码阅读</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/源码阅读/redis/" itemprop="url" rel="index">
                    <span itemprop="name">redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>[TOC]</p>
<p>基于redis-2.8</p>
<h2 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h2><h3 id="dict-h-c"><a href="#dict-h-c" class="headerlink" title="dict.h.c"></a>dict.h.c</h3><p>dict,hash的实现</p>
<h3 id="adlist-h-c"><a href="#adlist-h-c" class="headerlink" title="adlist.h.c"></a>adlist.h.c</h3><p>通用双向链表?</p>
<h3 id="sds-h-c"><a href="#sds-h-c" class="headerlink" title="sds.h.c"></a>sds.h.c</h3><p>封装了底层的字符串</p>
<h2 id="五种redis对象-基于底层数据结构"><a href="#五种redis对象-基于底层数据结构" class="headerlink" title="五种redis对象(基于底层数据结构)"></a>五种redis对象(基于底层数据结构)</h2><h3 id="t-list-c"><a href="#t-list-c" class="headerlink" title="t_list.c"></a>t_list.c</h3><h3 id="t-set-c"><a href="#t-set-c" class="headerlink" title="t_set.c"></a>t_set.c</h3><h3 id="t-string-c"><a href="#t-string-c" class="headerlink" title="t_string.c"></a>t_string.c</h3><h3 id="t-zset-c"><a href="#t-zset-c" class="headerlink" title="t_zset.c"></a>t_zset.c</h3><h3 id="t-hash-c"><a href="#t-hash-c" class="headerlink" title="t_hash.c"></a>t_hash.c</h3><h2 id="网络有关"><a href="#网络有关" class="headerlink" title="网络有关"></a>网络有关</h2><h3 id="networking-c"><a href="#networking-c" class="headerlink" title="networking.c"></a>networking.c</h3><p>和anet,ae的关系?</p>
<h3 id="anet-h-c"><a href="#anet-h-c" class="headerlink" title="anet.h.c"></a>anet.h.c</h3><p>a代表什么?封装了底层操作系统的socket API</p>
<h3 id="ae-h-c"><a href="#ae-h-c" class="headerlink" title="ae.h.c"></a>ae.h.c</h3><p>简单的事件驱动库,redis的reactor模式的实现</p>
<h4 id="ae-epoll-c-ae-evport-c-ae-kqueue-c-qe-select-c"><a href="#ae-epoll-c-ae-evport-c-ae-kqueue-c-qe-select-c" class="headerlink" title="ae_epoll.c,ae_evport.c,ae_kqueue.c,qe_select.c"></a>ae_epoll.c,ae_evport.c,ae_kqueue.c,qe_select.c</h4><p>这四个文件统一了不同操作系统提供的I/O event notification.<br>拿linux下的ae_epoll.c举例子,其在底层的epoll上面封了一层.</p>
<p>ae.h.c会使用这四种操作系统提供的event notification之一,对于ae.h.c来说,API是统一的.</p>
<h2 id="上层数据库"><a href="#上层数据库" class="headerlink" title="上层数据库"></a>上层数据库</h2><h3 id="redis-h-c"><a href="#redis-h-c" class="headerlink" title="redis.h.c"></a>redis.h.c</h3><p>redisDb是数据库的核心结构体,围绕它有redisClient,redisServer.分配代表客户端和服务器,然后再基于reactor模式,实现了两者之间的通信,典型的C/S架构.</p>
<p>redis.h里面的很多API函数是在其他的一些.c里实现的,不一定在redis.c里.例如redisDb的API函数就是在db.c里实现的.</p>
<h2 id="通用"><a href="#通用" class="headerlink" title="通用"></a>通用</h2><h3 id="zmalloc-h-c"><a href="#zmalloc-h-c" class="headerlink" title="zmalloc.h.c"></a>zmalloc.h.c</h3><p>封装了底层的malloc,calloc,remalloc,free四个函数.提供了可以进行内存分配统计的能力.</p>
<blockquote>
<p>  可以替换掉glibc的内存分配函数,例如可以用jemalloc库代替.有啥优点?</p>
</blockquote>
<h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><h3 id="version-h"><a href="#version-h" class="headerlink" title="version.h"></a>version.h</h3><p>版本号</p>
<h3 id="asciilogo-h"><a href="#asciilogo-h" class="headerlink" title="asciilogo.h"></a>asciilogo.h</h3><p>redis的ascii格式的logo,在服务器启动的时候会显示出来.</p>
<h3 id="config-c"><a href="#config-c" class="headerlink" title="config.c"></a>config.c</h3><p>解析配置文件的实现函数,API接口在redis.h里</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">mojiajun</p>
              <p class="site-description motion-element" itemprop="description">莫佳骏学习笔记</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">mojiajun</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>








        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
