<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="莫佳骏学习笔记">
<meta property="og:type" content="website">
<meta property="og:title" content="mojiajun">
<meta property="og:url" content="https://mojiajun.github.io/index.html">
<meta property="og:site_name" content="mojiajun">
<meta property="og:description" content="莫佳骏学习笔记">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="mojiajun">
<meta name="twitter:description" content="莫佳骏学习笔记">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://mojiajun.github.io/">





  <title>mojiajun</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">mojiajun</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://mojiajun.github.io/post/21a212dd.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mojiajun">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mojiajun">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/post/21a212dd.html" itemprop="url">Go-interface变量汇编探究</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-04-27T00:00:00+08:00">
                2020-04-27
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Go/" itemprop="url" rel="index">
                    <span itemprop="name">Go</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>[TOC]</p>
<p>Go interface变量这个16字节变量的(emptyInterface和nonEmptyInterface)汇编探究</p>
<p>Linux下机器,lldb version 6.0.0. 一般情况下macOS下的lldb用的挺正常的…这次不行.</p>
<p>换了台Linux的阿里云服务器.上面的lldb版本是6.0.0</p>
<p>lldb对Go的支持程度还没研究过.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lldb -v</span><br><span class="line">lldb version 6.0.0</span><br></pre></td></tr></table></figure>
<p>用于测试的Go代码如下</p>
<h3 id="一-用对象的指针来构造Tester这个interface"><a href="#一-用对象的指针来构造Tester这个interface" class="headerlink" title="一.用对象的指针来构造Tester这个interface."></a>一.用对象的指针来构造Tester这个interface.</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"unsafe"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Tester <span class="keyword">interface</span> &#123;</span><br><span class="line">	test()</span><br><span class="line">	<span class="keyword">string</span>() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Data <span class="keyword">struct</span> &#123;</span><br><span class="line">	ValA <span class="keyword">int</span></span><br><span class="line">	ValB <span class="keyword">int</span></span><br><span class="line">	ValC <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d Data)</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"test()"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d Data)</span> <span class="title">string</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">"abc"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	d := &amp;Data&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> i1 Tester = d</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> i2 <span class="keyword">interface</span>&#123;&#125; = i1  <span class="comment">// gdb 在 p i2的时候找不到这个符号,所以改用了lldb来看</span></span><br><span class="line">  </span><br><span class="line">	fmt.Println(unsafe.Pointer(&amp;i1))</span><br><span class="line">	fmt.Println(unsafe.Pointer(&amp;i2))</span><br><span class="line">	i1.test()</span><br><span class="line">	i1.<span class="keyword">string</span>()</span><br><span class="line">	<span class="keyword">if</span> typ, ok := i2.(*Data); ok &#123;</span><br><span class="line">		typ.test()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> build -o tmp_main -gcflags <span class="string">"all=-N -l"</span> main.<span class="keyword">go</span></span><br><span class="line"></span><br><span class="line">(lldb) br s -n main.main  <span class="comment">// 在Go的main函数打断点</span></span><br><span class="line">(lldb) n  <span class="comment">// 执行几次下一条语句</span></span><br><span class="line">(lldb) n</span><br><span class="line">(lldb) n</span><br><span class="line">(lldb) n</span><br><span class="line"></span><br><span class="line">i1(nonEmptyInterface)和i2(emptyInterface)也是两个对象,都是<span class="number">16</span>字节大小.分别对应Go里面的</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span>/<span class="number">1.14</span>/libexec/src/reflect/value.<span class="keyword">go</span></span><br><span class="line"><span class="comment">// emptyInterface is the header for an interface&#123;&#125; value.</span></span><br><span class="line"><span class="keyword">type</span> emptyInterface <span class="keyword">struct</span> &#123;</span><br><span class="line">	typ  *rtype</span><br><span class="line">	word unsafe.Pointer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// nonEmptyInterface is the header for an interface value with methods.</span></span><br><span class="line"><span class="keyword">type</span> nonEmptyInterface <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// see ../runtime/iface.go:/Itab</span></span><br><span class="line">	itab *<span class="keyword">struct</span> &#123;</span><br><span class="line">		ityp *rtype <span class="comment">// static interface type</span></span><br><span class="line">		typ  *rtype <span class="comment">// dynamic concrete type</span></span><br><span class="line">		hash <span class="keyword">uint32</span> <span class="comment">// copy of typ.hash</span></span><br><span class="line">		_    [<span class="number">4</span>]<span class="keyword">byte</span></span><br><span class="line">		fun  [<span class="number">100000</span>]unsafe.Pointer <span class="comment">// method table</span></span><br><span class="line">	&#125;</span><br><span class="line">	word unsafe.Pointer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">这俩对象的首地址用</span><br><span class="line">	fmt.Println(unsafe.Pointer(&amp;i1))</span><br><span class="line">	fmt.Println(unsafe.Pointer(&amp;i2))</span><br><span class="line">输出是</span><br><span class="line"><span class="number">0xc42000e1e0</span> -&gt;fmt.Println(unsafe.Pointer(&amp;i1))的输出</span><br><span class="line"><span class="number">0xc42000e1f</span>0 -&gt;fmt.Println(unsafe.Pointer(&amp;i2))的输出</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">然后用memory read查看一下i1.</span><br><span class="line">(lldb) memory read --size <span class="number">1</span> --format x --count <span class="number">16</span> <span class="number">0xc42000e1e0</span></span><br><span class="line"><span class="number">0xc42000e1e0</span>: <span class="number">0xc0</span> <span class="number">0x97</span> <span class="number">0x4d</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span></span><br><span class="line"><span class="number">0xc42000e1e8</span>: <span class="number">0x40</span> <span class="number">0x21</span> <span class="number">0x01</span> <span class="number">0x20</span> <span class="number">0xc4</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span></span><br><span class="line">(lldb) expression i1</span><br><span class="line">(main.Tester) *&amp;i1 = &#123;</span><br><span class="line">  tab = <span class="number">0x00000000004d</span>97c0</span><br><span class="line">  data = <span class="number">0x000000c420012140</span></span><br><span class="line">&#125;</span><br><span class="line">这个有个比较奇怪的问题. 用lldb想直接查看i1这个<span class="number">16</span>字节的nonEmptyInterface对象的地址(即首地址),失败...返回的不对, 是内部的tab的值.why?</span><br><span class="line">(lldb) expression &amp;i1</span><br><span class="line">(*main.Tester)  = <span class="number">0x00000000004d</span>97c0</span><br><span class="line"></span><br><span class="line">看一下i2</span><br><span class="line">(lldb) memory read --size <span class="number">1</span> --format x --count <span class="number">16</span> <span class="number">0xc42000e1f</span>0</span><br><span class="line"><span class="number">0xc42000e1f</span>0: <span class="number">0x80</span> <span class="number">0x47</span> <span class="number">0x4b</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span></span><br><span class="line"><span class="number">0xc42000e1f</span>8: <span class="number">0x40</span> <span class="number">0x21</span> <span class="number">0x01</span> <span class="number">0x20</span> <span class="number">0xc4</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span></span><br><span class="line">(lldb) expression i2</span><br><span class="line">(<span class="keyword">interface</span> &#123;&#125;) *&amp;i2 = &#123;</span><br><span class="line">  _type = <span class="number">0x00000000004b4780</span></span><br><span class="line">  data = <span class="number">0x000000c420012140</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">因为Go源码里是d := &amp;Data&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;,d会是一个地址,<span class="number">8</span>字节</span><br><span class="line">d是多少?</span><br><span class="line">(lldb) expression d</span><br><span class="line">(*main.Data) d = <span class="number">0x000000c420012140</span> (main.Tester.data/<span class="keyword">interface</span> &#123;&#125;.data值完全一样!)</span><br><span class="line">d里面的值</span><br><span class="line">(lldb) expression *d</span><br><span class="line">(main.Data) *d = (ValA = <span class="number">1</span>, ValB = <span class="number">2</span>, ValC = <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">再看i1.tab</span><br><span class="line">(lldb) expression i1.tab</span><br><span class="line">(*runtime.itab) tab = <span class="number">0x00000000004d</span>97c0</span><br><span class="line">(lldb) expression *(i1.tab)</span><br><span class="line">(runtime.itab) *tab = &#123;</span><br><span class="line">  inter = <span class="number">0x00000000004b5940</span></span><br><span class="line">  _type = <span class="number">0x00000000004b4780</span>    <span class="comment">// !!! 这个_type和i2的_type是完全一样的8个字节的地址!!!</span></span><br><span class="line">  hash = <span class="number">2596277159</span></span><br><span class="line">  _ = ([<span class="number">0</span>] = <span class="number">0</span>, [<span class="number">1</span>] = <span class="number">0</span>, [<span class="number">2</span>] = <span class="number">0</span>, [<span class="number">3</span>] = <span class="number">0</span>)</span><br><span class="line">  fun = ([<span class="number">0</span>] = <span class="number">0x000000000049b850</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通过查看i1.tab._type和i2._type.发现它们俩完全一样的8个字节的值.这说明</span></span><br><span class="line"><span class="keyword">var</span> i2 <span class="keyword">interface</span>&#123;&#125; = i1</span><br><span class="line">在制造i2的时候</span><br><span class="line"><span class="number">1.</span>把i1.tab._type提取出来</span><br><span class="line"><span class="number">2.</span>把i1.data提取出来</span><br><span class="line">然后用这两个值来构造<span class="keyword">interface</span>&#123;&#125;这个<span class="number">16</span>字节对象.</span><br></pre></td></tr></table></figure>
<h3 id="二-用对象本身来构造Tester这个interface"><a href="#二-用对象本身来构造Tester这个interface" class="headerlink" title="二.用对象本身来构造Tester这个interface."></a>二.用对象本身来构造Tester这个interface.</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"unsafe"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Tester <span class="keyword">interface</span> &#123;</span><br><span class="line">	test()</span><br><span class="line">	<span class="keyword">string</span>() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Data <span class="keyword">struct</span> &#123;</span><br><span class="line">	ValA <span class="keyword">int</span></span><br><span class="line">	ValB <span class="keyword">int</span></span><br><span class="line">	ValC <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d Data)</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"test()"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d Data)</span> <span class="title">string</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">"abc"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	d := Data&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;  <span class="comment">// 这里改了</span></span><br><span class="line">  fmt.Println(unsafe.Pointer(&amp;d))</span><br><span class="line">	<span class="keyword">var</span> i1 Tester = d</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> i2 <span class="keyword">interface</span>&#123;&#125; = i1  <span class="comment">// gdb 在 p i2的时候找不到这个符号,所以改用了lldb来看</span></span><br><span class="line">  </span><br><span class="line">	fmt.Println(unsafe.Pointer(&amp;i1))</span><br><span class="line">	fmt.Println(unsafe.Pointer(&amp;i2))</span><br><span class="line">	i1.test()</span><br><span class="line">	i1.<span class="keyword">string</span>()</span><br><span class="line">	<span class="keyword">if</span> typ, ok := i2.(*Data); ok &#123;</span><br><span class="line">		typ.test()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">0xc420012140</span> -&gt;fmt.Println(unsafe.Pointer(&amp;d))  <span class="comment">// !注意源对象的值是0x**140...</span></span><br><span class="line"><span class="number">0xc42000e1e0</span> -&gt;fmt.Println(unsafe.Pointer(&amp;i1))</span><br><span class="line"><span class="number">0xc42000e1f</span>0 -&gt;fmt.Println(unsafe.Pointer(&amp;i2))</span><br><span class="line"></span><br><span class="line">(lldb) expression i1</span><br><span class="line">(main.Tester) *&amp;i1 = &#123;</span><br><span class="line">  tab = <span class="number">0x00000000004d</span>97e0</span><br><span class="line">  data = <span class="number">0x000000c420012160</span>  <span class="comment">// </span></span><br><span class="line">&#125;</span><br><span class="line">(lldb) expression i2</span><br><span class="line">(<span class="keyword">interface</span> &#123;&#125;) *&amp;i2 = &#123;</span><br><span class="line">  _type = <span class="number">0x00000000004bf</span>9c0</span><br><span class="line">  data = <span class="number">0x000000c420012160</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// type Data struct占24字节, 所以--count 24</span></span><br><span class="line">(lldb) memory read --size <span class="number">1</span> --format x --count <span class="number">24</span> <span class="number">0x000000c420012160</span></span><br><span class="line"><span class="comment">// 注意!!!此时的i1.data和i2.data的值都是0x000000c420012160.和0xc420012140不一样了!!!</span></span><br><span class="line"><span class="comment">// 所以这么写</span></span><br><span class="line">d := Data&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">var</span> i1 Tester = d</span><br><span class="line"><span class="comment">// 会发生对象的一个拷贝!!!在生成Tester这个16字节对象的时候,然后把拷贝后的那个Data对象的地址0x000000c420012160赋值给了i1.data!</span></span><br><span class="line"><span class="comment">// 注意小端法, int在Go里面是8字节, 最低有效位01/02/03这些在最低地址</span></span><br><span class="line"><span class="number">0xc420012160</span>: <span class="number">0x01</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span></span><br><span class="line"><span class="number">0xc420012168</span>: <span class="number">0x02</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span></span><br><span class="line"><span class="number">0xc420012170</span>: <span class="number">0x03</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span></span><br><span class="line"></span><br><span class="line">如果读一下<span class="number">0xc420012140</span>位置...这是原来的对象的地址</span><br><span class="line">(lldb) memory read --size <span class="number">1</span> --format x --count <span class="number">24</span> <span class="number">0xc420012140</span></span><br><span class="line"><span class="number">0xc420012140</span>: <span class="number">0x01</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span></span><br><span class="line"><span class="number">0xc420012148</span>: <span class="number">0x02</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span></span><br><span class="line"><span class="number">0xc420012150</span>: <span class="number">0x03</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span></span><br><span class="line"></span><br><span class="line">如果多读一点</span><br><span class="line">(lldb) memory read --size <span class="number">1</span> --format x --count <span class="number">60</span> <span class="number">0xc420012140</span></span><br><span class="line"><span class="number">0xc420012140</span>: <span class="number">0x01</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span></span><br><span class="line"><span class="number">0xc420012148</span>: <span class="number">0x02</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span></span><br><span class="line"><span class="number">0xc420012150</span>: <span class="number">0x03</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span></span><br><span class="line"><span class="number">0xc420012158</span>: <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span></span><br><span class="line"><span class="number">0xc420012160</span>: <span class="number">0x01</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span></span><br><span class="line"><span class="number">0xc420012168</span>: <span class="number">0x02</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span></span><br><span class="line"><span class="number">0xc420012170</span>: <span class="number">0x03</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span></span><br><span class="line"><span class="number">0xc420012178</span>: <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span></span><br><span class="line">这个拷贝后的对象就在原先那个对象的附近...</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">按源码解释一下</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	d := Data&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;  <span class="comment">// d是一个对象,不是指针</span></span><br><span class="line">  fmt.Println(unsafe.Pointer(&amp;d))</span><br><span class="line">	<span class="keyword">var</span> i1 Tester = d.  <span class="comment">// 这里会发生一个Data对象的构造, 产生一份拷贝...只在这里会产生一份Data这个24字节的对象一份新的拷贝.</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> i2 <span class="keyword">interface</span>&#123;&#125; = i1  <span class="comment">// 这里不会产生Data的拷贝了</span></span><br><span class="line">  </span><br><span class="line">	fmt.Println(unsafe.Pointer(&amp;i1))</span><br><span class="line">	fmt.Println(unsafe.Pointer(&amp;i2))</span><br><span class="line">	i1.test()</span><br><span class="line">	i1.<span class="keyword">string</span>()</span><br><span class="line">	<span class="keyword">if</span> typ, ok := i2.(*Data); ok &#123;</span><br><span class="line">		typ.test()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="同理-如果直接是用对象或对象的指针去构造interface"><a href="#同理-如果直接是用对象或对象的指针去构造interface" class="headerlink" title="同理,如果直接是用对象或对象的指针去构造interface{}"></a>同理,如果直接是用对象或对象的指针去构造interface{}</h3><h4 id="用对象的指针去构造interface"><a href="#用对象的指针去构造interface" class="headerlink" title="用对象的指针去构造interface{}"></a>用对象的指针去构造interface{}</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前面的代码和之前的一样...</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    d := &amp;Data&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;  <span class="comment">// d是一个指针,本身占8字节</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">var</span> i2 <span class="keyword">interface</span>&#123;&#125; = d</span><br><span class="line">  </span><br><span class="line">    fmt.Println(unsafe.Pointer(&amp;i2))</span><br><span class="line">    <span class="keyword">if</span> typ, ok := i2.(*Data); ok &#123;</span><br><span class="line">        typ.test()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(lldb) expression d</span><br><span class="line">(*main.Data) d = <span class="number">0x000000c420012140</span></span><br><span class="line">(lldb) expression *d</span><br><span class="line">(main.Data) *d = (ValA = <span class="number">1</span>, ValB = <span class="number">2</span>, ValC = <span class="number">3</span>)</span><br><span class="line">(lldb) expression i2</span><br><span class="line">(<span class="keyword">interface</span> &#123;&#125;) *&amp;i2 = &#123;</span><br><span class="line">  _type = <span class="number">0x00000000004b4720</span></span><br><span class="line">  data = <span class="number">0x000000c420012140</span>  <span class="comment">// 用对象的指针构造interface&#123;&#125;,其中的data数据域和d完全一样...没发生拷贝</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="用对象本身去构造interface"><a href="#用对象本身去构造interface" class="headerlink" title="用对象本身去构造interface{}"></a>用对象本身去构造interface{}</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前面的代码和之前的一样...</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    d := Data&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;  <span class="comment">// d现在是个对象,d在这里例子里面占24字节</span></span><br><span class="line">  	fmt.Println(unsafe.Pointer(&amp;d))</span><br><span class="line">    <span class="keyword">var</span> i2 <span class="keyword">interface</span>&#123;&#125; = d</span><br><span class="line">  </span><br><span class="line">    fmt.Println(unsafe.Pointer(&amp;i2))</span><br><span class="line">    <span class="keyword">if</span> typ, ok := i2.(*Data); ok &#123;</span><br><span class="line">        typ.test()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">0xc420012140</span> -&gt;fmt.Println(unsafe.Pointer(&amp;d))的输出	</span><br><span class="line"></span><br><span class="line">(lldb) expression i2</span><br><span class="line">(<span class="keyword">interface</span> &#123;&#125;) *&amp;i2 = &#123;</span><br><span class="line">  _type = <span class="number">0x00000000004bf</span>8e0</span><br><span class="line">  data = <span class="number">0x000000c420012160</span>     <span class="comment">// 用对象本身去构造interface&#123;&#125;,会发生Data这个对象的拷贝. i2.data已经不等于&amp;d了!!!</span></span><br><span class="line">&#125;</span><br><span class="line">和之前一样可以查看一下内存</span><br><span class="line">(lldb) memory read --size <span class="number">1</span> --format x --count <span class="number">60</span> <span class="number">0xc420012140</span></span><br><span class="line"><span class="number">0xc420012140</span>: <span class="number">0x01</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span></span><br><span class="line"><span class="number">0xc420012148</span>: <span class="number">0x02</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span></span><br><span class="line"><span class="number">0xc420012150</span>: <span class="number">0x03</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span></span><br><span class="line"><span class="number">0xc420012158</span>: <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span></span><br><span class="line"><span class="number">0xc420012160</span>: <span class="number">0x01</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span></span><br><span class="line"><span class="number">0xc420012168</span>: <span class="number">0x02</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span></span><br><span class="line"><span class="number">0xc420012170</span>: <span class="number">0x03</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span></span><br><span class="line"><span class="number">0xc420012178</span>: <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span></span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在构造interface{}/或具有method的interface(对应nonEmptyInterface/emptyInterface)这两种interface时,用对象本身和对象的指针去构造出来的过程和结果都有点不一样.</p>
<p>第一种情况,对象本身会发生拷贝:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    d := Data&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">var</span> i2 <span class="keyword">interface</span>&#123;&#125; = d</span><br><span class="line">    <span class="comment">// 或var i1 Tester = d</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二情况,对象本身不发生拷贝</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    d := &amp;Data&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">var</span> i2 <span class="keyword">interface</span>&#123;&#125; = d</span><br><span class="line">    <span class="comment">// 或var i1 Tester = d</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后其他需要注意的就是去理解一下nonEmptyInterface/emptyInterface这两种interface的内存布局的区别…</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span>/<span class="number">1.14</span>/libexec/src/reflect/value.<span class="keyword">go</span></span><br><span class="line"><span class="comment">// emptyInterface is the header for an interface&#123;&#125; value.</span></span><br><span class="line"><span class="keyword">type</span> emptyInterface <span class="keyword">struct</span> &#123;</span><br><span class="line">	typ  *rtype</span><br><span class="line">	word unsafe.Pointer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// nonEmptyInterface is the header for an interface value with methods.</span></span><br><span class="line"><span class="keyword">type</span> nonEmptyInterface <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// see ../runtime/iface.go:/Itab</span></span><br><span class="line">	itab *<span class="keyword">struct</span> &#123;</span><br><span class="line">		ityp *rtype <span class="comment">// static interface type</span></span><br><span class="line">		typ  *rtype <span class="comment">// dynamic concrete type</span></span><br><span class="line">		hash <span class="keyword">uint32</span> <span class="comment">// copy of typ.hash</span></span><br><span class="line">		_    [<span class="number">4</span>]<span class="keyword">byte</span></span><br><span class="line">		fun  [<span class="number">100000</span>]unsafe.Pointer <span class="comment">// method table</span></span><br><span class="line">	&#125;</span><br><span class="line">	word unsafe.Pointer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果是用nonEmptyInterface这种interface赋值给emptyInterface,比如:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	d := &amp;Data&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> i1 Tester = d</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> i2 <span class="keyword">interface</span>&#123;&#125; = i1  <span class="comment">// 用nonEmptyInterface这种interface赋值给emptyInterface</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>var i2 interface{} = i1的构造过程:<br>在制造i2的时候<br>1.把i1.tab._type提取出来<br>2.把i1.data提取出来<br>然后用这两个值来构造interface{}这个16字节对象.</p>
<p>会发生这种赋值的一个例子:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	d := Data&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> i1 Tester = d</span><br><span class="line"></span><br><span class="line">	fmt.Println(reflect.TypeOf(i1))   <span class="comment">// 输出main.Data</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	d := &amp;Data&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> i1 Tester = d</span><br><span class="line"></span><br><span class="line">	fmt.Println(reflect.TypeOf(i1))   <span class="comment">// 输出*main.Data</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中TypeOf源码是</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TypeOf returns the reflection Type that represents the dynamic type of i.</span></span><br><span class="line"><span class="comment">// If i is a nil interface value, TypeOf returns nil.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TypeOf</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">Type</span></span> &#123;</span><br><span class="line">	eface := *(*emptyInterface)(unsafe.Pointer(&amp;i))</span><br><span class="line">	<span class="keyword">return</span> toType(eface.typ)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://mojiajun.github.io/post/688ffe04.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mojiajun">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mojiajun">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/post/688ffe04.html" itemprop="url">回溯法-N皇后问题-递归非递归实现-子集组合全排列的非递归实现</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-04-19T00:00:00+08:00">
                2020-04-19
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法与数据结构/" itemprop="url" rel="index">
                    <span itemprop="name">算法与数据结构</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法与数据结构/Leetcode/" itemprop="url" rel="index">
                    <span itemprop="name">Leetcode</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>[TOC]</p>
<h3 id="N皇后递归实现"><a href="#N皇后递归实现" class="headerlink" title="N皇后递归实现"></a>N皇后递归实现</h3><p>常规思路</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  Solution() : total_(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; solveNQueens(<span class="keyword">int</span> n) &#123;</span><br><span class="line">      <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; allres;</span><br><span class="line">      <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> allres;</span><br><span class="line">      dim_ = n;</span><br><span class="line">      <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; board(n, <span class="built_in">string</span>(n, <span class="string">'.'</span>));</span><br><span class="line">      <span class="comment">// 在row = 0的这一行放置一个皇后</span></span><br><span class="line">      dfs(board, allres, <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">return</span> allres;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getTotal</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> total_; &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">/// board:</span></span><br><span class="line">  <span class="comment">/// allres:</span></span><br><span class="line">  <span class="comment">/// row: 这个dfs目前在处理哪一行</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;board, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; &amp;allres, <span class="keyword">int</span> row)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (row == dim_) &#123;  <span class="comment">// 如果已经到了最后最后一行的下一行</span></span><br><span class="line">          <span class="comment">// 保存当前的board</span></span><br><span class="line">          total_ += <span class="number">1</span>;</span><br><span class="line">          allres.push_back(board);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; dim_; ++col) &#123;  <span class="comment">// 对目前这一行的所有点进行考虑</span></span><br><span class="line">          <span class="comment">// 比如一开始就是这四个点:[0][0], [0][1], [0][2], [0][3]</span></span><br><span class="line">          <span class="comment">// 如果在当前的board里, 在[row][col]这个点能放置皇后</span></span><br><span class="line">          <span class="keyword">if</span> (isPointRowColInsertableWithPreQueens(board, row, col)) &#123;</span><br><span class="line">              <span class="comment">// 那么放置</span></span><br><span class="line">              board[row][col] = <span class="string">'Q'</span>;</span><br><span class="line">              <span class="comment">// dfs进入下一行, (因为这一行已经放置过了)</span></span><br><span class="line">              dfs(board, allres, row + <span class="number">1</span>);</span><br><span class="line">              <span class="comment">// 对board进行还原(), 就是在这里回溯的!!!</span></span><br><span class="line">              board[row][col] = <span class="string">'.'</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 1. 不能同行(即row相同, col不同): 这一点由dfs的实现保证, 不需要检查</span></span><br><span class="line">  <span class="comment">/// 2. 不能同列()</span></span><br><span class="line">  <span class="comment">/// 3. 不能处在对角线.(两个方向的对角线)</span></span><br><span class="line">  <span class="comment">/// 2/3后面两点而且只需要考虑'&lt;row'的行!!!因为后面的行还没有放置皇后, 不需要考虑</span></span><br><span class="line">  <span class="comment">//在调用isPointRowColInsertableWithPreQueens的时候, board[row][col]还没有放置'Q'</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">isPointRowColInsertableWithPreQueens</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;board, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//不能同列, 那么就和之前的行比较</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> pre_row = row - <span class="number">1</span>; pre_row &gt;= <span class="number">0</span>; --pre_row) &#123;</span><br><span class="line">          <span class="keyword">if</span> (board[pre_row][col] == <span class="string">'Q'</span>) &#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 不能同对角线, 左上角的对角线</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> left_top_row = row - <span class="number">1</span>, left_top_col = col - <span class="number">1</span>; left_top_row &gt;= <span class="number">0</span> &amp;&amp; left_top_col &gt;= <span class="number">0</span>;</span><br><span class="line">           --left_top_row, --left_top_col) &#123;</span><br><span class="line">          <span class="keyword">if</span> (board[left_top_row][left_top_col] == <span class="string">'Q'</span>) &#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 不能同对角线, 右上角的对角线</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> right_top_row = row - <span class="number">1</span>, right_top_col = col + <span class="number">1</span>; right_top_row &gt;= <span class="number">0</span> &amp;&amp; right_top_col &lt; dim_;</span><br><span class="line">           --right_top_row, ++right_top_col) &#123;</span><br><span class="line">          <span class="keyword">if</span> (board[right_top_row][right_top_col] == <span class="string">'Q'</span>) &#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> total_ = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// board是个正方形</span></span><br><span class="line">  <span class="keyword">int</span> dim_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Solution solution;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">8</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; results = solution.solveNQueens(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; results.size(); ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; results[<span class="number">0</span>].size(); ++j) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; results[i][j] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"when n = "</span> &lt;&lt; n &lt;&lt; <span class="string">", total: "</span> &lt;&lt; solution.getTotal() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//int main() &#123;</span></span><br><span class="line"><span class="comment">//    for (int n = 1; n &lt;= 10; ++n) &#123;</span></span><br><span class="line"><span class="comment">//        Solution solution;</span></span><br><span class="line"><span class="comment">//        vector&lt;vector&lt;string&gt;&gt; results = solution.solveNQueens(n);</span></span><br><span class="line"><span class="comment">//        std::cout &lt;&lt; "when n = " &lt;&lt; n &lt;&lt; ", total: " &lt;&lt; solution.getTotal() &lt;&lt; '\n';</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//when n = 1, total: 1</span></span><br><span class="line"><span class="comment">//when n = 2, total: 0</span></span><br><span class="line"><span class="comment">//when n = 3, total: 0</span></span><br><span class="line"><span class="comment">//when n = 4, total: 2</span></span><br><span class="line"><span class="comment">//when n = 5, total: 10</span></span><br><span class="line"><span class="comment">//when n = 6, total: 4</span></span><br><span class="line"><span class="comment">//when n = 7, total: 40</span></span><br><span class="line"><span class="comment">//when n = 8, total: 92</span></span><br><span class="line"><span class="comment">//when n = 9, total: 352</span></span><br><span class="line"><span class="comment">//when n = 10, total: 724</span></span><br></pre></td></tr></table></figure>
<h3 id="N皇后非递归实现"><a href="#N皇后非递归实现" class="headerlink" title="N皇后非递归实现"></a>N皇后非递归实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; solveNQueens(<span class="keyword">int</span> n) &#123;</span><br><span class="line">      dim_ = n;</span><br><span class="line">      <span class="comment">// 每一行的皇后的列位置, 下标从1开始</span></span><br><span class="line">      <span class="comment">// 行列的位置都是[1, dim_]</span></span><br><span class="line">      <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pos(dim_ + <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">      iterateSolve(pos);</span><br><span class="line">      <span class="keyword">return</span> results_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getTotal</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> total_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">iterateSolve</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;pos)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 第一个放置位置在[1, 1]</span></span><br><span class="line">      <span class="keyword">int</span> row = <span class="number">1</span>, col = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">          <span class="comment">// 从当前行找一个可放置位置</span></span><br><span class="line">          <span class="keyword">while</span> (row &lt;= dim_ &amp;&amp; col &lt;= dim_) &#123;</span><br><span class="line">              <span class="keyword">if</span> (isValid(pos, row, col)) &#123;</span><br><span class="line">                  <span class="comment">// 第row行设置皇后位置为col</span></span><br><span class="line">                  pos[row] = col;</span><br><span class="line">                  <span class="comment">// 去下一行找</span></span><br><span class="line">                  row += <span class="number">1</span>;</span><br><span class="line">                  <span class="comment">// 列的位置重置为1</span></span><br><span class="line">                  col = <span class="number">1</span>;</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">// 当前row, col的位置不能放置皇后, row不变, ++col;</span></span><br><span class="line">              ++col;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 当所有行都已经有一个皇后</span></span><br><span class="line">          <span class="keyword">if</span> (row &gt; dim_) &#123;</span><br><span class="line">              total_ += <span class="number">1</span>;</span><br><span class="line">              results_.push_back(generateBoardFromPos(pos));</span><br><span class="line">              row = dim_;  <span class="comment">// 仍然扫描最后一行</span></span><br><span class="line">              <span class="comment">// 下一列</span></span><br><span class="line">              col = pos[row] + <span class="number">1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 当前行已经扫描完了, 需要回到上一行了</span></span><br><span class="line">          <span class="keyword">if</span> (col &gt; dim_) &#123;</span><br><span class="line">              <span class="keyword">if</span> (row == <span class="number">1</span>) &#123;</span><br><span class="line">                  <span class="comment">// 是不是第一行已经考虑完了, 是的话, 总的while循环退出</span></span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="comment">// 把目前这一行放置的皇后取消</span></span><br><span class="line">                  <span class="comment">// 回溯</span></span><br><span class="line">                  pos[row] = <span class="number">-1</span>;</span><br><span class="line">                  <span class="comment">// 去上一行</span></span><br><span class="line">                  row -= <span class="number">1</span>;</span><br><span class="line">                  <span class="comment">// 上一行的后一个位置</span></span><br><span class="line">                  col = pos[row] + <span class="number">1</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 根据pos数组得出一个board</span></span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; generateBoardFromPos(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;pos) &#123;</span><br><span class="line">      <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; board(dim_, <span class="built_in">string</span>(dim_, <span class="string">'.'</span>));</span><br><span class="line">      <span class="comment">// [1, dim_]行</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">1</span>; row &lt;= dim_; ++row) &#123;</span><br><span class="line">          <span class="keyword">int</span> x = row - <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">int</span> y = pos[row] - <span class="number">1</span>;</span><br><span class="line">          board[x][y] = <span class="string">'Q'</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> board;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// isValid功能: 要在board[row][col]这个位置放置皇后, 可以放吗?</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 1. 不能同行(即row相同, col不同): 这一点由实现本身保证(因为一行pos[row]只会有一个列的位置), 不需要检查</span></span><br><span class="line">  <span class="comment">/// 2. 不能同列</span></span><br><span class="line">  <span class="comment">/// 3. 不能处在对角线.(两个方向的对角线)</span></span><br><span class="line">  <span class="comment">/// 2/3后面两点而且只需要考虑'&lt;row'的行!!!因为后面的行还没有放置皇后, 不需要考虑, 即与行在[1, row - 1]之间的皇后比较是否冲突</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;pos, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">      assert(row &gt;= <span class="number">1</span> &amp;&amp; row &lt;= dim_);</span><br><span class="line">      assert(col &gt;= <span class="number">1</span> &amp;&amp; col &lt;= dim_);</span><br><span class="line">      <span class="comment">// 不能同列, 那么就和之前的行比较</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> pre_row = row - <span class="number">1</span>; pre_row &gt;= <span class="number">1</span>; --pre_row) &#123;</span><br><span class="line">          <span class="keyword">if</span> (pos[pre_row] == col) &#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 不能同对角线, 左上角的对角线</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> left_top_row = row - <span class="number">1</span>, left_top_col = col - <span class="number">1</span>; left_top_row &gt;= <span class="number">1</span> &amp;&amp; left_top_col &gt;= <span class="number">1</span>;</span><br><span class="line">           --left_top_row, --left_top_col) &#123;</span><br><span class="line">          <span class="keyword">if</span> (pos[left_top_row] == left_top_col) &#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 不能同对角线, 右上角的对角线</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> right_top_row = row - <span class="number">1</span>, right_top_col = col + <span class="number">1</span>; right_top_row &gt;= <span class="number">1</span> &amp;&amp; right_top_col &lt;= dim_;</span><br><span class="line">           --right_top_row, ++right_top_col) &#123;</span><br><span class="line">          <span class="keyword">if</span> (pos[right_top_row] == right_top_col) &#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; results_;</span><br><span class="line">  <span class="keyword">int</span> total_ = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> dim_ = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Solution solution;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">8</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; results = solution.solveNQueens(n);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"when n = "</span> &lt;&lt; n &lt;&lt; <span class="string">" , the number of total is: "</span> &lt;&lt; solution.getTotal() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;res : results) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;stringcol : res) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; stringcol &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"\n\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Leetcode51就是这个题.经典问题</p>
<p>本质还是DFS搜索,只不过没用递归,和递归解法一样.都是对解空间的那棵树进行搜索…只不过用非递归的方法来回溯和深度优先搜索.</p>
<p>也没用stack…用stack也能实现另外一个版本的非递归N皇后解法(这种解法大体还是类似于用vector<int> pos的解法,把这个vector<int> pos换成了stack<int> 不过用stack的方法感觉不如这种用vector<int> pos定义一个position数组的方法…更好的stack解法待研究).</int></int></int></int></p>
<hr>
<h3 id="利用N皇后非递归回溯的思路做子集-组合-全排列三道题"><a href="#利用N皇后非递归回溯的思路做子集-组合-全排列三道题" class="headerlink" title="利用N皇后非递归回溯的思路做子集/组合/全排列三道题"></a>利用N皇后非递归回溯的思路做子集/组合/全排列三道题</h3><p>递归解法就不贴上来了.比较简单.见<a href="https://github.com/labuladong/fucking-algorithm" target="_blank" rel="noopener">fucking-algorithm</a>/<a href="https://github.com/labuladong/fucking-algorithm/tree/master/高频面试系列" target="_blank" rel="noopener">高频面试系列</a>/子集排列组合.md</p>
<p>三道题的解法都类似于N皇后的非递归的思路…</p>
<h4 id="子集"><a href="#子集" class="headerlink" title="子集"></a>子集</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; solveQuestion(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums) &#123;</span><br><span class="line">      <span class="keyword">int</span> rows = nums.size();</span><br><span class="line">      dims_ = rows;</span><br><span class="line">      <span class="comment">// 列位置, 下标从1开始</span></span><br><span class="line">      <span class="comment">// 行列的位置都是[1, ...]</span></span><br><span class="line">      <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pos(dims_ + <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">      iterateSolve(pos, nums);</span><br><span class="line">      <span class="keyword">return</span> results_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getTotal</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> total_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">iterateSolve</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;pos, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 构造一个空集</span></span><br><span class="line">      results_.emplace_back();</span><br><span class="line">      total_ += <span class="number">1</span>;</span><br><span class="line">      <span class="comment">// 第一个放置位置在[1, 1]</span></span><br><span class="line">      <span class="keyword">int</span> row = <span class="number">1</span>, col = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">          <span class="comment">// 从当前行找一个可取位置</span></span><br><span class="line">          <span class="keyword">while</span> (row &lt;= dims_ &amp;&amp; col &lt;= dims_) &#123;</span><br><span class="line">              <span class="comment">// 第row行设置可取位置为col</span></span><br><span class="line">              pos[row] = col;</span><br><span class="line">              total_ += <span class="number">1</span>;</span><br><span class="line">              results_.push_back(generateBoardFromPos(pos, row, nums));</span><br><span class="line">              <span class="comment">// 去下一行找</span></span><br><span class="line">              row += <span class="number">1</span>;</span><br><span class="line">              col += <span class="number">1</span>;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 当所有行都已经有一个可取位置</span></span><br><span class="line">          <span class="keyword">if</span> (row &gt; dims_) &#123;</span><br><span class="line">              row = dims_;  <span class="comment">// 仍然扫描最后一行</span></span><br><span class="line">              <span class="comment">// 下一列</span></span><br><span class="line">              col = pos[row] + <span class="number">1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 当前行已经扫描完了, 需要回到上一行了</span></span><br><span class="line">          <span class="keyword">if</span> (col &gt; dims_) &#123;</span><br><span class="line">              <span class="keyword">if</span> (row == <span class="number">1</span>) &#123;</span><br><span class="line">                  <span class="comment">// 是不是第一行已经考虑完了, 是的话, 总的while循环退出</span></span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="comment">// 把目前这一行放置的可取位置取消</span></span><br><span class="line">                  <span class="comment">// 回溯</span></span><br><span class="line">                  pos[row] = <span class="number">-1</span>;</span><br><span class="line">                  <span class="comment">// 去上一行</span></span><br><span class="line">                  row -= <span class="number">1</span>;</span><br><span class="line">                  <span class="comment">// 上一行的后一个位置</span></span><br><span class="line">                  col = pos[row] + <span class="number">1</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 根据pos数组得出一个board</span></span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; generateBoardFromPos(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;pos, <span class="keyword">int</span> pos_size, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums) &#123;</span><br><span class="line">      <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; board(pos_size, INT_MIN);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">1</span>; row &lt;= pos_size; ++row) &#123;</span><br><span class="line">          <span class="keyword">int</span> x = row - <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">int</span> y = pos[row] - <span class="number">1</span>;</span><br><span class="line">          board[x] = nums[y];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> board;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; results_;</span><br><span class="line">  <span class="keyword">int</span> total_ = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> dims_ = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Solution solution;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; results = solution.solveQuestion(nums);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">" the number of total is: "</span> &lt;&lt; solution.getTotal() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;res : results) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;item : res) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; item &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">/// 求组合</span></span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; solveQuestion(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">      rows_ = k;</span><br><span class="line">      cols_ = nums.size();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 空nums的处理?</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 列位置, 下标从1开始</span></span><br><span class="line">      <span class="comment">// 行列的位置都是[1, ...]</span></span><br><span class="line">      <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pos(rows_ + <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">      iterateSolve(pos, nums);</span><br><span class="line">      <span class="keyword">return</span> results_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getTotal</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> total_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;pos, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 不能出现两个pos[row]一样的情况</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> pre_row = row - <span class="number">1</span>; pre_row &gt;= <span class="number">1</span>; --pre_row) &#123;</span><br><span class="line">          <span class="keyword">if</span> (pos[pre_row] == col) &#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 如果dims_是0, 可能会死循环...</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">iterateSolve</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;pos, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 第一个放置位置在[1, 1]</span></span><br><span class="line">      <span class="keyword">int</span> row = <span class="number">1</span>, col = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">          <span class="comment">// 从当前行找一个可取位置</span></span><br><span class="line">          <span class="comment">// 感觉没必要用while ...</span></span><br><span class="line">          <span class="keyword">while</span> (row &lt;= rows_ &amp;&amp; col &lt;= cols_) &#123;</span><br><span class="line">              <span class="comment">// 第row行设置可取位置为col</span></span><br><span class="line">              pos[row] = col;</span><br><span class="line">              <span class="comment">// 去下一行找</span></span><br><span class="line">              row += <span class="number">1</span>;</span><br><span class="line">              col += <span class="number">1</span>;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 当所有行都已经有一个可取位置</span></span><br><span class="line">          <span class="keyword">if</span> (row &gt; rows_) &#123;</span><br><span class="line">              total_ += <span class="number">1</span>;</span><br><span class="line">              results_.push_back(generateBoardFromPos(pos, nums));</span><br><span class="line">              row = rows_;  <span class="comment">// 仍然扫描最后一行</span></span><br><span class="line">              <span class="comment">// 下一列</span></span><br><span class="line">              col = pos[row] + <span class="number">1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 当前行已经扫描完了, 需要回到上一行了</span></span><br><span class="line">          <span class="keyword">if</span> (col &gt; cols_) &#123;</span><br><span class="line">              <span class="keyword">if</span> (row == <span class="number">1</span>) &#123;</span><br><span class="line">                  <span class="comment">// 是不是第一行已经考虑完了, 是的话, 总的while循环退出</span></span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="comment">// 把目前这一行放置的可取位置取消</span></span><br><span class="line">                  <span class="comment">// 回溯</span></span><br><span class="line">                  pos[row] = <span class="number">-1</span>;</span><br><span class="line">                  <span class="comment">// 去上一行</span></span><br><span class="line">                  row -= <span class="number">1</span>;</span><br><span class="line">                  <span class="comment">// 上一行的后一个位置</span></span><br><span class="line">                  col = pos[row] + <span class="number">1</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 根据pos数组得出一个board</span></span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; generateBoardFromPos(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;pos, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums) &#123;</span><br><span class="line">      <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; board(rows_, INT_MIN);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">1</span>; row &lt;= rows_; ++row) &#123;</span><br><span class="line">          <span class="keyword">int</span> x = row - <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">int</span> y = pos[row] - <span class="number">1</span>;</span><br><span class="line">          board[x] = nums[y];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> board;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; results_;</span><br><span class="line">  <span class="keyword">int</span> total_ = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> rows_ = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> cols_ = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Solution solution;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="comment">// 4选2 组合问题</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; results = solution.solveQuestion(nums, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">" the number of total is: "</span> &lt;&lt; solution.getTotal() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;res : results) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;item : res) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; item &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by mojiajun on 2020/4/18.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; solveQuestion(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums) &#123;</span><br><span class="line">      <span class="keyword">int</span> rows = nums.size();</span><br><span class="line">      dims_ = rows;</span><br><span class="line">      <span class="comment">// 列位置, 下标从1开始</span></span><br><span class="line">      <span class="comment">// 行列的位置都是[1, ...]</span></span><br><span class="line">      <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pos(dims_ + <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">      iterateSolve(pos, nums);</span><br><span class="line">      <span class="keyword">return</span> results_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getTotal</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> total_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;pos, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 不能出现两个pos[row]一样的情况</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> pre_row = row - <span class="number">1</span>; pre_row &gt;= <span class="number">1</span>; --pre_row) &#123;</span><br><span class="line">          <span class="keyword">if</span> (pos[pre_row] == col) &#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">iterateSolve</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;pos, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 第一个放置位置在[1, 1]</span></span><br><span class="line">      <span class="keyword">int</span> row = <span class="number">1</span>, col = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">          <span class="comment">// 从当前行找一个可取位置</span></span><br><span class="line">          <span class="keyword">while</span> (row &lt;= dims_ &amp;&amp; col &lt;= dims_) &#123;</span><br><span class="line">              <span class="keyword">if</span> (isValid(pos, row, col)) &#123;</span><br><span class="line">                  <span class="comment">// 第row行设置可取位置为col</span></span><br><span class="line">                  pos[row] = col;</span><br><span class="line">                  <span class="comment">// 去下一行找</span></span><br><span class="line">                  row += <span class="number">1</span>;</span><br><span class="line">                  <span class="comment">// 列的位置重置为1</span></span><br><span class="line">                  col = <span class="number">1</span>;</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              ++col;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 当所有行都已经有一个可取位置</span></span><br><span class="line">          <span class="keyword">if</span> (row &gt; dims_) &#123;</span><br><span class="line">              total_ += <span class="number">1</span>;</span><br><span class="line">              results_.push_back(generateBoardFromPos(pos, nums));</span><br><span class="line">              row = dims_;  <span class="comment">// 仍然扫描最后一行</span></span><br><span class="line">              <span class="comment">// 下一列</span></span><br><span class="line">              col = pos[row] + <span class="number">1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 当前行已经扫描完了, 需要回到上一行了</span></span><br><span class="line">          <span class="keyword">if</span> (col &gt; dims_) &#123;</span><br><span class="line">              <span class="keyword">if</span> (row == <span class="number">1</span>) &#123;</span><br><span class="line">                  <span class="comment">// 是不是第一行已经考虑完了, 是的话, 总的while循环退出</span></span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="comment">// 把目前这一行放置的可取位置取消</span></span><br><span class="line">                  <span class="comment">// 回溯</span></span><br><span class="line">                  pos[row] = <span class="number">-1</span>;</span><br><span class="line">                  <span class="comment">// 去上一行</span></span><br><span class="line">                  row -= <span class="number">1</span>;</span><br><span class="line">                  <span class="comment">// 上一行的后一个位置</span></span><br><span class="line">                  col = pos[row] + <span class="number">1</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 根据pos数组得出一个board</span></span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; generateBoardFromPos(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;pos, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums) &#123;</span><br><span class="line">      <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; board(dims_, INT_MIN);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">1</span>; row &lt;= dims_; ++row) &#123;</span><br><span class="line">          <span class="keyword">int</span> x = row - <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">int</span> y = pos[row] - <span class="number">1</span>;</span><br><span class="line">          board[x] = nums[y];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> board;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; results_;</span><br><span class="line">  <span class="keyword">int</span> total_ = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> dims_ = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Solution solution;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; results = solution.solveQuestion(nums);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">" the number of total is: "</span> &lt;&lt; solution.getTotal() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;res : results) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;item : res) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; item &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://mojiajun.github.io/post/4d990729.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mojiajun">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mojiajun">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/post/4d990729.html" itemprop="url">Rust-移动结构体内部元素的思考</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-02-14T00:00:00+08:00">
                2020-02-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Rust/" itemprop="url" rel="index">
                    <span itemprop="name">Rust</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在学习用Rust写链表的时候思考的一个问题.ch3.2 generic那里</p>
<p><a href="https://rust-unofficial.github.io/too-many-lists/second-generic.html" target="_blank" rel="noopener">https://rust-unofficial.github.io/too-many-lists/second-generic.html</a></p>
<p>即在ch3.2 generic的基础上给Node结构体添加一个</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; <span class="built_in">Drop</span> <span class="keyword">for</span> Node&lt;T&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">drop</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Node&lt;T&gt; end here"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么会出问题?</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">pop</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">Option</span>&lt;T&gt; &#123;</span><br><span class="line">        <span class="comment">// map返回一个Option&lt;U&gt;, 是传入的closure的返回值</span></span><br><span class="line">        <span class="comment">// 把self 传值的方式传入map.</span></span><br><span class="line">        <span class="comment">// 然后函数只需返回node.elem即可.Some这个tag外壳是map返回的时候披上去的</span></span><br><span class="line">        <span class="keyword">self</span>.head.take().map(|box_node| &#123;</span><br><span class="line">            <span class="keyword">self</span>.head = box_node.next;</span><br><span class="line">            box_node.elem</span><br><span class="line">        &#125;)  <span class="comment">// box_node按理说在这里销毁吧, 闭包结束的位置</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>原因在这里.map传入的那个closure拿到node的所有权之后.box_node在哪销毁?闭包结束的位置.但是在闭包里面可能会产生移动内部的元素.让内部元素进入undefine behaviour.但是结构体的内存并没有随着内部元素的移动而释放.(只是那些fields发生了改变.)</p>
<p>box_node销毁的时候.先调用Box的销毁过程.相当于C++的~unique_ptr.然后相当于C++的 delete pointer_to_heap..这个操作做两件事.1.先执行Node的drop.2.释放Node的内存.</p>
<p>所以如果Node没有定义drop方法.那么就没事.因为它只释放内存.没有调用drop.调用drop函数的时候(在这个函数内部,必须保证此时的Node里面的状态时well-define的,不止是内存不能释放掉.而且状态也要well-define).</p>
<h3 id="用一个例子详细探索一下"><a href="#用一个例子详细探索一下" class="headerlink" title="用一个例子详细探索一下:"></a>用一个例子详细探索一下:</h3><p>可以对各种情形都试试</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span> &#123;</span><br><span class="line">    elem: B,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//impl Drop for A &#123;</span></span><br><span class="line"><span class="comment">//    fn drop(&amp;mut self) &#123;</span></span><br><span class="line"><span class="comment">//        println!("drop() function in A");</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span></span> &#123;</span><br><span class="line">    el_b: <span class="built_in">i32</span>,</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//impl Clone for B &#123;</span></span><br><span class="line"><span class="comment">//    fn clone(&amp;self) -&gt; Self &#123;</span></span><br><span class="line"><span class="comment">//        B &#123; el_b: self.el_b &#125;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//impl Copy for B &#123;&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">impl</span> <span class="built_in">Drop</span> <span class="keyword">for</span> B &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">drop</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"drop() function in B"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> a = A &#123; elem: B &#123; el_b: <span class="number">100</span> &#125; &#125;;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// = 可能做了copy或者move</span></span><br><span class="line">        <span class="comment">// 考虑let a_elem = a.elem</span></span><br><span class="line">        <span class="comment">// 1. 如果是copy.那么A有没有drop都没事</span></span><br><span class="line">        <span class="comment">// 2. 如果是move.那么A不能定义drop.(原因猜测. A的销毁分成两步.先调用drop.再销毁内存)</span></span><br><span class="line">        <span class="comment">// 把A里面的元素移走并没有销毁A的内存吧.想象一下B是Box.就八字节.移动的本质是什么思考一下?</span></span><br><span class="line">        <span class="comment">// 但是A的drop运行的时候必须保证A是完整有效的. A的内存虽然都在, 但是里面的元素可能已经不保证有效</span></span><br><span class="line">        <span class="keyword">let</span> a_elem = a.elem;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"main() end here"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果是let a_elem = a.elem是move.那么A不能定义drop.但是还是能运行的.但是会让a进入里面的元素不保证有效的状态了…</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://mojiajun.github.io/post/436c1fd4.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mojiajun">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mojiajun">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/post/436c1fd4.html" itemprop="url">Rust-对象销毁过程中的栈溢出问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-02-13T00:00:00+08:00">
                2020-02-13
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Rust/" itemprop="url" rel="index">
                    <span itemprop="name">Rust</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>问题来源:<a href="http://rust-unofficial.github.io/too-many-lists/first-drop.html" target="_blank" rel="noopener">http://rust-unofficial.github.io/too-many-lists/first-drop.html</a></p>
<p>代码:</p>
<p>注意对象销毁类似C++.也有两个过程1.执行Drop().类似析构函数2.释放内存</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::mem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">List</span></span> &#123;</span><br><span class="line">    head: Link,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Link</span></span> &#123;</span><br><span class="line">    Empty,</span><br><span class="line">    More(<span class="built_in">Box</span>&lt;Node&gt;),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span> &#123;</span><br><span class="line">    elem: <span class="built_in">i32</span>,</span><br><span class="line">    next: Link,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="built_in">Drop</span> <span class="keyword">for</span> Node &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">drop</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"drop() function &#123;&#125;"</span>, <span class="keyword">self</span>.elem);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> List &#123;</span><br><span class="line">    <span class="comment">/// 创建一个List. head为空链接, 即创建一个空链表</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>() -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        List &#123; head: Link::Empty &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">push</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, elem: <span class="built_in">i32</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> new_node = <span class="built_in">Box</span>::new(Node &#123;</span><br><span class="line">            elem: elem,</span><br><span class="line">            next: mem::replace(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>.head, Link::Empty),</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 修改stack的top</span></span><br><span class="line">        <span class="comment">// new_node 加上More tag后移动给self.head</span></span><br><span class="line">        <span class="keyword">self</span>.head = Link::More(new_node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传入的是List的可变引用&amp;mut List</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">pop</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">Option</span>&lt;<span class="built_in">i32</span>&gt; &#123;</span><br><span class="line">        <span class="comment">// self.head是Link.现在把Link里面存的variant替换成Link::empty.然后返回原先的variant.</span></span><br><span class="line">        <span class="comment">// 改变了List的状态.但是并没有移走它的状态.放了另外一个状态在self.head里面</span></span><br><span class="line">        <span class="comment">// 然后对返回的那个Link::* variant 这个值进行 match</span></span><br><span class="line">        <span class="keyword">match</span> mem::replace(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>.head, Link::Empty) &#123;</span><br><span class="line">            <span class="comment">// 解开Link这个enum的Tag</span></span><br><span class="line">            Link::Empty =&gt; &#123; <span class="literal">None</span> &#125;</span><br><span class="line">            <span class="comment">// 如果这个variant是More(*), 那么解开More这个tag后'*'会被移动给node</span></span><br><span class="line">            Link::More(<span class="keyword">mut</span> node) =&gt; &#123;</span><br><span class="line">                <span class="comment">// 把node.next这个Link移动给self.head.</span></span><br><span class="line">                <span class="comment">// 这里因为Node有Drop Trait.所以是moveable类型. </span></span><br><span class="line">                <span class="comment">// 如果用self.head = node.next 那么Node里面的部分元素就被移动走了. 然后Node就成了一个部分有效部分无效的数据, 所以不行</span></span><br><span class="line">                <span class="keyword">self</span>.head = mem::replace(&amp;<span class="keyword">mut</span> node.next, Link::Empty);</span><br><span class="line">                <span class="literal">Some</span>(node.elem)</span><br><span class="line">            &#125; <span class="comment">// node在这里死掉吧.?</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> list = List::new();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(list.pop(), <span class="literal">None</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> <span class="number">1</span>..<span class="number">100000000</span> &#123;</span><br><span class="line">        list.push(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"main function end here"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main function end here</span><br><span class="line"><span class="built_in">drop</span>() function <span class="number">99999999</span></span><br><span class="line"><span class="built_in">drop</span>() function <span class="number">99999998</span></span><br><span class="line"><span class="built_in">drop</span>() function <span class="number">99999997</span></span><br><span class="line"><span class="built_in">drop</span>() function <span class="number">99999996</span></span><br><span class="line"><span class="built_in">drop</span>() function <span class="number">99999995</span></span><br><span class="line"><span class="built_in">drop</span>() function <span class="number">99999994</span></span><br><span class="line"><span class="built_in">drop</span>() function <span class="number">99999993</span></span><br><span class="line"><span class="built_in">drop</span>() function <span class="number">99999992</span></span><br><span class="line"><span class="built_in">drop</span>() function <span class="number">99999991</span></span><br><span class="line"><span class="built_in">drop</span>() function <span class="number">99999990</span></span><br><span class="line"><span class="built_in">drop</span>() function <span class="number">99999989</span></span><br><span class="line"><span class="built_in">drop</span>() function <span class="number">99999988</span></span><br><span class="line"><span class="built_in">drop</span>() function <span class="number">99999987</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>链表头是99999999这个元素.</p>
<p>其中为什么不用self.head = node.next</p>
<blockquote>
<p>Here, we tried to move a field out of a struct of type <code>DropStruct</code> which implements the <code>Drop</code> trait. However, a struct cannot be dropped if one or more of its fields have been moved.<a href="https://doc.rust-lang.org/error-index.html#E0509" target="_blank" rel="noopener">https://doc.rust-lang.org/error-index.html#E0509</a></p>
</blockquote>
<p>或者把Node的Drop去掉.然后就可以用self.head = node.next了.</p>
<p>下面这段C++代码也是同样的道理,意味着如果像rust里那么写,栈非常深的话,应该也会stackoverflow.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  Bar(<span class="keyword">int</span> id) :</span><br><span class="line">      id_(id) &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  ~Bar() &#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"~Bar() "</span> &lt;&lt; <span class="string">"id "</span> &lt;&lt; id_ &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> id_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  Foo(<span class="keyword">int</span> id) :</span><br><span class="line">      id_(id) &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~Foo() &#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"~Foo() "</span> &lt;&lt; <span class="string">"id "</span> &lt;&lt; id_ &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> id_;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Bar&gt; next_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> obj_01 = <span class="built_in">std</span>::make_unique&lt;Foo&gt;(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">auto</span> obj_02 = <span class="built_in">std</span>::make_unique&lt;Bar&gt;(<span class="number">2</span>);</span><br><span class="line">    obj_01-&gt;next_ = <span class="built_in">std</span>::move(obj_02);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"main end"</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那段Rust代码按照文章里提的写成迭代写法就好了…</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::mem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">List</span></span> &#123;</span><br><span class="line">    head: Link,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Link</span></span> &#123;</span><br><span class="line">    Empty,</span><br><span class="line">    More(<span class="built_in">Box</span>&lt;Node&gt;),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span> &#123;</span><br><span class="line">    elem: <span class="built_in">i32</span>,</span><br><span class="line">    next: Link,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> List &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>() -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        List &#123; head: Link::Empty &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">push</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, elem: <span class="built_in">i32</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> new_node = <span class="built_in">Box</span>::new(Node &#123;</span><br><span class="line">            elem: elem,</span><br><span class="line">            next: mem::replace(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>.head, Link::Empty),</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.head = Link::More(new_node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">pop</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">Option</span>&lt;<span class="built_in">i32</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">match</span> mem::replace(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>.head, Link::Empty) &#123;</span><br><span class="line">            Link::Empty =&gt; <span class="literal">None</span>,</span><br><span class="line">            Link::More(node) =&gt; &#123;</span><br><span class="line">                <span class="keyword">self</span>.head = node.next;</span><br><span class="line">                <span class="literal">Some</span>(node.elem)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="built_in">Drop</span> <span class="keyword">for</span> List &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">drop</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> cur_link = mem::replace(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>.head, Link::Empty);</span><br><span class="line">				</span><br><span class="line">        <span class="comment">// boxed_node是Box&lt;Node&gt;类型</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">let</span> Link::More(<span class="keyword">mut</span> boxed_node) = cur_link &#123;</span><br><span class="line">            cur_link = mem::replace(&amp;<span class="keyword">mut</span> boxed_node.next, Link::Empty);</span><br><span class="line">        &#125;  <span class="comment">// boxed_node这个Box死掉, 执行Node的Drop + 释放Node内存</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> list = List::new();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(list.pop(), <span class="literal">None</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> <span class="number">1</span>..<span class="number">100000000</span> &#123;</span><br><span class="line">        list.push(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"main function end here"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者这样</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::mem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">List</span></span> &#123;</span><br><span class="line">    head: Link,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Link</span></span> &#123;</span><br><span class="line">    Empty,</span><br><span class="line">    More(<span class="built_in">Box</span>&lt;Node&gt;),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span> &#123;</span><br><span class="line">    elem: <span class="built_in">i32</span>,</span><br><span class="line">    next: Link,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="built_in">Drop</span> <span class="keyword">for</span> Node &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">drop</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"drop() function &#123;&#125;"</span>, <span class="keyword">self</span>.elem);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> List &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>() -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        List &#123; head: Link::Empty &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">push</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, elem: <span class="built_in">i32</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> new_node = <span class="built_in">Box</span>::new(Node &#123;</span><br><span class="line">            elem: elem,</span><br><span class="line">            next: mem::replace(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>.head, Link::Empty),</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.head = Link::More(new_node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">pop</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">Option</span>&lt;<span class="built_in">i32</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">match</span> mem::replace(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>.head, Link::Empty) &#123;</span><br><span class="line">            Link::Empty =&gt; <span class="literal">None</span>,</span><br><span class="line">            Link::More(<span class="keyword">mut</span> node) =&gt; &#123;</span><br><span class="line">                <span class="keyword">self</span>.head = mem::replace(&amp;<span class="keyword">mut</span> node.next, Link::Empty);</span><br><span class="line">                <span class="literal">Some</span>(node.elem)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="built_in">Drop</span> <span class="keyword">for</span> List &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">drop</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> cur_link = mem::replace(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>.head, Link::Empty);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">let</span> Link::More(<span class="keyword">mut</span> boxed_node) = cur_link &#123;</span><br><span class="line">            cur_link = mem::replace(&amp;<span class="keyword">mut</span> boxed_node.next, Link::Empty);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> list = List::new();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(list.pop(), <span class="literal">None</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> <span class="number">1</span>..<span class="number">100000000</span> &#123;</span><br><span class="line">        list.push(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"main function end here"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其他:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//Bar *bar = new Bar(1);</span></span><br><span class="line">    <span class="comment">//delete bar;</span></span><br><span class="line">C++里面<span class="keyword">delete</span> bar干了两件事<span class="number">1.</span>执行~Bar()<span class="number">2.</span>释放内存</span><br></pre></td></tr></table></figure>
<p>只不过用Box或者std::unique_ptr.这个delete的动作不用程序员手写出来来.用RAII方法管理.但是本质还是会执行两个步骤,在Rust里就是1.释放内存前先执行Box<node>管理的那个struct的Drop().然后释放掉Box管理的内存.</node></p>
<p>编译器在清理Box<node>这种递归结构的时候,分成2部分,类似C++(这个Drop就等价于C++的析构函数…).会先去执行链表头元素的Drop().然后释放这个Box拥有的内存.在这两个步骤之间,要想释放掉内存,必须把每个子结构的Drop()+释放内存两个操作都完成了.才能释放父结构的内存.所以元素一多起来,就能很明显的看到调用栈的深度…然后stackoverflow.</node></p>
<p>代码怎么从Box的Drop跑到Node的Drop的???类似于C++里从std::unique_ptr::~unique_ptr()运行调用delete __ptr.</p>
<p>在macOS上用lldb + br s -n …各种Debug方法看汇编看出来.</p>
<p>和<a href="http://rust-unofficial.github.io/too-many-lists/first-drop.htmls不同的一点.Node有Drop方法.." target="_blank" rel="noopener">http://rust-unofficial.github.io/too-many-lists/first-drop.htmls不同的一点.Node有Drop方法..</a>.</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://mojiajun.github.io/post/50924fad.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mojiajun">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mojiajun">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/post/50924fad.html" itemprop="url">二叉搜索和lower_bound#upper_bound</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-01-28T00:00:00+08:00">
                2020-01-28
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法与数据结构/" itemprop="url" rel="index">
                    <span itemprop="name">算法与数据结构</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法与数据结构/Leetcode/" itemprop="url" rel="index">
                    <span itemprop="name">Leetcode</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="std-lower-bound-std-upper-bound使用"><a href="#std-lower-bound-std-upper-bound使用" class="headerlink" title="std::lower_bound,std::upper_bound使用"></a>std::lower_bound,std::upper_bound使用</h3><p>结合cppreference看</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::lower_bound(nums.begin(), nums.end(), target) </span><br><span class="line">&gt;= target的第一个元素</span><br></pre></td></tr></table></figure>
<p>The range [first, last) must be partitioned with respect to the expression element &lt; value or comp(element, value), i.e., all elements for which the expression is true must precede all elements for which the expression is false. A fully-sorted range meets this criterion.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::upper_bound(nums.begin(), nums.end(), target)</span><br><span class="line">&gt; target的第一个元素</span><br></pre></td></tr></table></figure>
<p>The range [first, last) must be partitioned with respect to the expression !(value &lt; element) or !comp(value, element), i.e., all elements for which the expression is true must precede all elements for which the expression is false. A fully-sorted range meets this criterion.</p>
<p>std::lower_bound</p>
<p>前面一部分的元素都 &lt; value .后面的都&gt;=value<br><strong>从后面这部分拿到第一个元素</strong></p>
<p>std::upper_bound</p>
<p>前面一部分的元素都 &lt;= value .后面的都&gt;value<br>从后面这部分拿到第一个元素</p>
<p>也就是不一定非要是fully-sorted???比如</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data&#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> lower = <span class="built_in">std</span>::lower_bound(data.begin(), data.end(), <span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<p>?</p>
<p>从cppreference看可能的实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIt</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">ForwardIt</span> <span class="title">lower_bound</span>(<span class="title">ForwardIt</span> <span class="title">first</span>, <span class="title">ForwardIt</span> <span class="title">last</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">value</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ForwardIt it;</span><br><span class="line">    <span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;ForwardIt&gt;::difference_type count, step;</span><br><span class="line">    count = <span class="built_in">std</span>::distance(first, last);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        it = first; </span><br><span class="line">        step = count / <span class="number">2</span>; </span><br><span class="line">        <span class="built_in">std</span>::advance(it, step);</span><br><span class="line">        <span class="keyword">if</span> (*it &lt; value) &#123;</span><br><span class="line">            first = ++it; </span><br><span class="line">            count -= step + <span class="number">1</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            count = step;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出,<strong>确实不一定必须是fully-sorted的…</strong>因为在去掉一部分的时候根据[前面一部分的元素都 &lt;= value .后面的都&gt;value]这个条件即可去掉不相关部分…!!!不一定非得是全排序的…</p>
<p>因为只要满足前面一部分的元素都 &lt; value .后面的都&gt;=value,就能用二分查找的方法找到第一个&gt;=value的元素.</p>
<p>界定范围用first和count</p>
<h3 id="在mac上llvm-libc-里面的实现"><a href="#在mac上llvm-libc-里面的实现" class="headerlink" title="在mac上llvm-libc++里面的实现"></a>在mac上llvm-libc++里面的实现</h3><p>c++/v1/algorithm</p>
<p>可读性比较差,结合cppreference里的可能实现看</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Compare</span>, <span class="title">class</span> _<span class="title">ForwardIterator</span>, <span class="title">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">LIBCPP_CONSTEXPR_AFTER_CXX17</span> _<span class="title">ForwardIterator</span></span></span><br><span class="line"><span class="class">__<span class="title">lower_bound</span>(_<span class="title">ForwardIterator</span> __<span class="title">first</span>, _<span class="title">ForwardIterator</span> __<span class="title">last</span>, <span class="title">const</span> _<span class="title">Tp</span>&amp; __<span class="title">value_</span>, _<span class="title">Compare</span> __<span class="title">comp</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;_ForwardIterator&gt;::difference_type difference_type;</span><br><span class="line">    difference_type __len = _VSTD::distance(__first, __last);</span><br><span class="line">    <span class="keyword">while</span> (__len != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        difference_type __l2 = _VSTD::__half_positive(__len);</span><br><span class="line">        _ForwardIterator __m = __first;</span><br><span class="line">        _VSTD::advance(__m, __l2);</span><br><span class="line">        <span class="keyword">if</span> (__comp(*__m, __value_))</span><br><span class="line">        &#123;</span><br><span class="line">            __first = ++__m;</span><br><span class="line">            __len -= __l2 + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            __len = __l2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> __first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Compare</span>, <span class="title">class</span> _<span class="title">ForwardIterator</span>, <span class="title">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">LIBCPP_CONSTEXPR_AFTER_CXX17</span> _<span class="title">ForwardIterator</span></span></span><br><span class="line"><span class="class">__<span class="title">upper_bound</span>(_<span class="title">ForwardIterator</span> __<span class="title">first</span>, _<span class="title">ForwardIterator</span> __<span class="title">last</span>, <span class="title">const</span> _<span class="title">Tp</span>&amp; __<span class="title">value_</span>, _<span class="title">Compare</span> __<span class="title">comp</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;_ForwardIterator&gt;::difference_type difference_type;</span><br><span class="line">    difference_type __len = _VSTD::distance(__first, __last);</span><br><span class="line">    <span class="keyword">while</span> (__len != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        difference_type __l2 = _VSTD::__half_positive(__len);</span><br><span class="line">        _ForwardIterator __m = __first;</span><br><span class="line">        _VSTD::advance(__m, __l2);</span><br><span class="line">        <span class="keyword">if</span> (__comp(__value_, *__m))</span><br><span class="line">            __len = __l2;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            __first = ++__m;</span><br><span class="line">            __len -= __l2 + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> __first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode相关题-如果不直接调用lower-bound-upper-bound-却要用的话"><a href="#Leetcode相关题-如果不直接调用lower-bound-upper-bound-却要用的话" class="headerlink" title="Leetcode相关题(如果不直接调用lower_bound,upper_bound,却要用的话)"></a>Leetcode相关题(如果不直接调用lower_bound,upper_bound,却要用的话)</h3><p>其实就是自己实现lower_bound,upper_bound.</p>
<p>主要看34题</p>
<p>可以直接用lower_bound,upper_bound</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; searchRange(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res(<span class="number">2</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">int</span> nums_size = nums.size();</span><br><span class="line">        <span class="keyword">if</span> (nums_size == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> count = nums_size, step, mid;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            step = count / <span class="number">2</span>;</span><br><span class="line">            mid = left + step;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">                count -= step + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                count = step;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// nums里面不存在target</span></span><br><span class="line">        <span class="keyword">if</span> (left == nums_size || nums[left] != target) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res[<span class="number">0</span>] = left;</span><br><span class="line">        &#125;</span><br><span class="line">        left = <span class="number">0</span>;</span><br><span class="line">        count = nums_size;</span><br><span class="line">        <span class="keyword">while</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            step = count / <span class="number">2</span>;</span><br><span class="line">            mid = left + step;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt;= target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">                count -= step + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                count = step;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res[<span class="number">1</span>] = left - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>翻译成left,right那种写法…(这种二叉搜索的变种记下来)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; searchRange(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res(<span class="number">2</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">int</span> nums_size = nums.size();</span><br><span class="line">        <span class="keyword">if</span> (nums_size == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> count, step, mid;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums_size;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            count = right - left;</span><br><span class="line">            step = count / <span class="number">2</span>;</span><br><span class="line">            mid = left + step;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// nums里面不存在target</span></span><br><span class="line">        <span class="keyword">if</span> (left == nums_size || nums[left] != target) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res[<span class="number">0</span>] = left;</span><br><span class="line">        &#125;</span><br><span class="line">        left = <span class="number">0</span>, right = nums_size;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            count = right - left;</span><br><span class="line">            step = count / <span class="number">2</span>;</span><br><span class="line">            mid = left + step;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt;= target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res[<span class="number">1</span>] = left - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>注意:</p>
<p>1.right = nums_size.</p>
<p>2.这种解法(对一类通用问题可以用!!!即lower_bound和upper_bound可以用的地方)</p>
<p>可以不用count,step变量</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; searchRange(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; results(<span class="number">2</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">int</span> nums_size = nums.size();</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums_size;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 能处理nums_size == 0的情况</span></span><br><span class="line">        <span class="comment">// 如果没找到.(left可能在尾后位置, 2.在中间)</span></span><br><span class="line">        <span class="keyword">if</span> (left == nums_size || nums[left] != target) &#123;</span><br><span class="line">            <span class="keyword">return</span> results;</span><br><span class="line">        &#125;</span><br><span class="line">        results[<span class="number">0</span>] = left;</span><br><span class="line">        left = <span class="number">0</span>, right = nums_size;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt;= target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        results[<span class="number">1</span>] = left - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> results;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Leetcode35的一个小优化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// left 可以不用再次初始化</span></span><br><span class="line">right = nums_size;</span><br></pre></td></tr></table></figure>
<p>这种模式是二叉搜索的通用模式.就是std::lower_bound和std::upper_bound背后的实现逻辑</p>
<p>只要是可以用std::lower_bound和std::upper_bound的地方,就可以在做题的时候手写替代…</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://mojiajun.github.io/post/55197121.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mojiajun">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mojiajun">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/post/55197121.html" itemprop="url">Quicksort实现</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-01-12T00:00:00+08:00">
                2020-01-12
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法与数据结构/" itemprop="url" rel="index">
                    <span itemprop="name">算法与数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>递归实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// nums[l, h], 两边都是闭区间</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> l, <span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot = nums[h];  <span class="comment">// 选最右侧做为pivot</span></span><br><span class="line">    <span class="keyword">int</span> i = l - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = l; j &lt;= h - <span class="number">1</span>; ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[j] &lt;= pivot) &#123;</span><br><span class="line">            i = i + <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">std</span>::swap(nums[i], nums[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::swap(nums[i + <span class="number">1</span>], nums[h]);</span><br><span class="line">    <span class="keyword">return</span> i + <span class="number">1</span>;  <span class="comment">// 返回pivot位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> l, <span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt; h) &#123;</span><br><span class="line">        <span class="keyword">int</span> pivot_idx = partition(nums, l, h);</span><br><span class="line">        quicksort(nums, l, pivot_idx - <span class="number">1</span>);</span><br><span class="line">        quicksort(nums, pivot_idx + <span class="number">1</span>, h);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers_01 = &#123;<span class="number">2</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    quicksort(numbers_01, <span class="number">0</span>, numbers_01.size() - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;item : numbers_01) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; item &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>快速排序非递归实现,用栈的替换递归</p>
<p>可以在里面加assert(l&lt;h)这种断言,保证precondition一定满足</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// nums[l, h], 两边都是闭区间</span></span><br><span class="line"><span class="comment">// l 得&lt;= h吧</span></span><br><span class="line"><span class="comment">// 一个元素送进去也可以. 可以在前面优化一下, 直接返回结果?</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> l, <span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot = nums[h];  <span class="comment">// 选最右侧做为pivot</span></span><br><span class="line">    <span class="keyword">int</span> i = l - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = l; j &lt;= h - <span class="number">1</span>; ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[j] &lt;= pivot) &#123;</span><br><span class="line">            i = i + <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">std</span>::swap(nums[i], nums[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::swap(nums[i + <span class="number">1</span>], nums[h]);</span><br><span class="line">    <span class="keyword">return</span> i + <span class="number">1</span>;  <span class="comment">// 返回pivot位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在这里, 每次调用partition送进去的l,h都是[l,h]闭区间</span></span><br><span class="line"><span class="comment">// 而且l &lt; h</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicksort_iterative</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> l, <span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= h) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">    <span class="comment">// l &lt; h</span></span><br><span class="line">    stk.push(l);</span><br><span class="line">    stk.push(h);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!stk.empty()) &#123;</span><br><span class="line">        h = stk.top();</span><br><span class="line">        stk.pop();</span><br><span class="line"></span><br><span class="line">        l = stk.top();</span><br><span class="line">        stk.pop();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> pivot_idx = partition(nums, l, h);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pivot_idx - <span class="number">1</span> &gt; l) &#123;  <span class="comment">// pivot左边至少还有2个元素</span></span><br><span class="line">            stk.push(l);</span><br><span class="line">            stk.push(pivot_idx - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pivot_idx + <span class="number">1</span> &lt; h) &#123;</span><br><span class="line">            stk.push(pivot_idx + <span class="number">1</span>);</span><br><span class="line">            stk.push(h);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers_01 = &#123;<span class="number">2</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    quicksort_iterative(numbers_01, <span class="number">0</span>, numbers_01.size() - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;item : numbers_01) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; item &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参考</p>
<p>1.CLRS</p>
<p>2.<a href="https://www.geeksforgeeks.org/iterative-quick-sort/amp/" target="_blank" rel="noopener">Iterative Quick Sort</a></p>
<p>其他:</p>
<p>1.随机化.参考算法导论</p>
<p>2.选主元问题</p>
<p>3.反序排,把&lt;=改成&gt;= </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://mojiajun.github.io/post/cebf9216.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mojiajun">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mojiajun">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/post/cebf9216.html" itemprop="url">C++11-条件变量</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-01-10T00:00:00+08:00">
                2020-01-10
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/多线程/" itemprop="url" rel="index">
                    <span itemprop="name">多线程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="std-condition-variable"><a href="#std-condition-variable" class="headerlink" title="std::condition_variable"></a>std::condition_variable</h1><p>头文件&lt;condition_variable&gt;</p>
<p>注意有两个版本的std::condition_variable::wait().</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait</span><span class="params">( <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt;&amp; lock )</span></span>;  (<span class="number">1</span>)	(since C++<span class="number">11</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Predicate</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">wait</span>( <span class="title">std</span>:</span>:unique_lock&lt;<span class="built_in">std</span>::mutex&gt;&amp; lock, Predicate pred );  (<span class="number">2</span>)	(since C++<span class="number">11</span>)</span><br></pre></td></tr></table></figure>
<p>一个基本例子:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参考Effective Modern C++ Item 39的例子</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这些在实际使用过程放在一个类里吧?</span></span><br><span class="line"><span class="built_in">std</span>::condition_variable cv_;</span><br><span class="line"><span class="built_in">std</span>::mutex m_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> flag = <span class="literal">false</span>;  <span class="comment">// 共享状态变量的修改受std::mutex的保护,在这里不需要是std::atomic</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 模拟计算任务消耗2秒</span></span><br><span class="line">    <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RAII技法加锁并解锁对共享变量修改区.即critical section</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lg(m_);</span><br><span class="line"></span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"set flag = true"</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;  <span class="comment">// lg解锁m_,析构函数中</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这个位置没有持有std::mutex</span></span><br><span class="line">    <span class="comment">// 想调用notify必须是没有持有锁的状态!!!否则wait没有锁可以拿</span></span><br><span class="line">    <span class="comment">// 重点是思考的时候注意拿锁和解锁一定要刚好一对!!!</span></span><br><span class="line">    cv_.notify_one();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">waits</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 某些任务.</span></span><br><span class="line"></span><br><span class="line">    &#123;  <span class="comment">// critical section</span></span><br><span class="line">        <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lk(m_);  <span class="comment">// lk加锁</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// waits() 执行到这里必须等待signals某些计算任务完成, 然后满足[] &#123; return flag; &#125; 这里面的条件得以满足了, 才能结束等待</span></span><br><span class="line">        cv_.wait(lk, [] &#123; <span class="keyword">return</span> flag; &#125;);</span><br><span class="line">        <span class="comment">// 等待完成之后wait()继续执行</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"wait() finish"</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;  <span class="comment">// lk解锁m_(析构函数中)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待另外一个线程计算完成之后的其他任务</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::thread t1(waits), t2(signals);</span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv_.wait(lk, [] &#123; <span class="built_in">return</span> flag; &#125;);这个带第二个参数的重载版本的cv_.wait()能解决两个问题.</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">它等价于</span><br><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">Predicate</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">condition_variable</span>:</span>:wait(unique_lock&lt;mutex&gt;&amp; lock, Predicate pred)</span><br><span class="line">	<span class="keyword">while</span> (!pred()) &#123;</span><br><span class="line">    wait(lock);  <span class="comment">// 这个是原始版本的wait()函数,只有一个参数</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两个问题:</p>
<p>1.唤醒丢失</p>
<blockquote>
<p>如果cv_.notify_one()已经执行了.但是cv_wait()在另外一个线程还没有执行,也没有关系.因为在执行cv_.wait(lk, [] { return flag; });的时候,首先就是检查函数体{…}返回的是不是true.如果是false.说明没有满足条件.那么才调用(1)第一个版本的wait().这个执行(unlock+block)两个操作(原子化的.不可分割.)…<br>但是如果是面对唤醒丢失情况.那么在检查{..}函数体的时候.发现条件true.那么while循环不进入循环,也就没执行第一个版本的wait().从而也就没block.然后cv_.wait(lk, [] { return flag; });返回.执行接下来的语句</p>
</blockquote>
<p>void wait( std::unique_lock<a href="std::mutex" target="_blank" rel="noopener">std::mutex</a>&amp; lock );  (1)    (since C++11)<br>在阻塞的时候被notify()之后,然后如果被选中了.那么它解除阻塞,拿到cpu时间片.然后拿锁.然后执行接下来的语句.</p>
<p>但是<br>template<class predicate><br>void wait( std::unique_lock<a href="std::mutex" target="_blank" rel="noopener">std::mutex</a>&amp; lock, Predicate pred );  (2)    (since C++11)只是版本(1)的一个简单封装.它可能对[(解锁,block)+(unblock,加锁)]这套流程执行次数是0次.(比如在唤醒丢失情况).</class></p>
<p>2.虚假唤醒.</p>
<p>这个也就是为什么要用while(!pred()){ wait(lock)}包装(1)版本的wait的原因.条件不满足继续Wait()就行了.等下次的notify.这个虚假唤醒可以参考下面这个例子.[来自cppreference的std::condition_variable::notify_one]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::condition_variable cv;</span><br><span class="line"><span class="built_in">std</span>::mutex cv_m;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> done = <span class="literal">false</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">waits</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lk(cv_m);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Waiting... \n"</span>;</span><br><span class="line">    cv.wait(lk, []&#123;<span class="keyword">return</span> i == <span class="number">1</span>;&#125;);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"...finished waiting. i == 1\n"</span>;</span><br><span class="line">    done = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signals</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">1</span>));</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Notifying falsely...\n"</span>;</span><br><span class="line">    cv.notify_one(); <span class="comment">// waiting thread is notified with i == 0.</span></span><br><span class="line">                     <span class="comment">// cv.wait wakes up, checks i, and goes back to waiting</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lk(cv_m);</span><br><span class="line">    i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!done) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Notifying true change...\n"</span>;</span><br><span class="line">        lk.unlock();</span><br><span class="line">        cv.notify_one(); <span class="comment">// waiting thread is notified with i == 1, cv.wait returns</span></span><br><span class="line">        <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">1</span>));</span><br><span class="line">        lk.lock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::thread t1(waits), t2(signals);</span><br><span class="line">    t1.join(); </span><br><span class="line">    t2.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其他:</p>
<p>1.std::condition_variable得配合std::mutex使用,但是不是直接对它解锁解锁.用的是std::unique_lock来辅助加锁解锁(用RAII).</p>
<p>2.为什么在第一个例子里面的notify那个线程用std::lock_guard<a href="std::mutex" target="_blank" rel="noopener">std::mutex</a> lg(m_);其实用std::unique_lock也可以.它们区别在哪呢.翻看它们的API文档,std::unique_lock有lock(),unlock()等操作底下的std::mutex的接口函数.而std::lock_guard仅仅只能在构造的时候拿到锁,析构的时候释放锁.中间过程不能解锁再拿锁.它的功能没有std::unique_lock多.std::unique_lock性能消耗比std::lock_guard稍微大点.(见<em>C++</em> Concurrency in Action英文第二版)</p>
<blockquote>
<p>std::lock_guard和std::unique_lock都在析构函数中解锁.都是RAII管理类.<br>std::unique_lock可以选择在构造的时候不拿锁,std::defer_lock选项.std::lock_guard不行.</p>
</blockquote>
<p>如:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::defer_lock允许在不获取锁的情况下创建锁结构。当锁定多个互斥锁时，如果两个函数调用者同时尝试获取锁，则会有一个死锁机会窗口：</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lock1(_mutex1, <span class="built_in">std</span>::defer_lock);</span><br><span class="line">    <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lock2(_mutex2, <span class="built_in">std</span>::defer_lock);</span><br><span class="line">    lock1.lock()</span><br><span class="line">    lock2.lock(); <span class="comment">// deadlock here 这里是可以会死锁的. </span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Locked! &lt;&lt; std::endl;</span></span><br><span class="line"><span class="string">    //...</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">使用以下代码，无论函数中发生什么，都会以适当的顺序获取和释放锁：</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    std::unique_lock&lt;std::mutex&gt; lock1(_mutex1, std::defer_lock);</span></span><br><span class="line"><span class="string">    std::unique_lock&lt;std::mutex&gt; lock2(_mutex2, std::defer_lock);</span></span><br><span class="line"><span class="string">    std::lock(lock1,lock2); // no deadlock possible</span></span><br><span class="line"><span class="string">    std::cout &lt;&lt; "</span>Locked! &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>多把锁的时候就可能会出现死锁.</p>
<blockquote>
<p>std::unique_lock感觉在两个地方得用<br>1.配合条件变量<br>2.除了在构造析构的时机,其他时候也想加锁或解锁.</p>
</blockquote>
<p>参考:</p>
<p>1.Effective Modern C++ Item 39</p>
<blockquote>
<p>就像Item 39说的一样,这样用条件变量通知的办法abstract不够高,程序员还会涉及到一些细节,如果是one-shot一次性通知任务.可以用std::future+std::promise<void>,这么去写更简单.感觉这么写有点类似于Go的channel进行通知的那个意思了??</void></p>
</blockquote>
<p>2.cppreference</p>
<p>3.<em>C++</em> Concurrency in Action英文第二版</p>
<p>待分析:</p>
<p>1.std::cout和printf()的线程安全问题.需不需要额外同步,感觉是要的啊.那临界区会变大呀.影响并发性能…(临界区小点好.)</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://mojiajun.github.io/post/49b47e20.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mojiajun">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mojiajun">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/post/49b47e20.html" itemprop="url">ffmpeg-一次SegmentationFault的debug过程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-11-08T00:00:00+08:00">
                2019-11-08
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Debug/" itemprop="url" rel="index">
                    <span itemprop="name">Debug</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>基本环境:CentOS7.7+gcc4.8.5</p>
<p>cpu信息查看:lscpu,操作系统查看:lsb_release -a</p>
<p>之前ffmpeg源码编译还正常的,换一台机器,用的cpu和之前的不一样.然后就不行了.报Segmentation Fault.</p>
<p>然后逐步找问题所在</p>
<h3 id="首先先设置core-file-size-用gdb-ffmpeg-core-去定位问题"><a href="#首先先设置core-file-size-用gdb-ffmpeg-core-去定位问题" class="headerlink" title="首先先设置core file size,用gdb ffmpeg core,去定位问题"></a>首先先设置core file size,用gdb ffmpeg core,去定位问题</h3><p>ulimit -a/-c单位:字节Byte</p>
<p>然后可以直接在shell设置,但是保存不持久.为了一直可以core dump.设置/etc/security/limits.conf.设成了10G</p>
<p>然后再次运行出错的ffmpeg命令,这时在执行目录下生产了一个core文件,一看接近5个G.</p>
<p>然后gdb ffmpeg core</p>
<p>但是此时一堆”??”gdb提示说是用debuginfo-install去安装调试信息,然后去一个一个安装.</p>
<p>最后ffmpeg重新编译之前配置加几行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">--<span class="built_in">enable</span>-debug=3 \</span><br><span class="line">--<span class="built_in">disable</span>-optimizations \</span><br><span class="line">--<span class="built_in">disable</span>-asm  \</span><br><span class="line">--<span class="built_in">disable</span>-stripping \</span><br></pre></td></tr></table></figure>
<p>然后重新gdb看.</p>
<p>发现栈帧如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[Thread debugging <span class="keyword">using</span> libthread_db enabled]</span><br><span class="line">Using host libthread_db library <span class="string">"/lib64/libthread_db.so.1"</span>.</span><br><span class="line">Core was generated by `/home/msgroup/ffmpeg-pkg/ffmpeg/ffmpeg -i ../Game.of.Thrones.S08E01.Kings.Landi<span class="string">'.</span></span><br><span class="line">Program terminated with signal 11, Segmentation fault.</span><br><span class="line">#<span class="number">0</span>  <span class="number">0x00000000018e484f</span> <span class="function">in <span class="title">x264_8_load_deinterleave_chroma_fenc_avx512</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="params">(gdb)</span> bt</span></span><br><span class="line">#0  0x00000000018e484f in x264_8_load_deinterleave_chroma_fenc_avx512 ()</span><br><span class="line">#<span class="number">1</span>  <span class="number">0x0000000001806717</span> <span class="function">in <span class="title">ac_energy_mb</span> <span class="params">()</span></span></span><br><span class="line">#2  0x0000000001808a72 in x264_8_adaptive_quant_frame ()</span><br><span class="line">#<span class="number">3</span>  <span class="number">0x0000000001768476</span> <span class="function">in <span class="title">x264_8_encoder_encode</span> <span class="params">()</span></span></span><br><span class="line">#4  0x0000000000ba9b6a in X264_frame (ctx=0x4ce37c0, pkt=0x56a89b0, frame=0x5a7c5b0, got_packet=0x7ffce1f008bc) at libavcodec/libx264.c:413</span><br><span class="line">#5  0x0000000000a1677f in avcodec_encode_video2 (avctx=0x4ce37c0, avpkt=0x56a89b0, frame=0x5a7c5b0, got_packet_ptr=0x7ffce1f008bc) at libavcodec/encode.c:296</span><br><span class="line">#6  0x0000000000a16a71 in do_encode (avctx=0x4ce37c0, frame=0x5a7c5b0, got_packet=0x7ffce1f008bc) at libavcodec/encode.c:365</span><br><span class="line">#7  0x0000000000a16c4c in avcodec_send_frame (avctx=0x4ce37c0, frame=0x5a7c5b0) at libavcodec/encode.c:414</span><br><span class="line">#8  0x0000000000428cf8 in do_video_out (of=0x4cbdb70, ost=0x4e9e270, next_picture=0x5a7c5b0, sync_ipts=0) at fftools/ffmpeg.c:1286</span><br><span class="line">#9  0x0000000000429c54 in reap_filters (flush=0) at fftools/ffmpeg.c:1503</span><br><span class="line">#10 0x0000000000435160 in transcode_step () at fftools/ffmpeg.c:4645</span><br><span class="line">#11 0x0000000000435220 in transcode () at fftools/ffmpeg.c:4689</span><br><span class="line">#12 0x0000000000435992 in main (argc=8, argv=0x7ffce1f01778) at fftools/ffmpeg.c:4891</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure>
<h3 id="发现问题所在后-缩小问题范围"><a href="#发现问题所在后-缩小问题范围" class="headerlink" title="发现问题所在后,缩小问题范围"></a>发现问题所在后,缩小问题范围</h3><p>x264_8_load_deinterleave_chroma_fenc_avx512().感觉应该是高级点的cpu浮点数指令有问题</p>
<p>x264源码里头搜一搜</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">grep x264_8_load_deinterleave_chroma_fenc_avx512 * -R</span><br><span class="line">grep _chroma_fenc_avx512 * -R</span><br><span class="line"></span><br><span class="line">nm common/x86/mc-c-8.o | less</span><br></pre></td></tr></table></figure>
<p>还有就是源码里头也可以看看.</p>
<p>没结果.然后gcc看看有没有取消avx512的选项,有两个-mno-avx,-mno-avx2.(只对C生成的汇编管用,要是手写的汇编没用吧.)但是好像不管用.然后发现不能在config.mak里改,这个貌似是由configure Shell脚本生成的.所以去这个脚本里改改试试.发现貌似还是不行.</p>
<p>最后想到x264 configure的时候,多加一个选项.禁止x264使用platform-specific assembly optimizations(可能是一些手写汇编?)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--<span class="built_in">disable</span>-asm            <span class="built_in">disable</span> platform-specific assembly optimizations</span><br></pre></td></tr></table></figure>
<p>然后重新编译x264,再重新编译ffmpeg.</p>
<p>最后问题解决.</p>
<blockquote>
<p>  core dump挺重要啊.对于debug</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://mojiajun.github.io/post/4a75fa2f.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mojiajun">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mojiajun">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/post/4a75fa2f.html" itemprop="url">mit6824-lab1-part-V</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-10-10T00:00:00+08:00">
                2019-10-10
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/分布式/" itemprop="url" rel="index">
                    <span itemprop="name">分布式</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/分布式/mit6824/" itemprop="url" rel="index">
                    <span itemprop="name">mit6824</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>[TOC]</p>
<h2 id="lab1-Part-V-Inverted-index-generation"><a href="#lab1-Part-V-Inverted-index-generation" class="headerlink" title="lab1-Part V Inverted index generation"></a>lab1-Part V Inverted index generation</h2><p>Inverted index倒排索引.从关键词到url的索引.(文件名也可以看做一种url吧.)</p>
<p>那就是在word count的基础上加点东西?和word count还是不同的.看后面的代码即知.</p>
<p>不仅统计词数,还要附带出现的url位置.</p>
<p>这个partV不难,还是挺有意思的.</p>
<p>先用go run ii.go master sequential pg-*.txt测试.</p>
<h3 id="mapF"><a href="#mapF" class="headerlink" title="mapF"></a>mapF</h3><p>感觉mapF函数几乎和lab2-wc.go里面的mapF差不多啊</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapF</span><span class="params">(document <span class="keyword">string</span>, value <span class="keyword">string</span>)</span> <span class="params">(res []mapreduce.KeyValue)</span></span> &#123;</span><br><span class="line">	<span class="comment">// Your code here (Part V).</span></span><br><span class="line">	<span class="comment">// 划分词</span></span><br><span class="line">	<span class="comment">// 划分词这里得搞明白...</span></span><br><span class="line">	<span class="comment">// words := strings.Fields(contents)</span></span><br><span class="line">	words := strings.FieldsFunc(contents, <span class="function"><span class="keyword">func</span><span class="params">(c <span class="keyword">rune</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">		<span class="keyword">return</span> !unicode.IsLetter(c)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 先构造一个map</span></span><br><span class="line">	mapping := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>) <span class="comment">// 有溢出的风险</span></span><br><span class="line">	<span class="keyword">for</span> _, w := <span class="keyword">range</span> words &#123;</span><br><span class="line">		mapping[w]++</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//把map的数据写入res</span></span><br><span class="line">	<span class="keyword">var</span> res []mapreduce.KeyValue</span><br><span class="line">	<span class="keyword">for</span> key, val := <span class="keyword">range</span> mapping &#123;</span><br><span class="line">		res = <span class="built_in">append</span>(res, mapreduce.KeyValue&#123;Key: key, Value: strconv.Itoa(val) + document&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="reduceF"><a href="#reduceF" class="headerlink" title="reduceF"></a>reduceF</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reduceF</span><span class="params">(key <span class="keyword">string</span>, values []<span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="comment">// Your code here (Part V).</span></span><br><span class="line">	<span class="keyword">var</span> valInt <span class="keyword">int</span></span><br><span class="line">	<span class="keyword">var</span> invertedIndex <span class="keyword">string</span></span><br><span class="line">	<span class="keyword">for</span> _, val := <span class="keyword">range</span> values &#123;</span><br><span class="line">		<span class="comment">// fmt.Println(val)</span></span><br><span class="line">		splitRes := strings.FieldsFunc(val, <span class="function"><span class="keyword">func</span><span class="params">(c <span class="keyword">rune</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">			<span class="keyword">return</span> unicode.IsSpace(c)  <span class="comment">// 为true则删除,而且会作为界限，在这里即是空格space</span></span><br><span class="line">		&#125;)</span><br><span class="line">		<span class="comment">// fmt.Println(splitRes)</span></span><br><span class="line">		valIntTemp, err := strconv.Atoi(splitRes[<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Fatal(<span class="string">"reduceF() fail "</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">		valInt += valIntTemp</span><br><span class="line">		<span class="keyword">if</span> invertedIndex != <span class="string">""</span> &#123;</span><br><span class="line">			invertedIndex += <span class="string">","</span></span><br><span class="line">		&#125;</span><br><span class="line">		invertedIndex += splitRes[<span class="number">1</span>]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> strconv.Itoa(valInt) + <span class="string">" "</span> + invertedIndex <span class="comment">// 这么写的话也可能溢出.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样的话前面的那个数字会把所有出现的次数都算进来了.等于是wc count了…?<br>但是应该不是这样的.改成下面这就好了,因为要在mapF阶段去重.所以这么写</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapF</span><span class="params">(document <span class="keyword">string</span>, value <span class="keyword">string</span>)</span> []<span class="title">mapreduce</span>.<span class="title">KeyValue</span></span> &#123;</span><br><span class="line">	<span class="comment">// Your code here (Part V).</span></span><br><span class="line">	<span class="comment">// 划分词</span></span><br><span class="line">	<span class="comment">// 划分词这里得搞明白...</span></span><br><span class="line">	<span class="comment">// words := strings.Fields(contents)</span></span><br><span class="line">	words := strings.FieldsFunc(value, <span class="function"><span class="keyword">func</span><span class="params">(c <span class="keyword">rune</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">		<span class="keyword">return</span> !unicode.IsLetter(c)  <span class="comment">// 不是字母的地方得删除,而且会作为界限</span></span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 先构造一个map</span></span><br><span class="line">	mapping := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>) <span class="comment">// 有溢出的风险</span></span><br><span class="line">	<span class="keyword">for</span> _, w := <span class="keyword">range</span> words &#123;</span><br><span class="line">		mapping[w]++</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//把map的数据写入res</span></span><br><span class="line">	<span class="keyword">var</span> res []mapreduce.KeyValue</span><br><span class="line">	<span class="keyword">for</span> key, _ := <span class="keyword">range</span> mapping &#123;</span><br><span class="line">		res = <span class="built_in">append</span>(res, mapreduce.KeyValue&#123;Key: key, Value: strconv.Itoa(<span class="number">1</span>) + <span class="string">" "</span> + document&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="master-worker分布式模式来运行"><a href="#master-worker分布式模式来运行" class="headerlink" title="master-worker分布式模式来运行"></a>master-worker分布式模式来运行</h3><p>类似lab1-part-II那样太麻烦了…</p>
<p>直接改代码吧,改成test-test.go里面的那样.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   mr := mapreduce.Distributed(<span class="string">"iiseq"</span>, os.Args[<span class="number">1</span>:], <span class="number">3</span>, <span class="string">"localhost:7700"</span>)</span><br><span class="line">   <span class="comment">// Start 2 workers that fail after 10 tasks</span></span><br><span class="line">   <span class="keyword">go</span> mapreduce.RunWorker(<span class="string">"localhost:7700"</span>, <span class="string">"localhost:7701"</span>,</span><br><span class="line">      mapF, reduceF, <span class="number">2</span>, <span class="literal">nil</span>)</span><br><span class="line">   <span class="keyword">go</span> mapreduce.RunWorker(<span class="string">"localhost:7700"</span>, <span class="string">"localhost:7702"</span>,</span><br><span class="line">      mapF, reduceF, <span class="number">-1</span>, <span class="literal">nil</span>)</span><br><span class="line">   <span class="keyword">go</span> mapreduce.RunWorker(<span class="string">"localhost:7700"</span>, <span class="string">"localhost:7703"</span>,</span><br><span class="line">      mapF, reduceF, <span class="number">3</span>, <span class="literal">nil</span>)</span><br><span class="line">   <span class="keyword">go</span> mapreduce.RunWorker(<span class="string">"localhost:7700"</span>, <span class="string">"localhost:7704"</span>,</span><br><span class="line">      mapF, reduceF, <span class="number">-1</span>, <span class="literal">nil</span>)</span><br><span class="line">   mr.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> sequential.mrtmp.iiseq为 sequential模式下的最后输出mrtmp.iiseq,用来进行对比.结果发现是一样的.doMap()不管怎么执行,hash进哪个文件都是确定的.然后doReduce()会对key进行排序后写入输出文件.所以是一样的.等效的.</p>
<p>go run ii.go pg-*.txt<br>diff mrtmp.iiseq sequential.mrtmp.iiseq</p>
<h3 id="最后总结-完成lab1的part-I至V-5个part之后"><a href="#最后总结-完成lab1的part-I至V-5个part之后" class="headerlink" title="最后总结(完成lab1的part-I至V,5个part之后)"></a>最后总结(完成lab1的part-I至V,5个part之后)</h3><p>part-I,实现doMap()和doReduce().</p>
<p>part-II,实现mapF和reduceF(这个相当于是mapreduce框架提供给用户业务代码的接口).lab2有word count任务.<br>lab5有Inverted index任务,在理解清楚真个mapreduce框架的流程后,并不难.</p>
<p>part-III,实现schedule().这一部分应该是最难的一个part了…把序列式的执行改成基于rpc的分布式执行.这一部分需要仔细理解清楚整个流程中的每个细节.</p>
<p>part-IV,在part-III的基础上增加worker崩了也没事的容错机制.</p>
<p>part-V.针对Inverted index任务写业务代码</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://mojiajun.github.io/post/36cb5d71.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mojiajun">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mojiajun">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/post/36cb5d71.html" itemprop="url">mit6824-lab1-part-IV</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-10-09T00:00:00+08:00">
                2019-10-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/分布式/" itemprop="url" rel="index">
                    <span itemprop="name">分布式</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/分布式/mit6824/" itemprop="url" rel="index">
                    <span itemprop="name">mit6824</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>[TOC]</p>
<h2 id="lab1-Part-I-Map-Reduce-input-and-output-part-IV"><a href="#lab1-Part-I-Map-Reduce-input-and-output-part-IV" class="headerlink" title="lab1-Part-I-Map/Reduce input and output-part-IV"></a>lab1-Part-I-Map/Reduce input and output-part-IV</h2><p>MapReduce makes this relatively easy because workers don’t have persistent state.<br>什么是persistent state?</p>
<p>Two invocations of a map or reduce function are required to generate the same output for a given input (i.e. the map and reduce functions are “functional”)[这里应该指的是只要输入一样,也就是给的task一样,不同map,reduce函数的输出是完全一样的.输出即输出文件.], so there won’t be inconsistencies[不一致] if subsequent processing sometimes reads one output and sometimes the other(读的时候不就是读同一个文件吗???). In addition, the MapReduce framework ensures that map and reduce function output appears atomically: the output file will either not exist, or will contain the entire output of a single execution of the map or reduce function (the lab code doesn’t actually implement this[这个实验里确实没实现这个], but instead only fails workers at the end of a task, so there aren’t concurrent executions of a task[一个task并发执行???不行吧.一个task只能被分配给一个worker]).???啥意思?</p>
<p>1.某个worker失效后,也就是没有在进行监听了,那么master怎么知晓这件事?然后接下来的任务就跳过它.在后续可能还会把任务分配给这个worker,但是在call()的内部rpc.Dial()时,会timeout.然后检测到错误.</p>
<p>2.worker可能是中途由于不明原因终止的.这也要能处理好.这种情况虽然官方给的测试用例里面对这种情况没测,但是应该也是可以的,因为那样最终还是会导致call()rpc调用的时候timeout.那样的话输出文件如果已经创建了怎么办?直接覆盖吧.</p>
<p>3.多个worker可能会执行相同的task.所以会出现什么问题?如果是两个worker往同一个文件里面写入呢?这种情况还是可能出现的吧?甚至3个,4个…worker往同一个输出文件里面写入,假设在备用的第2个worker又执行那个失败任务的时候这个备用的worker也故障了(可能超时之后第2个worker调用的rpc还是正在执行),那么就会出现第3个worker来执行这个任务.就有可能出现同时3个worker它们对应的rpc都在执行同一个task.以此类推4个,5个…<br>因为假设worker在写入,但是rpc timeout了,此时master端直接返回了,然后就会把任务分配给其他worker了.此时其他worker就可能在工作了.但是应该没啥影响吧?往同一个文件里写.因为它们的文件偏移不一样.后面的这个会覆盖前面的那个的写入.<strong>而假设两个worker如果假设都正确写入的话,他们写入的结果应该是完全一样的.</strong>所以哪怕前一个正在写入,后一个worker又进行工作了,也在写入,也不会出问题.??是这么回事吗?</p>
<p>只在lab1-part-III的基础上稍微改了一点点.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">schedule</span><span class="params">(jobName <span class="keyword">string</span>, mapFiles []<span class="keyword">string</span>, nReduce <span class="keyword">int</span>, phase jobPhase, registerChan <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> ntasks <span class="keyword">int</span></span><br><span class="line">	<span class="keyword">var</span> n_other <span class="keyword">int</span> <span class="comment">// number of inputs (for reduce) or outputs (for map)</span></span><br><span class="line">	<span class="keyword">switch</span> phase &#123;</span><br><span class="line">	<span class="keyword">case</span> mapPhase:</span><br><span class="line">		ntasks = <span class="built_in">len</span>(mapFiles)</span><br><span class="line">		n_other = nReduce</span><br><span class="line">	<span class="keyword">case</span> reducePhase:</span><br><span class="line">		ntasks = nReduce</span><br><span class="line">		n_other = <span class="built_in">len</span>(mapFiles)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">"Schedule: %v %v tasks (%d I/Os)\n"</span>, ntasks, phase, n_other)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// All ntasks tasks have to be scheduled on workers. Once all tasks</span></span><br><span class="line">	<span class="comment">// have completed successfully, schedule() should return.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Your code here (Part III, Part IV).</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// worker设成工作池模式.模仿Go-by-example的worker-pools例子[https://gobyexample.com/worker-pools]</span></span><br><span class="line">	<span class="comment">// 新来的worker怎么办? 使用另外一个协程阻塞在registerChan这个channel上面,一旦有新来的worker,再启动一个新的协程来进行同步rpc调用</span></span><br><span class="line">	<span class="comment">// 最终目标是把ntasks个任务分配给若干个worker,在schedule()的尾部,需要等待所有任务处理完.</span></span><br><span class="line"></span><br><span class="line">	taskPool := <span class="built_in">make</span>(<span class="keyword">chan</span> DoTaskArgs, ntasks)</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 不开一个新的协程去负责接收registerChan里面的worker好像不行,因为不知道会有多少个worker会来,以及多久来.而registerChan</span></span><br><span class="line">	<span class="comment">// 又是unbuffer的,接收不到就会阻塞</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="comment">// 这个for循环一定要有,否则!!!后面的代码执行一次之后就退出了,也就是会导致只会创建出一个worker协程,这不是我们想要的结果.</span></span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="comment">// 从forwardRegistration收到一个worker的地址</span></span><br><span class="line">			worker := &lt;-registerChan</span><br><span class="line">			<span class="comment">//fmt.Println("launch a new worker goroutine", worker)</span></span><br><span class="line">			<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">				<span class="keyword">for</span> taskArgs := <span class="keyword">range</span> taskPool &#123; <span class="comment">// 参考Go-by-example的worker-pools例子[https://gobyexample.com/worker-pools]</span></span><br><span class="line">					boolval := call(worker, <span class="string">"Worker.DoTask"</span>, taskArgs, <span class="literal">nil</span>)</span><br><span class="line">					<span class="keyword">if</span> boolval == <span class="literal">false</span> &#123;</span><br><span class="line">						<span class="comment">// 没做完这个task,直接退出,不用调用wg.Done(),因为它没完成指定任务</span></span><br><span class="line">						<span class="comment">// 然后得把任务重新加入任务池</span></span><br><span class="line">						taskPool &lt;- taskArgs</span><br><span class="line">						<span class="keyword">break</span></span><br><span class="line">					&#125;</span><br><span class="line">					wg.Done()</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建每个任务对应的DoTaskArgs结构体,然后放入taskPool</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; ntasks; i++ &#123;</span><br><span class="line">		<span class="keyword">var</span> doTaskArgs DoTaskArgs;</span><br><span class="line">		doTaskArgs.JobName = jobName</span><br><span class="line">		doTaskArgs.TaskNumber = i</span><br><span class="line">		doTaskArgs.NumOtherPhase = n_other</span><br><span class="line">		<span class="keyword">switch</span> phase &#123;</span><br><span class="line">		<span class="keyword">case</span> mapPhase:</span><br><span class="line">			doTaskArgs.Phase = mapPhase</span><br><span class="line">			doTaskArgs.File = mapFiles[i]</span><br><span class="line">		<span class="keyword">case</span> reducePhase:</span><br><span class="line">			doTaskArgs.Phase = reducePhase</span><br><span class="line">		&#125;</span><br><span class="line">		taskPool &lt;- doTaskArgs</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">"Schedule: %v done\n"</span>, phase)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RunWorker协程启动后就一直在监听.(会检测当前做的task数目是否已经达到阈值,达到之后则这个协程退出.不再监听.)<br>如果是在监听状态,当有任务到来,比如master的schedule()发起rpc调用call(worker, “Worker.DoTask”, taskArgs, nil),RunWorker协程会go rpcs.ServeConn(conn)</p>
<p>测试用例里面用的是设定nRPC的值,然后做完指定数量的后.在RunWorker中会把wk.nRPC减到0,然后go rpcs.ServeConn(conn)处理最后一次task.当RunWorker协程再次循环的时候即退出.此时,下一次task来的时候,若分配给了这个退出的worker.然后这个RunWorker协程调用call().估计在rpc.Dial()失败?所以不会继续,timeout,然后检测失败.</p>
<blockquote>
<p>???<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;c, errx := rpc.Dial(<span class="string">"unix"</span>, srv)</span><br><span class="line">&gt;<span class="comment">// 在lab2的最后,换用localhost 7777这样的tcp连接去这么调用也可以?</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">mojiajun</p>
              <p class="site-description motion-element" itemprop="description">莫佳骏学习笔记</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">20</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">mojiajun</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>








        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
