<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="莫佳骏学习笔记">
<meta property="og:type" content="website">
<meta property="og:title" content="mojiajun">
<meta property="og:url" content="https://mojiajun.github.io/page/2/index.html">
<meta property="og:site_name" content="mojiajun">
<meta property="og:description" content="莫佳骏学习笔记">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="mojiajun">
<meta name="twitter:description" content="莫佳骏学习笔记">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://mojiajun.github.io/page/2/">





  <title>mojiajun</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">mojiajun</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://mojiajun.github.io/post/3b45df5e.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mojiajun">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mojiajun">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/post/3b45df5e.html" itemprop="url">C++-虚函数机制-01</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-07-22T00:00:00+08:00">
                2019-07-22
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>[TOC]</p>
<p>这篇是虚函数表vtbl和虚表指针vptr的基础.基本认知,采用的是调试器反汇编看底层的方式.额外提了下空类.</p>
<p>测试环境:<br>x86-64<br>Ubuntu 18.04.2 LTS<br>cat /proc/version</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Linux version 4.15.0-48-generic (buildd@lgw01-amd64-036) (gcc version 7.3.0 (Ubuntu 7.3.0-16ubuntu3)) <span class="comment">#51-Ubuntu SMP Wed Apr 3 08:28:49 UTC 2019</span></span><br></pre></td></tr></table></figure>
<h3 id="虚函数表"><a href="#虚函数表" class="headerlink" title="虚函数表"></a>虚函数表</h3><p>虚函数机制(没分析继承)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">virtual_func_test01.cc</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CVirtual</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">GetNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> _nNumber;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SetNumber</span><span class="params">(<span class="keyword">int</span> nNumber)</span> </span>&#123;</span><br><span class="line">      _nNumber = nNumber;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> _nNumber;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nSizeOfCVirtual = <span class="keyword">sizeof</span>(CVirtual);</span><br><span class="line">    <span class="keyword">int</span> nSizeOfPointer = <span class="keyword">sizeof</span>(<span class="keyword">int</span> *);</span><br><span class="line">    <span class="comment">//printf("the size of CVirtual (in BYTE) is : %d\n", nSizeOfCVirtual);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译:g++ -g -o virtual_func_test01 virtual_func_test01.cc<br>调试:lldb ./virtual_func_test01</p>
<p>main这里打个断点.然后反汇编一下.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(lldb) dis</span><br><span class="line">virtual_func_test01`main:</span><br><span class="line">    0x5555555545fa &lt;+0&gt;:  pushq  %rbp</span><br><span class="line">    0x5555555545fb &lt;+1&gt;:  movq   %rsp, %rbp</span><br><span class="line">    0x5555555545fe &lt;+4&gt;:  movl   $0x10, -0x8(%rbp)</span><br><span class="line">    0x555555554605 &lt;+11&gt;: movl   $0x8, -0x4(%rbp)</span><br><span class="line">-&gt;  0x55555555460c &lt;+18&gt;: movl   $0x0, %eax</span><br><span class="line">    0x555555554611 &lt;+23&gt;: popq   %rbp</span><br><span class="line">    0x555555554612 &lt;+24&gt;: retq</span><br></pre></td></tr></table></figure>
<p>结果分别是(十进制)16和8<br>涉及 rbp,rsp 栈向低地址生长,eax(返回值常用的寄存器,见CSAPP第三章),ATT格式汇编等基础.这里不提了.</p>
<hr>
<p>修改一下代码,创建一个栈上的对象testObj.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">CVirtual <span class="title">testObj</span><span class="params">(<span class="number">10324</span>)</span></span>;</span><br><span class="line">    testObj.SetNumber(<span class="number">200</span>);</span><br><span class="line">    testObj.GetNumber();</span><br><span class="line">    CVirtual *ptestObj = &amp;testObj;</span><br><span class="line">    <span class="keyword">int</span> nSizeOfCVirtual = <span class="keyword">sizeof</span>(CVirtual);</span><br><span class="line">    <span class="keyword">int</span> nSizeOfPointer = <span class="keyword">sizeof</span>(<span class="keyword">int</span> *);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>貌似lldb没找到gdb info vtbl类似的命令,所以在这里用gdb查看一下vtbl(要等CVirtual的构造函数执行完,否则vtbl里面的地址不对,相当于还没初始化好.).</p>
<p>然后反汇编main函数,顺便用info vtbl testObj查看一下虚函数表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disassemble main</span><br><span class="line">Dump of assembler code for function main():</span><br><span class="line">   0x000055555555475a &lt;+0&gt;:	push   %rbp</span><br><span class="line">   0x000055555555475b &lt;+1&gt;:	mov    %rsp,%rbp</span><br><span class="line">   0x000055555555475e &lt;+4&gt;:	sub    $0x30,%rsp</span><br><span class="line">   0x0000555555554762 &lt;+8&gt;:	mov    %fs:0x28,%rax</span><br><span class="line">   0x000055555555476b &lt;+17&gt;:	mov    %rax,-0x8(%rbp)</span><br><span class="line">   0x000055555555476f &lt;+21&gt;:	xor    %eax,%eax</span><br><span class="line">   0x0000555555554771 &lt;+23&gt;:	lea    -0x20(%rbp),%rax</span><br><span class="line">   0x0000555555554775 &lt;+27&gt;:	mov    $0x2854,%esi</span><br><span class="line">   0x000055555555477a &lt;+32&gt;:	mov    %rax,%rdi</span><br><span class="line">   0x000055555555477d &lt;+35&gt;:	callq  0x5555555547d0 &lt;CVirtual::CVirtual(int)&gt;</span><br><span class="line">   0x0000555555554782 &lt;+40&gt;:	lea    -0x20(%rbp),%rax</span><br><span class="line">   0x0000555555554786 &lt;+44&gt;:	mov    $0xc8,%esi</span><br><span class="line">   0x000055555555478b &lt;+49&gt;:	mov    %rax,%rdi</span><br><span class="line">   0x000055555555478e &lt;+52&gt;:	callq  0x555555554808 &lt;CVirtual::SetNumber(int)&gt;</span><br><span class="line">   0x0000555555554793 &lt;+57&gt;:	lea    -0x20(%rbp),%rax</span><br><span class="line">   0x0000555555554797 &lt;+61&gt;:	mov    %rax,%rdi</span><br><span class="line">   0x000055555555479a &lt;+64&gt;:	callq  0x5555555547f6 &lt;CVirtual::GetNumber()&gt;</span><br><span class="line">   0x000055555555479f &lt;+69&gt;:	lea    -0x20(%rbp),%rax</span><br><span class="line">   0x00005555555547a3 &lt;+73&gt;:	mov    %rax,-0x28(%rbp)</span><br><span class="line">   0x00005555555547a7 &lt;+77&gt;:	movl   $0x10,-0x30(%rbp)</span><br><span class="line">   0x00005555555547ae &lt;+84&gt;:	movl   $0x8,-0x2c(%rbp)</span><br><span class="line">=&gt; 0x00005555555547b5 &lt;+91&gt;:	mov    $0x0,%eax</span><br><span class="line">   0x00005555555547ba &lt;+96&gt;:	mov    -0x8(%rbp),%rdx</span><br><span class="line">   0x00005555555547be &lt;+100&gt;:	xor    %fs:0x28,%rdx</span><br><span class="line">   0x00005555555547c7 &lt;+109&gt;:	je     0x5555555547ce &lt;main()+116&gt;</span><br><span class="line">   0x00005555555547c9 &lt;+111&gt;:	callq  0x555555554630 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">   0x00005555555547ce &lt;+116&gt;:	leaveq</span><br><span class="line">   0x00005555555547cf &lt;+117&gt;:	retq</span><br><span class="line">End of assembler dump.</span><br><span class="line"></span><br><span class="line">(gdb) info vtbl testObj</span><br><span class="line">vtable for &apos;CVirtual&apos; @ 0x555555754d98 (subobject @ 0x7fffffffe470):</span><br><span class="line">[0]: 0x5555555547f6 &lt;CVirtual::GetNumber()&gt;</span><br><span class="line">[1]: 0x555555554808 &lt;CVirtual::SetNumber(int)&gt;</span><br><span class="line">刚好就是main里面callq的函数地址.// subobject @ 0x7fffffffe470 gdb打印的testObj对象的地址</span><br></pre></td></tr></table></figure>
<hr>
<p>然后看一下这个testObj占多大?对象的地址在哪?</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x ptestObj</span><br><span class="line"> :	0x55754d98</span><br><span class="line">//ptestObj指针在main帧里面,栈上面的变量.这个指针的值是0x7fffffffe470,也就是testObj的地址.注意后面的0x55754d98是0x7fffffffe470指向的位置的内容(也就是vtbl的值)</span><br></pre></td></tr></table></figure>
<p>又因为testObj在栈上占16字节<br>然后读一下这块内存的内容,注意输出是小端.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/16xb 0x7fffffffe470</span><br><span class="line">0x7fffffffe470:	0x98	0x4d	0x75	0x55	0x55	0x55	0x00	0x00</span><br><span class="line">0x7fffffffe478:	0xc8	0x00	0x00	0x00	0x55	0x55	0x00	0x00</span><br></pre></td></tr></table></figure>
<p>因为sizeof(int) == 4字节.在目前的机器的实现上前8个字节存的是指向vtbl的vptr.<br>vptr存的地址是0x00005555 55754d98.<br>0xc8 0x00 0x00 0x00是后面调用testObj.SetNumber(200);存入的200,还有四个字节估计和对齐有关?</p>
<p>然后把虚函数表里面的内容读出来看看</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/32xb 0x0000555555754d98</span><br><span class="line">0x555555754d98 &lt;_ZTV8CVirtual+16&gt;:	0xf6	0x47	0x55	0x55	0x55	0x55	0x00	0x00</span><br><span class="line">0x555555754da0 &lt;_ZTV8CVirtual+24&gt;:	0x08	0x48	0x55	0x55	0x55	0x55	0x00	0x00</span><br><span class="line">0x555555754da8 &lt;_ZTI8CVirtual&gt;:	0xf8	0x67	0xdc	0xf7	0xff	0x7f	0x00	0x00</span><br><span class="line">0x555555754db0 &lt;_ZTI8CVirtual+8&gt;:	0xa8	0x48	0x55	0x55	0x55	0x55	0x00	0x00</span><br></pre></td></tr></table></figure>
<p>前两项输出和gdb info vtal结果一样.</p>
<p>最后看看</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[0]: 0x5555555547f6 &lt;CVirtual::GetNumber()&gt;</span><br><span class="line">[1]: 0x555555554808 &lt;CVirtual::SetNumber(int)&gt;</span><br><span class="line">这两个函数的内容存在哪了.</span><br></pre></td></tr></table></figure>
<p>disassemble 0x5555555547f6 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/64x 0x5555555547f6</span><br><span class="line">0x5555555547f6 &lt;CVirtual::GetNumber()&gt;:	0x55	0x48	0x89	0xe5	0x48	0x89	0x7d	0xf8</span><br><span class="line">0x5555555547fe &lt;CVirtual::GetNumber()+8&gt;:	0x48	0x8b	0x45	0xf8	0x8b	0x40	0x08	0x5d</span><br><span class="line">0x555555554806 &lt;CVirtual::GetNumber()+16&gt;:	0xc3	0x90	0x55	0x48	0x89	0xe5	0x48	0x89</span><br><span class="line">0x55555555480e &lt;CVirtual::SetNumber(int)+6&gt;:	0x7d	0xf8	0x89	0x75	0xf4	0x48	0x8b	0x45</span><br><span class="line">0x555555554816 &lt;CVirtual::SetNumber(int)+14&gt;:	0xf8	0x8b	0x55	0xf4	0x89	0x50	0x08	0x90</span><br><span class="line">0x55555555481e &lt;CVirtual::SetNumber(int)+22&gt;:	0x5d	0xc3	0x41	0x57	0x41	0x56	0x49	0x89</span><br><span class="line">0x555555554826 &lt;__libc_csu_init+6&gt;:	0xd7	0x41	0x55	0x41	0x54	0x4c	0x8d	0x25</span><br><span class="line">0x55555555482e &lt;__libc_csu_init+14&gt;:	0x46	0x05	0x20	0x00	0x55	0x48	0x8d	0x2d</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disassemble 0x5555555547f6</span><br><span class="line">Dump of assembler code for function CVirtual::GetNumber():</span><br><span class="line">   0x00005555555547f6 &lt;+0&gt;:		push   %rbp</span><br><span class="line">   0x00005555555547f7 &lt;+1&gt;:		mov    %rsp,%rbp</span><br><span class="line">   0x00005555555547fa &lt;+4&gt;:		mov    %rdi,-0x8(%rbp)</span><br><span class="line">   0x00005555555547fe &lt;+8&gt;:		mov    -0x8(%rbp),%rax</span><br><span class="line">   0x0000555555554802 &lt;+12&gt;:	mov    0x8(%rax),%eax</span><br><span class="line">   0x0000555555554805 &lt;+15&gt;:	pop    %rbp</span><br><span class="line">   0x0000555555554806 &lt;+16&gt;:	retq</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>
<p>同理[1]: 0x555555554808 <a href="CVirtual::SetNumber(int)" target="_blank" rel="noopener">CVirtual::SetNumber(int)</a>不在这里列举了.<br>最后的最后,看看在ELF文件里面这两函数在哪.readelf命令看,但是显示的加载地址都比较小.与调试器里面的不符.1.<a href="https://www.martinkysel.com/demystifying-virtual-tables-in-c-part-1-trivial-constructors/" target="_blank" rel="noopener">Demystifying Virtual Tables In C++</a>这个人分析却是一样的.老版本的不是这样的啊.什么情况…加载器都干了些什么…算了,先不分析这里了.后续再看了.</p>
<h3 id="空类"><a href="#空类" class="headerlink" title="空类"></a>空类</h3><p>参考<a href="http://www.stroustrup.com/bs_faq2.html#sizeof-empty" target="_blank" rel="noopener">Bjarne Stroustrup-Why is the size of an empty class not zero?</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Empty</span> &#123;</span> &#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Empty a, b;</span><br><span class="line">	Empty *pa = &amp;a;</span><br><span class="line">	Empty *pb = &amp;b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    f();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(lldb) frame variable</span><br><span class="line">(Empty) a = &#123;&#125;</span><br><span class="line">(Empty) b = &#123;&#125;</span><br><span class="line">(Empty *) pa = 0x00007fffffffe4a6</span><br><span class="line">(Empty *) pb = 0x00007fffffffe4a7</span><br><span class="line">(lldb) expression &amp;a</span><br><span class="line">(Empty *) <span class="variable">$0</span> = 0x00007fffffffe4a6</span><br><span class="line">(lldb) expression &amp;b</span><br><span class="line">(Empty *) <span class="variable">$1</span> = 0x00007fffffffe4a7</span><br><span class="line">(lldb) memory <span class="built_in">read</span> --size 1 --format x --count 1 0x00007fffffffe4a6</span><br><span class="line">0x7fffffffe4a6: 0x00</span><br><span class="line">(lldb) memory <span class="built_in">read</span> --size 1 --format x --count 1 0x00007fffffffe4a7</span><br><span class="line">0x7fffffffe4a7: 0x00</span><br></pre></td></tr></table></figure>
<p>在我的这台机器上空类的对象占一个字节.字节内容查看是0x00.<br>很奇怪的一点是,没有Empty <em>pa = &a;Empty </em>pb = &b;这两行的话用调试器看expression &amp;a和expression &amp;b是一样的?</p>
<p>1.如果是吧地址取出来Empty <em>pa = &a;Empty </em>pb = &b;像这样,不管调试器还是直接打印出来,pa和pb都会是不同的地址.<br>2.如果按Bjarne Stroustrup给的例子,进行if测试,也是不会相同的.</p>
<hr>
<p>但是如果是empty base class,那么会有一个编译器的优化,叫做empty base class optimization</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Empty</span> &#123;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X</span> :</span> Empty &#123;</span><br><span class="line">        <span class="keyword">int</span> a;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(X* p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">void</span>* p1 = p;</span><br><span class="line">        <span class="keyword">void</span>* p2 = &amp;p-&gt;a;</span><br><span class="line">        <span class="keyword">if</span> (p1 == p2) <span class="built_in">cout</span> &lt;&lt; <span class="string">"nice: good optimizer\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    X testObj;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"sizeof X %d\n"</span>, <span class="keyword">sizeof</span>(X));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"sizeof testObj %d\n"</span>, <span class="keyword">sizeof</span>(testObj));</span><br><span class="line">    f(&amp;testObj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出:</p>
<p>sizeof X 4<br>sizeof testObj 4<br>nice: good optimizer</p>
<hr>
<p>参考:</p>
<p>1.<a href="https://www.martinkysel.com/demystifying-virtual-tables-in-c-part-1-trivial-constructors/" target="_blank" rel="noopener">Demystifying Virtual Tables In C++</a></p>
<p>2.<a href="http://www.stroustrup.com/bs_faq2.html#sizeof-empty" target="_blank" rel="noopener">Bjarne Stroustrup-Why is the size of an empty class not zero?</a></p>
<p>3.反汇编与逆向分析技术揭秘</p>
<p>4.深入探索C++对象模型</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://mojiajun.github.io/post/a24c8ee4.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mojiajun">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mojiajun">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/post/a24c8ee4.html" itemprop="url">C++-虚函数机制-02</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-07-22T00:00:00+08:00">
                2019-07-22
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>反汇编与逆向分析技术揭秘第十一章虚函数<br>阅读及用x86-64-g++平台分析</p>
<p>这篇主要是构造函数和析构函数和vtbl,vptr的联系.(就是把反汇编与逆向分析技术揭秘第十一章虚函数11.1节用x86-64 linux ATT汇编格式过了一遍…)</p>
<p>这篇还没涉及继承…</p>
<p>[TOC]</p>
<h3 id="构造函数和vptr"><a href="#构造函数和vptr" class="headerlink" title="构造函数和vptr"></a>构造函数和vptr</h3><hr>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CVirtual</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">GetNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> _nNumber;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SetNumber</span><span class="params">(<span class="keyword">int</span> nNumber)</span> </span>&#123;</span><br><span class="line">      _nNumber = nNumber;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> _nNumber;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CVirtual testObj;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disassemble main</span><br><span class="line">Dump of assembler code for function main():</span><br><span class="line">   0x000055555555475a &lt;+0&gt;:	push   %rbp</span><br><span class="line">   0x000055555555475b &lt;+1&gt;:	mov    %rsp,%rbp</span><br><span class="line">   0x000055555555475e &lt;+4&gt;:	sub    $0x20,%rsp</span><br><span class="line">   0x0000555555554762 &lt;+8&gt;:	mov    %fs:0x28,%rax</span><br><span class="line">   0x000055555555476b &lt;+17&gt;:	mov    %rax,-0x8(%rbp)</span><br><span class="line">   0x000055555555476f &lt;+21&gt;:	xor    %eax,%eax</span><br><span class="line">   0x0000555555554771 &lt;+23&gt;:	lea    -0x20(%rbp),%rax</span><br><span class="line">=&gt; 0x0000555555554775 &lt;+27&gt;:	mov    %rax,%rdi</span><br><span class="line">   0x0000555555554778 &lt;+30&gt;:	callq  0x5555555547c2 &lt;CVirtual::CVirtual()&gt;</span><br><span class="line">   0x000055555555477d &lt;+35&gt;:	mov    $0x0,%eax</span><br><span class="line">   0x0000555555554782 &lt;+40&gt;:	mov    -0x8(%rbp),%rdx</span><br><span class="line">   0x0000555555554786 &lt;+44&gt;:	xor    %fs:0x28,%rdx</span><br><span class="line">   0x000055555555478f &lt;+53&gt;:	je     0x555555554796 &lt;main()+60&gt;</span><br><span class="line">   0x0000555555554791 &lt;+55&gt;:	callq  0x555555554630 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">   0x0000555555554796 &lt;+60&gt;:	leaveq</span><br><span class="line">   0x0000555555554797 &lt;+61&gt;:	retq</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x $rax  # testObj对象地址</span><br><span class="line">0x7fffffffe470:	0xe0</span><br><span class="line">(gdb) info vtbl testObj</span><br><span class="line">vtable for &apos;CVirtual&apos; @ 0x5555555547e0 (subobject @ 0x7fffffffe470):</span><br><span class="line">[0]: 0x41d7894956415741</span><br><span class="line">[1]: 0x586258d4c544155</span><br><span class="line"># @ 0x5555555547e0是不能用的.因为还没有执行完callq  0x5555555547c2 &lt;CVirtual::CVirtual()&gt;,</span><br><span class="line"># 只有当执行完&lt;CVirtual::CVirtual()&gt;,才算是完整的构造好了对象.否则,别用gdb info vtbl.</span><br><span class="line"># 构造完成之后调用info vtbl testObj的结果,发现@ 0x555555754d98才是vptr正确的值!!!</span><br><span class="line">(gdb) info vtbl testObj</span><br><span class="line">vtable for &apos;CVirtual&apos; @ 0x555555754d98 (subobject @ 0x7fffffffe470):</span><br><span class="line">[0]: 0x555555554798 &lt;CVirtual::GetNumber()&gt;</span><br><span class="line">[1]: 0x5555555547aa &lt;CVirtual::SetNumber(int)&gt;</span><br></pre></td></tr></table></figure>
<p>在callq  0x5555555547c2 <a href="CVirtual::CVirtual()" target="_blank" rel="noopener">CVirtual::CVirtual()</a>之前,需要把testObj的地址(处于对象已经有内存了,但是vptr还没初始化的状态,即[半完成品]对象)放入%rdi.这个地方调用的合成的默认构造函数.也就是在callq CVirtual::CVirtual(),需要先拿到this指针送到%rdi寄存器.</p>
<p>然后是合成的默认构造函数内容:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disassemble 0x5555555547c2</span><br><span class="line">Dump of assembler code for function CVirtual::CVirtual():</span><br><span class="line">   0x00005555555547c2 &lt;+0&gt;:	push   %rbp</span><br><span class="line">   0x00005555555547c3 &lt;+1&gt;:	mov    %rsp,%rbp</span><br><span class="line">   0x00005555555547c6 &lt;+4&gt;:	mov    %rdi,-0x8(%rbp)  #把%rdi里面的this指针存到-0x8(%rbp)</span><br><span class="line">   0x00005555555547ca &lt;+8&gt;:	lea    0x2005c7(%rip),%rdx        # 0x555555754d98 &lt;_ZTV8CVirtual+16&gt;          # 把0x555555754d98这个虚函数表的地址送到%rdx</span><br><span class="line">   0x00005555555547d1 &lt;+15&gt;:	mov    -0x8(%rbp),%rax</span><br><span class="line">   0x00005555555547d5 &lt;+19&gt;:	mov    %rdx,(%rax)  # 把虚函数表地址0x555555754d98填入this指针的对象的前8个字节(也即存入虚表指针里).</span><br><span class="line">   0x00005555555547d8 &lt;+22&gt;:	nop</span><br><span class="line">   0x00005555555547d9 &lt;+23&gt;:	pop    %rbp</span><br><span class="line">   0x00005555555547da &lt;+24&gt;:	retq</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>
<p>这个合成的默认构造函数只干了一件事,那就是把class CVirtual的虚表地址填入对象的vptr指针.</p>
<p>不管testObj对象创建不创建.class CVirtual的虚表在程序加载好了之后就在内存里了.<br>通过x/16xb 0x555555754d98(虚表地址)就能查看虚表的内容.一个类的多个不同对象是共享同一张虚表的.只需要在调用构造函数的时候把虚表地址填入对象的vptr即可.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/16xb 0x555555754d98</span><br><span class="line">0x555555754d98 &lt;_ZTV8CVirtual+16&gt;:	0x98	0x47	0x55	0x55	0x55	0x55	0x00	0x00</span><br><span class="line">0x555555754da0 &lt;_ZTV8CVirtual+24&gt;:	0xaa	0x47	0x55	0x55	0x55	0x55	0x00	0x00</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="object直接调用-用’-’"><a href="#object直接调用-用’-’" class="headerlink" title="object直接调用(用’.’)"></a>object直接调用(用’.’)</h3><p>如果是testObj.SetNumber(200)和testObj.GetNumber()</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CVirtual testObj;</span><br><span class="line">    testObj.SetNumber(<span class="number">200</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\r\n"</span>, testObj.GetNumber());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disassemble main</span><br><span class="line">Dump of assembler code for function main():</span><br><span class="line">   0x00005555555547aa &lt;+0&gt;:	push   %rbp</span><br><span class="line">   0x00005555555547ab &lt;+1&gt;:	mov    %rsp,%rbp</span><br><span class="line">   0x00005555555547ae &lt;+4&gt;:	sub    $0x20,%rsp</span><br><span class="line">=&gt; 0x00005555555547b2 &lt;+8&gt;:	mov    %fs:0x28,%rax</span><br><span class="line">   0x00005555555547bb &lt;+17&gt;:	mov    %rax,-0x8(%rbp)</span><br><span class="line">   0x00005555555547bf &lt;+21&gt;:	xor    %eax,%eax</span><br><span class="line">   0x00005555555547c1 &lt;+23&gt;:	lea    -0x20(%rbp),%rax</span><br><span class="line">   0x00005555555547c5 &lt;+27&gt;:	mov    %rax,%rdi</span><br><span class="line">   0x00005555555547c8 &lt;+30&gt;:	callq  0x555555554842 &lt;CVirtual::CVirtual()&gt;</span><br><span class="line">   0x00005555555547cd &lt;+35&gt;:	lea    -0x20(%rbp),%rax  # this指针放入%rax</span><br><span class="line">   0x00005555555547d1 &lt;+39&gt;:	mov    $0xc8,%esi  # 200放入%esi</span><br><span class="line">   0x00005555555547d6 &lt;+44&gt;:	mov    %rax,%rdi  # %rax中的this指针转移到%rdi </span><br><span class="line">   0x00005555555547d9 &lt;+47&gt;:	callq  0x55555555482a &lt;CVirtual::SetNumber(int)&gt;</span><br><span class="line">   0x00005555555547de &lt;+52&gt;:	lea    -0x20(%rbp),%rax</span><br><span class="line">   0x00005555555547e2 &lt;+56&gt;:	mov    %rax,%rdi</span><br><span class="line">   0x00005555555547e5 &lt;+59&gt;:	callq  0x555555554818 &lt;CVirtual::GetNumber()&gt;</span><br><span class="line">   0x00005555555547ea &lt;+64&gt;:	mov    %eax,%esi</span><br><span class="line">   0x00005555555547ec &lt;+66&gt;:	lea    0xf1(%rip),%rdi        # 0x5555555548e4</span><br><span class="line">   0x00005555555547f3 &lt;+73&gt;:	mov    $0x0,%eax</span><br><span class="line">   0x00005555555547f8 &lt;+78&gt;:	callq  0x555555554670 &lt;printf@plt&gt;</span><br><span class="line">   0x00005555555547fd &lt;+83&gt;:	mov    $0x0,%eax</span><br><span class="line">   0x0000555555554802 &lt;+88&gt;:	mov    -0x8(%rbp),%rdx</span><br><span class="line">   0x0000555555554806 &lt;+92&gt;:	xor    %fs:0x28,%rdx</span><br><span class="line">   0x000055555555480f &lt;+101&gt;:	je     0x555555554816 &lt;main()+108&gt;</span><br><span class="line">   0x0000555555554811 &lt;+103&gt;:	callq  0x555555554680 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">   0x0000555555554816 &lt;+108&gt;:	leaveq</span><br><span class="line">   0x0000555555554817 &lt;+109&gt;:	retq</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>
<p>注意testObj.SetNumber(200)和testObj.GetNumber()的调用都是直接调用,用的<br>callq  0x55555555482a和callq  0x555555554818.</p>
<blockquote>
<p>  直接调用这样不能多态,举一个有继承的例子,override虚函数的例子?</p>
</blockquote>
<p>CVirtual::SetNumber(int)的汇编分析,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disassemble 0x55555555482a</span><br><span class="line">Dump of assembler code for function CVirtual::SetNumber(int):</span><br><span class="line">   0x000055555555482a &lt;+0&gt;:	push   %rbp</span><br><span class="line">   0x000055555555482b &lt;+1&gt;:	mov    %rsp,%rbp</span><br><span class="line">   0x000055555555482e &lt;+4&gt;:	mov    %rdi,-0x8(%rbp)  # 第一个参数this指针放入-0x8(%rbp)</span><br><span class="line">   0x0000555555554832 &lt;+8&gt;:	mov    %esi,-0xc(%rbp)  # %esi是第二个参数,如果是</span><br><span class="line">   													  	# SetNumerber(200),%esi里面就是200</span><br><span class="line">   0x0000555555554835 &lt;+11&gt;:	mov    -0x8(%rbp),%rax  </span><br><span class="line">   0x0000555555554839 &lt;+15&gt;:	mov    -0xc(%rbp),%edx</span><br><span class="line">   0x000055555555483c &lt;+18&gt;:	mov    %edx,0x8(%rax)  # 把第二个参数里面要设置的值放入</span><br><span class="line">   												# 0x8(%rax), 即对象的首地址偏移8个字节的位置.</span><br><span class="line">   												# 即private变量_nNumber的位置.</span><br><span class="line">   0x000055555555483f &lt;+21&gt;:	nop</span><br><span class="line">   0x0000555555554840 &lt;+22&gt;:	pop    %rbp</span><br><span class="line">   0x0000555555554841 &lt;+23&gt;:	retq</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>
<h3 id="object指针-用’-gt-’-和引用-‘ref-’-调用"><a href="#object指针-用’-gt-’-和引用-‘ref-’-调用" class="headerlink" title="object指针(用’-&gt;’)和引用(‘ref.’)调用"></a>object指针(用’-&gt;’)和引用(‘ref.’)调用</h3><p>下面比较下直接对象调用(用’.’)和指针调用和引用调用的区别?</p>
<h4 id="指针调用"><a href="#指针调用" class="headerlink" title="指针调用"></a>指针调用</h4><p>先指针调用分析</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CVirtual</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">GetNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> _nNumber;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SetNumber</span><span class="params">(<span class="keyword">int</span> nNumber)</span> </span>&#123;</span><br><span class="line">      _nNumber = nNumber;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> _nNumber;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CVirtual *ptestObj = <span class="keyword">new</span> CVirtual();</span><br><span class="line">    ptestObj-&gt;SetNumber(<span class="number">200</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\r\n"</span>, ptestObj-&gt;GetNumber());</span><br><span class="line">    <span class="keyword">delete</span> ptestObj;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disassemble main</span><br><span class="line">Dump of assembler code for function main():</span><br><span class="line">   0x00005555555547fa &lt;+0&gt;:	push   %rbp</span><br><span class="line">   0x00005555555547fb &lt;+1&gt;:	mov    %rsp,%rbp</span><br><span class="line">   0x00005555555547fe &lt;+4&gt;:	push   %rbx</span><br><span class="line">   0x00005555555547ff &lt;+5&gt;:	sub    $0x18,%rsp</span><br><span class="line">=&gt; 0x0000555555554803 &lt;+9&gt;:	mov    $0x10,%edi</span><br><span class="line">   0x0000555555554808 &lt;+14&gt;:	callq  0x5555555546c0 &lt;_Znwm@plt&gt;</span><br><span class="line">   0x000055555555480d &lt;+19&gt;:	mov    %rax,%rbx</span><br><span class="line">   0x0000555555554810 &lt;+22&gt;:	movq   $0x0,(%rbx)</span><br><span class="line">   0x0000555555554817 &lt;+29&gt;:	movl   $0x0,0x8(%rbx)</span><br><span class="line">   0x000055555555481e &lt;+36&gt;:	mov    %rbx,%rdi</span><br><span class="line">   0x0000555555554821 &lt;+39&gt;:	callq  0x5555555548b4 &lt;CVirtual::CVirtual()&gt;</span><br><span class="line">   0x0000555555554826 &lt;+44&gt;:	mov    %rbx,-0x18(%rbp)   # this指针</span><br><span class="line">   0x000055555555482a &lt;+48&gt;:	mov    -0x18(%rbp),%rax	  # %rax现在存的是对象的首地址</span><br><span class="line">   0x000055555555482e &lt;+52&gt;:	mov    (%rax),%rax		  # 把对象首地址指向的东西(即vptr)放入rax</span><br><span class="line">   0x0000555555554831 &lt;+55&gt;:	add    $0x8,%rax		  # vptr + 8, </span><br><span class="line">   # 原因在于SetNumber(int)类中声明顺序在GetNumber()后面,所以在vtbl里在GetNumber()后面,</span><br><span class="line">   # 而vtbl是一个个函数指针组成的列表.x86-64一个指针占8字节,所以vptr + 8</span><br><span class="line">   0x0000555555554835 &lt;+59&gt;:	mov    (%rax),%rax		  # 找到位置了,然后把vptr + 8这个位置的对应的函数指针取出来放入rax</span><br><span class="line">   0x0000555555554838 &lt;+62&gt;:	mov    -0x18(%rbp),%rdx</span><br><span class="line">   0x000055555555483c &lt;+66&gt;:	mov    $0xc8,%esi		  # 第二个参数200即0xc8</span><br><span class="line">   0x0000555555554841 &lt;+71&gt;:	mov    %rdx,%rdi		  # this指针送入%rdi</span><br><span class="line">   0x0000555555554844 &lt;+74&gt;:	callq  *%rax # 调用SetNumber(int)</span><br><span class="line">   0x0000555555554846 &lt;+76&gt;:	mov    -0x18(%rbp),%rax</span><br><span class="line">   0x000055555555484a &lt;+80&gt;:	mov    (%rax),%rax   # 把对象首地址指向的东西(即vptr)放入rax</span><br><span class="line">   0x000055555555484d &lt;+83&gt;:	mov    (%rax),%rax   # 把vptr + 0这个位置的对应的函数指针取出来放入rax, 即GetNumber()</span><br><span class="line">   0x0000555555554850 &lt;+86&gt;:	mov    -0x18(%rbp),%rdx</span><br><span class="line">   0x0000555555554854 &lt;+90&gt;:	mov    %rdx,%rdi</span><br><span class="line">   0x0000555555554857 &lt;+93&gt;:	callq  *%rax</span><br><span class="line">   0x0000555555554859 &lt;+95&gt;:	mov    %eax,%esi</span><br><span class="line">   0x000055555555485b &lt;+97&gt;:	lea    0xf2(%rip),%rdi        # 0x555555554954</span><br><span class="line">   0x0000555555554862 &lt;+104&gt;:	mov    $0x0,%eax</span><br><span class="line">   0x0000555555554867 &lt;+109&gt;:	callq  0x5555555546b0 &lt;printf@plt&gt;</span><br><span class="line">   0x000055555555486c &lt;+114&gt;:	mov    -0x18(%rbp),%rax</span><br><span class="line">   0x0000555555554870 &lt;+118&gt;:	mov    $0x10,%esi</span><br><span class="line">   0x0000555555554875 &lt;+123&gt;:	mov    %rax,%rdi</span><br><span class="line">   0x0000555555554878 &lt;+126&gt;:	callq  0x5555555546d0 &lt;_ZdlPvm@plt&gt;</span><br><span class="line">   0x000055555555487d &lt;+131&gt;:	mov    $0x0,%eax</span><br><span class="line">   0x0000555555554882 &lt;+136&gt;:	add    $0x18,%rsp</span><br><span class="line">   0x0000555555554886 &lt;+140&gt;:	pop    %rbx</span><br><span class="line">   0x0000555555554887 &lt;+141&gt;:	pop    %rbp</span><br><span class="line">   0x0000555555554888 &lt;+142&gt;:	retq</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>
<h4 id="引用调用"><a href="#引用调用" class="headerlink" title="引用调用"></a>引用调用</h4><p>引用调用分析,</p>
<p>本来以为这样就会像指针那样间接调用了.没想到不是…C++代码如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CVirtual</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">GetNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> _nNumber;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SetNumber</span><span class="params">(<span class="keyword">int</span> nNumber)</span> </span>&#123;</span><br><span class="line">      _nNumber = nNumber;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> _nNumber;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CVirtual testObj;</span><br><span class="line">    CVirtual &amp;rtestObj = testObj;</span><br><span class="line">    rtestObj.SetNumber(<span class="number">200</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\r\n"</span>, rtestObj.GetNumber());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>反汇编之后,发现这不和object直接调用(用’.’)几乎一样吗…<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disassemble main</span><br><span class="line">Dump of assembler code for function main():</span><br><span class="line">   0x00005555555547aa &lt;+0&gt;:	push   %rbp</span><br><span class="line">   0x00005555555547ab &lt;+1&gt;:	mov    %rsp,%rbp</span><br><span class="line">   0x00005555555547ae &lt;+4&gt;:	sub    $0x30,%rsp</span><br><span class="line">=&gt; 0x00005555555547b2 &lt;+8&gt;:	mov    %fs:0x28,%rax  # ?</span><br><span class="line">   0x00005555555547bb &lt;+17&gt;:	mov    %rax,-0x8(%rbp)</span><br><span class="line">   0x00005555555547bf &lt;+21&gt;:	xor    %eax,%eax</span><br><span class="line">   0x00005555555547c1 &lt;+23&gt;:	lea    -0x20(%rbp),%rax</span><br><span class="line">   0x00005555555547c5 &lt;+27&gt;:	mov    %rax,%rdi</span><br><span class="line">   0x00005555555547c8 &lt;+30&gt;:	callq  0x55555555484a &lt;CVirtual::CVirtual()&gt;</span><br><span class="line">   0x00005555555547cd &lt;+35&gt;:	lea    -0x20(%rbp),%rax  # object地址送入rax</span><br><span class="line">   0x00005555555547d1 &lt;+39&gt;:	mov    %rax,-0x28(%rbp)  # 建立引用rtestObj,即-0x28(%rbp)</span><br><span class="line">   0x00005555555547d5 &lt;+43&gt;:	mov    -0x28(%rbp),%rax  # 下面的代码等同于直接对象调用(用&apos;.&apos;的那种)</span><br><span class="line">   0x00005555555547d9 &lt;+47&gt;:	mov    $0xc8,%esi</span><br><span class="line">   0x00005555555547de &lt;+52&gt;:	mov    %rax,%rdi</span><br><span class="line">   0x00005555555547e1 &lt;+55&gt;:	callq  0x555555554832 &lt;CVirtual::SetNumber(int)&gt;</span><br><span class="line">   0x00005555555547e6 &lt;+60&gt;:	mov    -0x28(%rbp),%rax</span><br><span class="line">   0x00005555555547ea &lt;+64&gt;:	mov    %rax,%rdi</span><br><span class="line">   0x00005555555547ed &lt;+67&gt;:	callq  0x555555554820 &lt;CVirtual::GetNumber()&gt;</span><br><span class="line">   0x00005555555547f2 &lt;+72&gt;:	mov    %eax,%esi</span><br><span class="line">   0x00005555555547f4 &lt;+74&gt;:	lea    0xf9(%rip),%rdi        # 0x5555555548f4</span><br><span class="line">   0x00005555555547fb &lt;+81&gt;:	mov    $0x0,%eax</span><br><span class="line">   0x0000555555554800 &lt;+86&gt;:	callq  0x555555554670 &lt;printf@plt&gt;</span><br><span class="line">   0x0000555555554805 &lt;+91&gt;:	mov    $0x0,%eax</span><br><span class="line">   0x000055555555480a &lt;+96&gt;:	mov    -0x8(%rbp),%rdx</span><br><span class="line">   0x000055555555480e &lt;+100&gt;:	xor    %fs:0x28,%rdx</span><br><span class="line">   0x0000555555554817 &lt;+109&gt;:	je     0x55555555481e &lt;main()+116&gt;</span><br><span class="line">   0x0000555555554819 &lt;+111&gt;:	callq  0x555555554680 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">   0x000055555555481e &lt;+116&gt;:	leaveq</span><br><span class="line">   0x000055555555481f &lt;+117&gt;:	retq</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure></p>
<p>但是改成堆对象后</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CVirtual</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">GetNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> _nNumber;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SetNumber</span><span class="params">(<span class="keyword">int</span> nNumber)</span> </span>&#123;</span><br><span class="line">      _nNumber = nNumber;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> _nNumber;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CVirtual *ptestObj = <span class="keyword">new</span> CVirtual();</span><br><span class="line">    CVirtual &amp;rtestObj = *ptestObj;</span><br><span class="line">    rtestObj.SetNumber(<span class="number">200</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\r\n"</span>, rtestObj.GetNumber());</span><br><span class="line">    <span class="keyword">delete</span> ptestObj;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>反汇编之后,这种和指针调用虚函数的方法一样,都是间接调用,拿到对象的vptr指向的函数指针表里面的某一项.然后调用它.(callq  *%rax)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disassemble main</span><br><span class="line">Dump of assembler code for function main():</span><br><span class="line">   0x00005555555547fa &lt;+0&gt;:	push   %rbp</span><br><span class="line">   0x00005555555547fb &lt;+1&gt;:	mov    %rsp,%rbp</span><br><span class="line">   0x00005555555547fe &lt;+4&gt;:	push   %rbx</span><br><span class="line">   0x00005555555547ff &lt;+5&gt;:	sub    $0x18,%rsp</span><br><span class="line">=&gt; 0x0000555555554803 &lt;+9&gt;:	mov    $0x10,%edi</span><br><span class="line">   0x0000555555554808 &lt;+14&gt;:	callq  0x5555555546c0 &lt;_Znwm@plt&gt; # 这里应该是分配堆内存的那个函数</span><br><span class="line">   0x000055555555480d &lt;+19&gt;:	mov    %rax,%rbx  # 返回的指针存在了%rax,然后送入%rbx</span><br><span class="line">   0x0000555555554810 &lt;+22&gt;:	movq   $0x0,(%rbx)</span><br><span class="line">   0x0000555555554817 &lt;+29&gt;:	movl   $0x0,0x8(%rbx)</span><br><span class="line">   0x000055555555481e &lt;+36&gt;:	mov    %rbx,%rdi</span><br><span class="line">   0x0000555555554821 &lt;+39&gt;:	callq  0x5555555548bc &lt;CVirtual::CVirtual()&gt; # 调用构造函数</span><br><span class="line">   0x0000555555554826 &lt;+44&gt;:	mov    %rbx,-0x20(%rbp)  # rbx存的即是ptestObj指针吧.</span><br><span class="line">   								# -0x20(%rbp)是rtestObj这个引用占的8字节的首地址?</span><br><span class="line">   0x000055555555482a &lt;+48&gt;:	mov    -0x20(%rbp),%rax</span><br><span class="line">   0x000055555555482e &lt;+52&gt;:	mov    %rax,-0x18(%rbp)  </span><br><span class="line">   								# 下面的逻辑和指针调用分析的一样了...本质是因为引用和指针在汇编这个层面看,引用由指针实现(感觉这句话不严谨?汇编层面的指针就是一个8字节的地址,关键看反汇编的代码吧.一下就明白了).</span><br><span class="line">   0x0000555555554832 &lt;+56&gt;:	mov    -0x18(%rbp),%rax</span><br><span class="line">   0x0000555555554836 &lt;+60&gt;:	mov    (%rax),%rax</span><br><span class="line">   0x0000555555554839 &lt;+63&gt;:	add    $0x8,%rax</span><br><span class="line">   0x000055555555483d &lt;+67&gt;:	mov    (%rax),%rax</span><br><span class="line">   0x0000555555554840 &lt;+70&gt;:	mov    -0x18(%rbp),%rdx</span><br><span class="line">   0x0000555555554844 &lt;+74&gt;:	mov    $0xc8,%esi</span><br><span class="line">   0x0000555555554849 &lt;+79&gt;:	mov    %rdx,%rdi</span><br><span class="line">   0x000055555555484c &lt;+82&gt;:	callq  *%rax</span><br><span class="line">   0x000055555555484e &lt;+84&gt;:	mov    -0x18(%rbp),%rax</span><br><span class="line">   0x0000555555554852 &lt;+88&gt;:	mov    (%rax),%rax</span><br><span class="line">   0x0000555555554855 &lt;+91&gt;:	mov    (%rax),%rax</span><br><span class="line">   0x0000555555554858 &lt;+94&gt;:	mov    -0x18(%rbp),%rdx</span><br><span class="line">   0x000055555555485c &lt;+98&gt;:	mov    %rdx,%rdi</span><br><span class="line">   0x000055555555485f &lt;+101&gt;:	callq  *%rax</span><br><span class="line">   0x0000555555554861 &lt;+103&gt;:	mov    %eax,%esi</span><br><span class="line">   0x0000555555554863 &lt;+105&gt;:	lea    0xfa(%rip),%rdi        # 0x555555554964</span><br><span class="line">   0x000055555555486a &lt;+112&gt;:	mov    $0x0,%eax</span><br><span class="line">   0x000055555555486f &lt;+117&gt;:	callq  0x5555555546b0 &lt;printf@plt&gt;</span><br><span class="line">   0x0000555555554874 &lt;+122&gt;:	mov    -0x20(%rbp),%rax</span><br><span class="line">   0x0000555555554878 &lt;+126&gt;:	mov    $0x10,%esi</span><br><span class="line">   0x000055555555487d &lt;+131&gt;:	mov    %rax,%rdi</span><br><span class="line">   0x0000555555554880 &lt;+134&gt;:	callq  0x5555555546d0 &lt;_ZdlPvm@plt&gt; # delete</span><br><span class="line">   0x0000555555554885 &lt;+139&gt;:	mov    $0x0,%eax</span><br><span class="line">   0x000055555555488a &lt;+144&gt;:	add    $0x18,%rsp</span><br><span class="line">   0x000055555555488e &lt;+148&gt;:	pop    %rbx</span><br><span class="line">   0x000055555555488f &lt;+149&gt;:	pop    %rbp</span><br><span class="line">   0x0000555555554890 &lt;+150&gt;:	retq</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>
<p>最终就两种调用方式.</p>
<p>callq  0x555555554832 和 callq  *%rax</p>
<p>分别是直接调用和间接调用,只有callq  *%rax这种间接方式是查vptr指向的虚函数表,然后找到函数指针后调用相应函数的,也就是虚函数实现C++多态的关键…(有个问题,这么做的话,性能上打折扣吗???)</p>
<hr>
<h3 id="析构函数与vptr"><a href="#析构函数与vptr" class="headerlink" title="析构函数与vptr"></a>析构函数与vptr</h3><blockquote>
<p>  反汇编与逆向分析技术揭秘11.1节P261最后几段话,没太明白,关键应该是要结合继承来分析…待看吧…</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CVirtual</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">GetNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> _nNumber;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SetNumber</span><span class="params">(<span class="keyword">int</span> nNumber)</span> </span>&#123;</span><br><span class="line">      _nNumber = nNumber;</span><br><span class="line">  &#125;</span><br><span class="line">  ~CVirtual() &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"~CVirtual()\n"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> _nNumber;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CVirtual testObj;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disassemble main</span><br><span class="line">Dump of assembler code for function main():</span><br><span class="line">   0x00005555555547ea &lt;+0&gt;:	push   %rbp</span><br><span class="line">   0x00005555555547eb &lt;+1&gt;:	mov    %rsp,%rbp</span><br><span class="line">   0x00005555555547ee &lt;+4&gt;:	push   %rbx</span><br><span class="line">   0x00005555555547ef &lt;+5&gt;:	sub    $0x28,%rsp</span><br><span class="line">=&gt; 0x00005555555547f3 &lt;+9&gt;:	mov    %fs:0x28,%rax</span><br><span class="line">   0x00005555555547fc &lt;+18&gt;:	mov    %rax,-0x18(%rbp)</span><br><span class="line">   0x0000555555554800 &lt;+22&gt;:	xor    %eax,%eax</span><br><span class="line">   0x0000555555554802 &lt;+24&gt;:	lea    -0x30(%rbp),%rax</span><br><span class="line">   0x0000555555554806 &lt;+28&gt;:	mov    %rax,%rdi</span><br><span class="line">   0x0000555555554809 &lt;+31&gt;:	callq  0x555555554890 &lt;CVirtual::CVirtual()&gt;</span><br><span class="line">   0x000055555555480e &lt;+36&gt;:	mov    $0x0,%ebx</span><br><span class="line">   0x0000555555554813 &lt;+41&gt;:	lea    -0x30(%rbp),%rax</span><br><span class="line">   0x0000555555554817 &lt;+45&gt;:	mov    %rax,%rdi  # this指针</span><br><span class="line">   0x000055555555481a &lt;+48&gt;:	callq  0x555555554866 &lt;CVirtual::~CVirtual()&gt;</span><br><span class="line">   0x000055555555481f &lt;+53&gt;:	mov    %ebx,%eax</span><br><span class="line">   0x0000555555554821 &lt;+55&gt;:	mov    -0x18(%rbp),%rdx  # 后面的这些什么作用?</span><br><span class="line">   0x0000555555554825 &lt;+59&gt;:	xor    %fs:0x28,%rdx</span><br><span class="line">   0x000055555555482e &lt;+68&gt;:	je     0x555555554835 &lt;main()+75&gt;</span><br><span class="line">   0x0000555555554830 &lt;+70&gt;:	callq  0x5555555546b0 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">   0x0000555555554835 &lt;+75&gt;:	add    $0x28,%rsp</span><br><span class="line">   0x0000555555554839 &lt;+79&gt;:	pop    %rbx</span><br><span class="line">   0x000055555555483a &lt;+80&gt;:	pop    %rbp</span><br><span class="line">   0x000055555555483b &lt;+81&gt;:	retq</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disassemble 0x555555554866  # callq  0x555555554866 &lt;CVirtual::~CVirtual()&gt;</span><br><span class="line">Dump of assembler code for function CVirtual::~CVirtual():</span><br><span class="line">   0x0000555555554866 &lt;+0&gt;:	push   %rbp</span><br><span class="line">   0x0000555555554867 &lt;+1&gt;:	mov    %rsp,%rbp</span><br><span class="line">   0x000055555555486a &lt;+4&gt;:	sub    $0x10,%rsp</span><br><span class="line">   0x000055555555486e &lt;+8&gt;:	mov    %rdi,-0x8(%rbp)  # this指针存入-0x8(%rbp)</span><br><span class="line">   0x0000555555554872 &lt;+12&gt;:	lea    0x200517(%rip),%rdx        # 0x555555754d90 &lt;_ZTV8CVirtual+16&gt;									   # 虚表地址放入%rdx</span><br><span class="line">   														# 0x555555754d90是虚表地址</span><br><span class="line">   0x0000555555554879 &lt;+19&gt;:	mov    -0x8(%rbp),%rax</span><br><span class="line">   0x000055555555487d &lt;+23&gt;:	mov    %rdx,(%rax)		# 虚表地址放入this指针指的那个对象的vptr?啥?那岂不是和构造函数干了一样的事情?</span><br><span class="line">   # 又是把虚表首地址赋值到对应对象的虚表指针中</span><br><span class="line">   0x0000555555554880 &lt;+26&gt;:	lea    0xad(%rip),%rdi        # 0x555555554934</span><br><span class="line">   0x0000555555554887 &lt;+33&gt;:	callq  0x5555555546c0 &lt;puts@plt&gt;</span><br><span class="line">   0x000055555555488c &lt;+38&gt;:	nop</span><br><span class="line">   0x000055555555488d &lt;+39&gt;:	leaveq</span><br><span class="line">   0x000055555555488e &lt;+40&gt;:	retq</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>
<p>这个析构的汇编分析尤其是写入虚表指针那里,不明白!!!这里的弄清楚的线索在反汇编与逆向分析技术揭秘11.1节最后几段话.关键应该是要结合继承来分析…</p>
<p>有合成的析构函数吧?有,见C++Primer13.1.3.之前见过,记不得了…<br>如果改成</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CVirtual</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">GetNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> _nNumber;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SetNumber</span><span class="params">(<span class="keyword">int</span> nNumber)</span> </span>&#123;</span><br><span class="line">      _nNumber = nNumber;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//~CVirtual() &#123;</span></span><br><span class="line">  <span class="comment">//    printf("~CVirtual()\n");</span></span><br><span class="line">  <span class="comment">//&#125;</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> _nNumber;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CVirtual testObj;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>回到不显式定义析构函数的时候.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disassemble main</span><br><span class="line">Dump of assembler code for function main():</span><br><span class="line">   0x000055555555475a &lt;+0&gt;:	push   %rbp</span><br><span class="line">   0x000055555555475b &lt;+1&gt;:	mov    %rsp,%rbp</span><br><span class="line">   0x000055555555475e &lt;+4&gt;:	sub    $0x20,%rsp</span><br><span class="line">=&gt; 0x0000555555554762 &lt;+8&gt;:	mov    %fs:0x28,%rax</span><br><span class="line">   0x000055555555476b &lt;+17&gt;:	mov    %rax,-0x8(%rbp)</span><br><span class="line">   0x000055555555476f &lt;+21&gt;:	xor    %eax,%eax</span><br><span class="line">   0x0000555555554771 &lt;+23&gt;:	lea    -0x20(%rbp),%rax</span><br><span class="line">   0x0000555555554775 &lt;+27&gt;:	mov    %rax,%rdi</span><br><span class="line">   0x0000555555554778 &lt;+30&gt;:	callq  0x5555555547c2 &lt;CVirtual::CVirtual()&gt;</span><br><span class="line">   0x000055555555477d &lt;+35&gt;:	mov    $0x0,%eax</span><br><span class="line">   0x0000555555554782 &lt;+40&gt;:	mov    -0x8(%rbp),%rdx</span><br><span class="line">   0x0000555555554786 &lt;+44&gt;:	xor    %fs:0x28,%rdx</span><br><span class="line">   0x000055555555478f &lt;+53&gt;:	je     0x555555554796 &lt;main()+60&gt;</span><br><span class="line">   0x0000555555554791 &lt;+55&gt;:	callq  0x555555554630 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">   0x0000555555554796 &lt;+60&gt;:	leaveq</span><br><span class="line">   0x0000555555554797 &lt;+61&gt;:	retq</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>
<p>在main里面没调用析构函数?被编译器优化了???关优化试试.<br>析构这里有没有类似构造的RVO的g++ -fno-elide-constructors这样的东西?强制不优化,执行析构函数.<br>这里结合Effective Modern C++的有一小节来看(讲编译器在背后帮你实现了哪些copy control函数那节,主要这里有C++11的,而Effective C++里面只没有移动版本copy control函数的分析).先放着吧…</p>
<p>参考:</p>
<p>1.反汇编与逆向分析技术揭秘</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://mojiajun.github.io/post/18ee0c7.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mojiajun">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mojiajun">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/post/18ee0c7.html" itemprop="url">mit6828-内联汇编-xv6-xchg-spinlock</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-07-10T00:00:00+08:00">
                2019-07-10
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OS/" itemprop="url" rel="index">
                    <span itemprop="name">OS</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OS/xv6/" itemprop="url" rel="index">
                    <span itemprop="name">xv6</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>[TOC]</p>
<h2 id="inline-assembly"><a href="#inline-assembly" class="headerlink" title="inline assembly"></a>inline assembly</h2><p>入门:<a href="https://blog.csdn.net/slvher/article/details/8864996" target="_blank" rel="noopener">【Linux学习笔记】Linux C中内联汇编的语法格式及使用方法（Inline Assembly in Linux C）</a>这个讲的比较好了.更全面的得查类似<a href="http://www.ibiblio.org/gferg/ldp/GCC-Inline-Assembly-HOWTO.html#ss5.1" target="_blank" rel="noopener">GCC-Inline-Assembly-HOWTO</a>这种</p>
<p>inline assembly感觉细节好多…下次看估计又忘了…</p>
<hr>
<p>用1对双引号将多行命令括起来 加”;”分号?<br>clobbered register修饰寄存器?修饰?<br><a href="https://en.wikipedia.org/wiki/Inline_assembler" target="_blank" rel="noopener">Inline assembler</a>里面有个用汇编求tan(x)的例子,待看,感觉挺有趣.</p>
<hr>
<p>当我们不想通过寄存器中转，而是直接操作内存时，可以用”m”来约束。例如：<br>asm volatile ( “lock; decl %0” : “=m” (counter) : “m” (counter));<br>该指令实现原子减一操作，输入、输出操作数均直接来自内存（<strong>也正因如此，才能保证操作的原子性</strong>）。 </p>
<blockquote>
<p>  也正因如此，才能保证操作的原子性,更底层细节?这是是保证原子性的关键吗?结合后面的xv6的xchg函数实现.<br>  3个东西.1是lock前缀,2是+代表read-modify-write,3是”m”直接操作内存</p>
</blockquote>
<p>“=的意思” output operand应该有个”=”,1.说明这个是输出操作数,2.write-only</p>
<ul>
<li>“r” is a constraint on the operands. We’ll see constraints in detail later. For the time being, “r” says to GCC to use any register for storing the operands. output operand constraint should have a constraint modifier “=”. And this modifier says that it is the output operand and is write-only.</li>
</ul>
<p>“cc”的意思</p>
<p>If our instruction can alter the condition code register, we have to add “cc” to the list of clobbered registers.s</p>
<hr>
<h2 id="xv6的xchg函数"><a href="#xv6的xchg函数" class="headerlink" title="xv6的xchg函数"></a>xv6的xchg函数</h2><p>static inline uint<br>xchg(volatile uint <em>addr, uint newval)
</em>交换<em>addr和newval,然后把</em>addr的原先的值作为result返回!!!这只是从C层面可以这么从逻辑上理解.实际编译器干的有些区别,但是最终结果一致.<br>范例:见后面</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> uint</span><br><span class="line">xchg(<span class="keyword">volatile</span> uint *addr, uint newval)</span><br><span class="line">&#123;</span><br><span class="line">  uint result;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The + in "+m" denotes a read-modify-write operand.</span></span><br><span class="line">  <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">"lock; xchgl %0, %1"</span> :</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="string">"+m"</span> (*addr), <span class="string">"=a"</span> (result) :</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="string">"1"</span> (newval) :</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="string">"cc"</span>)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这个"1"感觉是代表对应前面的%1,指定位置的作用?没仔细查...猜的</span></span><br><span class="line">kernel.<span class="keyword">asm</span>:</span><br><span class="line"> <span class="number">8515</span>   <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">"lock; xchgl %0, %1"</span> :</span></span></span><br><span class="line"><span class="function"><span class="params"> <span class="number">8516</span> <span class="number">80104373</span>:       ba <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          mov    $<span class="number">0x1</span>,%edx</span></span></span><br><span class="line"><span class="function"><span class="params"> <span class="number">8517</span> <span class="number">80104378</span>:       eb <span class="number">09</span>                   jmp    <span class="number">80104383</span> &lt;acquire+<span class="number">0x33</span>&gt;</span></span></span><br><span class="line"><span class="function"><span class="params"> <span class="number">8518</span> <span class="number">8010437</span>a:       <span class="number">8</span>d b6 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       lea    <span class="number">0x0</span>(%esi),%esi</span></span></span><br><span class="line"><span class="function"><span class="params"> <span class="number">8519</span> <span class="number">80104380</span>:       <span class="number">8b</span> <span class="number">5</span>d <span class="number">08</span>                mov    <span class="number">0x8</span>(%ebp),%ebx</span></span></span><br><span class="line"><span class="function"><span class="params"> <span class="number">8520</span> <span class="number">80104383</span>:       <span class="number">89</span> d0                   mov    %edx,%eax</span></span></span><br><span class="line"><span class="function"><span class="params"> <span class="number">8521</span> <span class="number">80104385</span>:       f0 <span class="number">87</span> <span class="number">03</span>                lock xchg %eax,(%ebx)</span></span></span><br><span class="line"><span class="function"><span class="params"> <span class="number">8522</span>   <span class="keyword">while</span>(xchg(&amp;lk-&gt;locked, <span class="number">1</span>) != <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"><span class="params"> <span class="number">8523</span> <span class="number">80104388</span>:       <span class="number">85</span> c0                   test   %eax,%eax</span></span></span><br><span class="line"><span class="function"><span class="params"> <span class="number">8524</span> <span class="number">8010438</span>a:       <span class="number">75</span> f4                   jne    <span class="number">80104380</span> &lt;acquire+<span class="number">0x30</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>在实际运行的汇编代码里面为什么顺序又变了?前后的顺序?<br>猜测:这部分代码还是得根据实际运行的情况来看,test   %eax,%eax,即测试的是eax,而且”=a” (result) :<br>所以eax存的是交换之后的值,那么在交换之前,存在是newval<br>根据lock; xchgl (<em>addr), newval字面来套是这样的.因为eax得存交换后的值,所以eax交换前存的是newval<br>所以lock; xchgl (</em>addr), eax,然后就和实际运行看到的相反了…这个过程是编译器给做的.并不太清楚编译器寄存器分配<br>规则…</p>
<p>附上前后的其他东西,便于数那个&lt;acquire+0x30&gt;的位置十进制数偏移48,jne    80104380 &lt;acquire+0x30&gt;跳转到lea    0x0(%esi),%esi</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">8498</span> <span class="number">80104350</span> &lt;acquire&gt;:</span><br><span class="line"><span class="number">8499</span> &#123;</span><br><span class="line"><span class="number">8500</span> <span class="number">80104350</span>:       <span class="number">55</span>                      push   %ebp</span><br><span class="line"><span class="number">8501</span> <span class="number">80104351</span>:       <span class="number">89</span> e5                   mov    %esp,%ebp</span><br><span class="line"><span class="number">8502</span> <span class="number">80104353</span>:       <span class="number">56</span>                      push   %esi</span><br><span class="line"><span class="number">8503</span> <span class="number">80104354</span>:       <span class="number">53</span>                      push   %ebx</span><br><span class="line"><span class="number">8504</span>   pushcli(); <span class="comment">// disable interrupts to avoid deadlock.</span></span><br><span class="line"><span class="number">8505</span> <span class="number">80104355</span>:       e8 <span class="number">26</span> ff ff ff          call   <span class="number">80104280</span> &lt;pushcli&gt;</span><br><span class="line"><span class="number">8506</span>   <span class="keyword">if</span>(holding(lk))</span><br><span class="line"><span class="number">8507</span> <span class="number">8010435</span>a:       <span class="number">8b</span> <span class="number">5</span>d <span class="number">08</span>                mov    <span class="number">0x8</span>(%ebp),%ebx</span><br><span class="line"><span class="number">8508</span> <span class="number">8010435</span>d:       <span class="number">83</span> ec <span class="number">0</span>c                sub    $<span class="number">0xc</span>,%esp</span><br><span class="line"><span class="number">8509</span> <span class="number">80104360</span>:       <span class="number">53</span>                      push   %ebx</span><br><span class="line"><span class="number">8510</span> <span class="number">80104361</span>:       e8 ba ff ff ff          call   <span class="number">80104320</span> &lt;holding&gt;</span><br><span class="line"><span class="number">8511</span> <span class="number">80104366</span>:       <span class="number">83</span> c4 <span class="number">10</span>                add    $<span class="number">0x10</span>,%esp</span><br><span class="line"><span class="number">8512</span> <span class="number">80104369</span>:       <span class="number">85</span> c0                   test   %eax,%eax</span><br><span class="line"><span class="number">8513</span> <span class="number">8010436b</span>:       <span class="number">0f</span> <span class="number">85</span> <span class="number">83</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       jne    <span class="number">801043f</span>4 &lt;acquire+<span class="number">0xa4</span>&gt;</span><br><span class="line"><span class="number">8514</span> <span class="number">80104371</span>:       <span class="number">89</span> c6                   mov    %eax,%esi</span><br><span class="line"><span class="number">8515</span>   <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">"lock; xchgl %0, %1"</span> :   </span></span></span><br><span class="line"><span class="function"><span class="params"><span class="number">8516</span> <span class="number">80104373</span>:       ba <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          mov    $<span class="number">0x1</span>,%edx</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="number">8517</span> <span class="number">80104378</span>:       eb <span class="number">09</span>                   jmp    <span class="number">80104383</span> &lt;acquire+<span class="number">0x33</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<h2 id="xchg-使用案例-xv6的spinlock的acquire和release"><a href="#xchg-使用案例-xv6的spinlock的acquire和release" class="headerlink" title="xchg()使用案例,xv6的spinlock的acquire和release"></a>xchg()使用案例,xv6的spinlock的acquire和release</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">acquire(struct spinlock *lk)</span><br><span class="line">&#123;</span><br><span class="line">  pushcli(); <span class="comment">// disable interrupts to avoid deadlock.</span></span><br><span class="line">  <span class="keyword">if</span>(holding(lk))</span><br><span class="line">    panic(<span class="string">"acquire"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The xchg is atomic.</span></span><br><span class="line">  <span class="keyword">while</span>(xchg(&amp;lk-&gt;locked, <span class="number">1</span>) != <span class="number">0</span>)</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Tell the C compiler and the processor to not move loads or stores</span></span><br><span class="line">  <span class="comment">// past this point, to ensure that the critical section's memory</span></span><br><span class="line">  <span class="comment">// references happen after the lock is acquired.</span></span><br><span class="line">  __sync_synchronize();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Record info about lock acquisition for debugging.</span></span><br><span class="line">  lk-&gt;cpu = mycpu();</span><br><span class="line">  getcallerpcs(&amp;lk, lk-&gt;pcs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Release the lock.</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">release(struct spinlock *lk)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(!holding(lk))</span><br><span class="line">    panic(<span class="string">"release"</span>);</span><br><span class="line"></span><br><span class="line">  lk-&gt;pcs[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  lk-&gt;cpu = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  __sync_synchronize();</span><br><span class="line">  <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">"movl $0, %0"</span> : <span class="string">"+m"</span> (lk-&gt;locked) : )</span></span>;</span><br><span class="line"></span><br><span class="line">  popcli();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">8516</span> <span class="number">80104373</span>:       ba <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          mov    $<span class="number">0x1</span>,%edx</span><br><span class="line"> <span class="number">8517</span> <span class="number">80104378</span>:       eb <span class="number">09</span>                   jmp    <span class="number">80104383</span> &lt;acquire+<span class="number">0x33</span>&gt;</span><br><span class="line"> <span class="number">8518</span> <span class="number">8010437</span>a:       <span class="number">8</span>d b6 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       lea    <span class="number">0x0</span>(%esi),%esi</span><br><span class="line"> <span class="number">8519</span> <span class="number">80104380</span>:       <span class="number">8b</span> <span class="number">5</span>d <span class="number">08</span>                mov    <span class="number">0x8</span>(%ebp),%ebx</span><br><span class="line"> <span class="number">8520</span> <span class="number">80104383</span>:       <span class="number">89</span> d0                   mov    %edx,%eax</span><br><span class="line"> <span class="number">8521</span> <span class="number">80104385</span>:       f0 <span class="number">87</span> <span class="number">03</span>                lock xchg %eax,(%ebx)</span><br><span class="line"> <span class="number">8523</span> <span class="number">80104388</span>:       <span class="number">85</span> c0                   test   %eax,%eax</span><br><span class="line"> <span class="number">8524</span> <span class="number">8010438</span>a:       <span class="number">75</span> f4                   jne    <span class="number">80104380</span> &lt;acquire+<span class="number">0x30</span>&gt;</span><br><span class="line"><span class="comment">// 这八行汇编是底下的这个while循环被编译器编译后处理的结果,</span></span><br><span class="line"><span class="comment">// 在kernel.asm拿到的.详细的见前面的分析.jne    </span></span><br><span class="line"><span class="comment">// 80104380 &lt;acquire+0x30&gt;跳到lea    0x0(%esi),%esi</span></span><br><span class="line">  <span class="keyword">while</span>(xchg(&amp;lk-&gt;locked, <span class="number">1</span>) != <span class="number">0</span>)</span><br><span class="line">    ;</span><br><span class="line"><span class="comment">// 这个就是操作系统教材里面爱提的概念busy wait?</span></span><br><span class="line"><span class="comment">// 在汇编层面实际执行的循环是:</span></span><br><span class="line"> <span class="number">8518</span> <span class="number">8010437</span>a:       <span class="number">8</span>d b6 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       lea    <span class="number">0x0</span>(%esi),%esi</span><br><span class="line"> <span class="number">8519</span> <span class="number">80104380</span>:       <span class="number">8b</span> <span class="number">5</span>d <span class="number">08</span>                mov    <span class="number">0x8</span>(%ebp),%ebx</span><br><span class="line"> <span class="number">8520</span> <span class="number">80104383</span>:       <span class="number">89</span> d0                   mov    %edx,%eax</span><br><span class="line"> <span class="number">8521</span> <span class="number">80104385</span>:       f0 <span class="number">87</span> <span class="number">03</span>                lock xchg %eax,(%ebx)</span><br><span class="line"> <span class="number">8523</span> <span class="number">80104388</span>:       <span class="number">85</span> c0                   test   %eax,%eax</span><br><span class="line"> <span class="number">8524</span> <span class="number">8010438</span>a:       <span class="number">75</span> f4                   jne    <span class="number">80104380</span> &lt;acquire+<span class="number">0x30</span>&gt;</span><br></pre></td></tr></table></figure>
<p>没拿到锁的时候,lk-&gt;locked存的是0,拿到锁后存的是1.<br>情况A:假设lk这把spinlock的locked原来的状态是0,代表当前这把锁还没有被拿到过,然后进入acquire(),xchg()换lk-&gt;locked和1,交换后lk-&gt;locked存的变成1了,代表锁上了.然后从C层面看的话,xchg()返回的结果是lk-&gt;locked()交换之前的值.也就是0,所以while(0 != 0)条件不满足,false,while(false),那么不执行循环语句,在这里是空语句(;).然后执行__sync_synchronize();.代表拿到锁了.<br>情况B:假设lk这把spinlock的locked原来的状态是1,代表当前这把锁已经被拿过了,然后进入acquire(),xchg()换lk-&gt;locked和1,交换后lk-&gt;locked存的仍然是1(1和1交换).然后从C层面看的话,xchg()返回的结果是lk-&gt;locked()交换之前的值.也就是1,所以while(1 != 0)条件满足,true,while(true),那么执行循环语句,在这里是空语句(;)然后再次执行xchg()…还是1和1交换.然后再次执行xchg()…这个就是spinlock的本质!</p>
<h2 id="额外"><a href="#额外" class="headerlink" title="额外"></a>额外</h2><p>1.read-modify-write??</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The + in "+m" denotes a read-modify-write operand.</span></span><br><span class="line">+号在GCC-Inline-Assembly-HOWTO还没找着(没仔细找),还有这个read-modify-write operand,是原子操作的关键所在???!!!</span><br></pre></td></tr></table></figure>
<p>2.研究下busy wait和sleep<br><a href="https://stackoverflow.com/questions/1107593/what-are-trade-offs-for-busy-wait-vs-sleep" target="_blank" rel="noopener">What are trade offs for “busy wait” vs “sleep”?</a>还没看,但是待看…<br>感觉busy wait消耗cpu资源,sleep并没有消耗cpu资源(只是粗略的讲)</p>
<p>3.实际调试下,打断点.在acquire()上</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://mojiajun.github.io/post/11e7222f.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mojiajun">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mojiajun">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/post/11e7222f.html" itemprop="url">redis-项目文件概览</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-28T00:00:00+08:00">
                2019-04-28
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/源码阅读/" itemprop="url" rel="index">
                    <span itemprop="name">源码阅读</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/源码阅读/redis/" itemprop="url" rel="index">
                    <span itemprop="name">redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>[TOC]</p>
<p>基于redis-2.8</p>
<h2 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h2><h3 id="dict-h-c"><a href="#dict-h-c" class="headerlink" title="dict.h.c"></a>dict.h.c</h3><p>dict,hash的实现</p>
<h3 id="adlist-h-c"><a href="#adlist-h-c" class="headerlink" title="adlist.h.c"></a>adlist.h.c</h3><p>通用双向链表?</p>
<h3 id="sds-h-c"><a href="#sds-h-c" class="headerlink" title="sds.h.c"></a>sds.h.c</h3><p>封装了底层的字符串</p>
<h2 id="五种redis对象-基于底层数据结构"><a href="#五种redis对象-基于底层数据结构" class="headerlink" title="五种redis对象(基于底层数据结构)"></a>五种redis对象(基于底层数据结构)</h2><h3 id="t-list-c"><a href="#t-list-c" class="headerlink" title="t_list.c"></a>t_list.c</h3><h3 id="t-set-c"><a href="#t-set-c" class="headerlink" title="t_set.c"></a>t_set.c</h3><h3 id="t-string-c"><a href="#t-string-c" class="headerlink" title="t_string.c"></a>t_string.c</h3><h3 id="t-zset-c"><a href="#t-zset-c" class="headerlink" title="t_zset.c"></a>t_zset.c</h3><h3 id="t-hash-c"><a href="#t-hash-c" class="headerlink" title="t_hash.c"></a>t_hash.c</h3><h2 id="网络有关"><a href="#网络有关" class="headerlink" title="网络有关"></a>网络有关</h2><h3 id="networking-c"><a href="#networking-c" class="headerlink" title="networking.c"></a>networking.c</h3><p>和anet,ae的关系?</p>
<h3 id="anet-h-c"><a href="#anet-h-c" class="headerlink" title="anet.h.c"></a>anet.h.c</h3><p>a代表什么?封装了底层操作系统的socket API</p>
<h3 id="ae-h-c"><a href="#ae-h-c" class="headerlink" title="ae.h.c"></a>ae.h.c</h3><p>简单的事件驱动库,redis的reactor模式的实现</p>
<h4 id="ae-epoll-c-ae-evport-c-ae-kqueue-c-qe-select-c"><a href="#ae-epoll-c-ae-evport-c-ae-kqueue-c-qe-select-c" class="headerlink" title="ae_epoll.c,ae_evport.c,ae_kqueue.c,qe_select.c"></a>ae_epoll.c,ae_evport.c,ae_kqueue.c,qe_select.c</h4><p>这四个文件统一了不同操作系统提供的I/O event notification.<br>拿linux下的ae_epoll.c举例子,其在底层的epoll上面封了一层.</p>
<p>ae.h.c会使用这四种操作系统提供的event notification之一,对于ae.h.c来说,API是统一的.</p>
<h2 id="上层数据库"><a href="#上层数据库" class="headerlink" title="上层数据库"></a>上层数据库</h2><h3 id="redis-h-c"><a href="#redis-h-c" class="headerlink" title="redis.h.c"></a>redis.h.c</h3><p>redisDb是数据库的核心结构体,围绕它有redisClient,redisServer.分配代表客户端和服务器,然后再基于reactor模式,实现了两者之间的通信,典型的C/S架构.</p>
<p>redis.h里面的很多API函数是在其他的一些.c里实现的,不一定在redis.c里.例如redisDb的API函数就是在db.c里实现的.</p>
<h2 id="通用"><a href="#通用" class="headerlink" title="通用"></a>通用</h2><h3 id="zmalloc-h-c"><a href="#zmalloc-h-c" class="headerlink" title="zmalloc.h.c"></a>zmalloc.h.c</h3><p>封装了底层的malloc,calloc,remalloc,free四个函数.提供了可以进行内存分配统计的能力.</p>
<blockquote>
<p>  可以替换掉glibc的内存分配函数,例如可以用jemalloc库代替.有啥优点?</p>
</blockquote>
<h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><h3 id="version-h"><a href="#version-h" class="headerlink" title="version.h"></a>version.h</h3><p>版本号</p>
<h3 id="asciilogo-h"><a href="#asciilogo-h" class="headerlink" title="asciilogo.h"></a>asciilogo.h</h3><p>redis的ascii格式的logo,在服务器启动的时候会显示出来.</p>
<h3 id="config-c"><a href="#config-c" class="headerlink" title="config.c"></a>config.c</h3><p>解析配置文件的实现函数,API接口在redis.h里</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://mojiajun.github.io/post/18ee0d3.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mojiajun">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mojiajun">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/post/18ee0d3.html" itemprop="url">redis-server初始化</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-27T00:00:00+08:00">
                2019-04-27
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/源码阅读/" itemprop="url" rel="index">
                    <span itemprop="name">源码阅读</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/源码阅读/redis/" itemprop="url" rel="index">
                    <span itemprop="name">redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="initServerConfig"><a href="#initServerConfig" class="headerlink" title="initServerConfig()"></a>initServerConfig()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initServerConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">    getRandomHexChars(server.runid,REDIS_RUN_ID_SIZE);</span><br><span class="line">    server.configfile = <span class="literal">NULL</span>;</span><br><span class="line">    server.hz = REDIS_DEFAULT_HZ;</span><br><span class="line">    server.runid[REDIS_RUN_ID_SIZE] = <span class="string">'\0'</span>;</span><br><span class="line">    server.arch_bits = (<span class="keyword">sizeof</span>(<span class="keyword">long</span>) == <span class="number">8</span>) ? <span class="number">64</span> : <span class="number">32</span>;</span><br><span class="line">    server.port = REDIS_SERVERPORT;</span><br><span class="line">    server.bindaddr_count = <span class="number">0</span>;</span><br><span class="line">    server.unixsocket = <span class="literal">NULL</span>;</span><br><span class="line">    server.unixsocketperm = REDIS_DEFAULT_UNIX_SOCKET_PERM;</span><br><span class="line">    server.ipfd_count = <span class="number">0</span>;</span><br><span class="line">    server.sofd = <span class="number">-1</span>;</span><br><span class="line">    server.dbnum = REDIS_DEFAULT_DBNUM;</span><br><span class="line">    server.verbosity = REDIS_DEFAULT_VERBOSITY;</span><br><span class="line">    server.maxidletime = REDIS_MAXIDLETIME;</span><br><span class="line">    server.tcpkeepalive = REDIS_DEFAULT_TCP_KEEPALIVE;</span><br><span class="line">    server.active_expire_enabled = <span class="number">1</span>;</span><br><span class="line">    server.client_max_querybuf_len = REDIS_MAX_QUERYBUF_LEN;</span><br><span class="line">    server.saveparams = <span class="literal">NULL</span>;</span><br><span class="line">    server.loading = <span class="number">0</span>;</span><br><span class="line">    server.logfile = zstrdup(REDIS_DEFAULT_LOGFILE);</span><br><span class="line">    server.syslog_enabled = REDIS_DEFAULT_SYSLOG_ENABLED;</span><br><span class="line">    server.syslog_ident = zstrdup(REDIS_DEFAULT_SYSLOG_IDENT);</span><br><span class="line">    server.syslog_facility = LOG_LOCAL0;</span><br><span class="line">    server.daemonize = REDIS_DEFAULT_DAEMONIZE;</span><br><span class="line">    server.aof_state = REDIS_AOF_OFF;</span><br><span class="line">    server.aof_fsync = REDIS_DEFAULT_AOF_FSYNC;</span><br><span class="line">    server.aof_no_fsync_on_rewrite = REDIS_DEFAULT_AOF_NO_FSYNC_ON_REWRITE;</span><br><span class="line">    server.aof_rewrite_perc = REDIS_AOF_REWRITE_PERC;</span><br><span class="line">    server.aof_rewrite_min_size = REDIS_AOF_REWRITE_MIN_SIZE;</span><br><span class="line">    server.aof_rewrite_base_size = <span class="number">0</span>;</span><br><span class="line">    server.aof_rewrite_scheduled = <span class="number">0</span>;</span><br><span class="line">    server.aof_last_fsync = time(<span class="literal">NULL</span>);</span><br><span class="line">    server.aof_rewrite_time_last = <span class="number">-1</span>;</span><br><span class="line">    server.aof_rewrite_time_start = <span class="number">-1</span>;</span><br><span class="line">    server.aof_lastbgrewrite_status = REDIS_OK;</span><br><span class="line">    server.aof_delayed_fsync = <span class="number">0</span>;</span><br><span class="line">    server.aof_fd = <span class="number">-1</span>;</span><br><span class="line">    server.aof_selected_db = <span class="number">-1</span>; <span class="comment">/* Make sure the first time will not match */</span></span><br><span class="line">    server.aof_flush_postponed_start = <span class="number">0</span>;</span><br><span class="line">    server.aof_rewrite_incremental_fsync = REDIS_DEFAULT_AOF_REWRITE_INCREMENTAL_FSYNC;</span><br><span class="line">    server.pidfile = zstrdup(REDIS_DEFAULT_PID_FILE);</span><br><span class="line">    server.rdb_filename = zstrdup(REDIS_DEFAULT_RDB_FILENAME);</span><br><span class="line">    server.aof_filename = zstrdup(<span class="string">"appendonly.aof"</span>);</span><br><span class="line">    server.requirepass = <span class="literal">NULL</span>;</span><br><span class="line">    server.rdb_compression = REDIS_DEFAULT_RDB_COMPRESSION;</span><br><span class="line">    server.rdb_checksum = REDIS_DEFAULT_RDB_CHECKSUM;</span><br><span class="line">    server.stop_writes_on_bgsave_err = REDIS_DEFAULT_STOP_WRITES_ON_BGSAVE_ERROR;</span><br><span class="line">    server.activerehashing = REDIS_DEFAULT_ACTIVE_REHASHING;</span><br><span class="line">    server.notify_keyspace_events = <span class="number">0</span>;</span><br><span class="line">    server.maxclients = REDIS_MAX_CLIENTS;</span><br><span class="line">    server.bpop_blocked_clients = <span class="number">0</span>;</span><br><span class="line">    server.maxmemory = REDIS_DEFAULT_MAXMEMORY;</span><br><span class="line">    server.maxmemory_policy = REDIS_DEFAULT_MAXMEMORY_POLICY;</span><br><span class="line">    server.maxmemory_samples = REDIS_DEFAULT_MAXMEMORY_SAMPLES;</span><br><span class="line">    server.hash_max_ziplist_entries = REDIS_HASH_MAX_ZIPLIST_ENTRIES;</span><br><span class="line">    server.hash_max_ziplist_value = REDIS_HASH_MAX_ZIPLIST_VALUE;</span><br><span class="line">    server.list_max_ziplist_entries = REDIS_LIST_MAX_ZIPLIST_ENTRIES;</span><br><span class="line">    server.list_max_ziplist_value = REDIS_LIST_MAX_ZIPLIST_VALUE;</span><br><span class="line">    server.set_max_intset_entries = REDIS_SET_MAX_INTSET_ENTRIES;</span><br><span class="line">    server.zset_max_ziplist_entries = REDIS_ZSET_MAX_ZIPLIST_ENTRIES;</span><br><span class="line">    server.zset_max_ziplist_value = REDIS_ZSET_MAX_ZIPLIST_VALUE;</span><br><span class="line">    server.shutdown_asap = <span class="number">0</span>;</span><br><span class="line">    server.repl_ping_slave_period = REDIS_REPL_PING_SLAVE_PERIOD;</span><br><span class="line">    server.repl_timeout = REDIS_REPL_TIMEOUT;</span><br><span class="line">    server.repl_min_slaves_to_write = REDIS_DEFAULT_MIN_SLAVES_TO_WRITE;</span><br><span class="line">    server.repl_min_slaves_max_lag = REDIS_DEFAULT_MIN_SLAVES_MAX_LAG;</span><br><span class="line">    server.lua_caller = <span class="literal">NULL</span>;</span><br><span class="line">    server.lua_time_limit = REDIS_LUA_TIME_LIMIT;</span><br><span class="line">    server.lua_client = <span class="literal">NULL</span>;</span><br><span class="line">    server.lua_timedout = <span class="number">0</span>;</span><br><span class="line">    server.loading_process_events_interval_bytes = (<span class="number">1024</span>*<span class="number">1024</span>*<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    updateLRUClock();</span><br><span class="line">    resetServerSaveParams();</span><br><span class="line"></span><br><span class="line">    appendServerSaveParams(<span class="number">60</span>*<span class="number">60</span>,<span class="number">1</span>);  <span class="comment">/* save after 1 hour and 1 change */</span></span><br><span class="line">    appendServerSaveParams(<span class="number">300</span>,<span class="number">100</span>);  <span class="comment">/* save after 5 minutes and 100 changes */</span></span><br><span class="line">    appendServerSaveParams(<span class="number">60</span>,<span class="number">10000</span>); <span class="comment">/* save after 1 minute and 10000 changes */</span></span><br><span class="line">    <span class="comment">/* Replication related */</span></span><br><span class="line">    server.masterauth = <span class="literal">NULL</span>;</span><br><span class="line">    server.masterhost = <span class="literal">NULL</span>;</span><br><span class="line">    server.masterport = <span class="number">6379</span>;</span><br><span class="line">    server.master = <span class="literal">NULL</span>;</span><br><span class="line">    server.cached_master = <span class="literal">NULL</span>;</span><br><span class="line">    server.repl_master_initial_offset = <span class="number">-1</span>;</span><br><span class="line">    server.repl_state = REDIS_REPL_NONE;</span><br><span class="line">    server.repl_syncio_timeout = REDIS_REPL_SYNCIO_TIMEOUT;</span><br><span class="line">    server.repl_serve_stale_data = REDIS_DEFAULT_SLAVE_SERVE_STALE_DATA;</span><br><span class="line">    server.repl_slave_ro = REDIS_DEFAULT_SLAVE_READ_ONLY;</span><br><span class="line">    server.repl_down_since = <span class="number">0</span>; <span class="comment">/* Never connected, repl is down since EVER. */</span></span><br><span class="line">    server.repl_disable_tcp_nodelay = REDIS_DEFAULT_REPL_DISABLE_TCP_NODELAY;</span><br><span class="line">    server.slave_priority = REDIS_DEFAULT_SLAVE_PRIORITY;</span><br><span class="line">    server.master_repl_offset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Replication partial resync backlog */</span></span><br><span class="line">    server.repl_backlog = <span class="literal">NULL</span>;</span><br><span class="line">    server.repl_backlog_size = REDIS_DEFAULT_REPL_BACKLOG_SIZE;</span><br><span class="line">    server.repl_backlog_histlen = <span class="number">0</span>;</span><br><span class="line">    server.repl_backlog_idx = <span class="number">0</span>;</span><br><span class="line">    server.repl_backlog_off = <span class="number">0</span>;</span><br><span class="line">    server.repl_backlog_time_limit = REDIS_DEFAULT_REPL_BACKLOG_TIME_LIMIT;</span><br><span class="line">    server.repl_no_slaves_since = time(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Client output buffer limits */</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; REDIS_CLIENT_LIMIT_NUM_CLASSES; j++)</span><br><span class="line">        server.client_obuf_limits[j] = clientBufferLimitsDefaults[j];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Double constants initialization */</span></span><br><span class="line">    R_Zero = <span class="number">0.0</span>;</span><br><span class="line">    R_PosInf = <span class="number">1.0</span>/R_Zero;</span><br><span class="line">    R_NegInf = <span class="number">-1.0</span>/R_Zero;</span><br><span class="line">    R_Nan = R_Zero/R_Zero;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Command table -- we initiialize it here as it is part of the</span></span><br><span class="line"><span class="comment">     * initial configuration, since command names may be changed via</span></span><br><span class="line"><span class="comment">     * redis.conf using the rename-command directive. */</span></span><br><span class="line">    server.commands = dictCreate(&amp;commandTableDictType,<span class="literal">NULL</span>);</span><br><span class="line">    server.orig_commands = dictCreate(&amp;commandTableDictType,<span class="literal">NULL</span>);</span><br><span class="line">    populateCommandTable();</span><br><span class="line">    server.delCommand = lookupCommandByCString(<span class="string">"del"</span>);</span><br><span class="line">    server.multiCommand = lookupCommandByCString(<span class="string">"multi"</span>);</span><br><span class="line">    server.lpushCommand = lookupCommandByCString(<span class="string">"lpush"</span>);</span><br><span class="line">    server.lpopCommand = lookupCommandByCString(<span class="string">"lpop"</span>);</span><br><span class="line">    server.rpopCommand = lookupCommandByCString(<span class="string">"rpop"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Slow log */</span></span><br><span class="line">    server.slowlog_log_slower_than = REDIS_SLOWLOG_LOG_SLOWER_THAN;</span><br><span class="line">    server.slowlog_max_len = REDIS_SLOWLOG_MAX_LEN;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Debugging */</span></span><br><span class="line">    server.assert_failed = <span class="string">"&lt;no assertion failed&gt;"</span>;</span><br><span class="line">    server.assert_file = <span class="string">"&lt;no file&gt;"</span>;</span><br><span class="line">    server.assert_line = <span class="number">0</span>;</span><br><span class="line">    server.bug_report_start = <span class="number">0</span>;</span><br><span class="line">    server.watchdog_period = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="initServer"><a href="#initServer" class="headerlink" title="initServer()"></a>initServer()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">    signal(SIGHUP, SIG_IGN);</span><br><span class="line">    signal(SIGPIPE, SIG_IGN);</span><br><span class="line">    setupSignalHandlers();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (server.syslog_enabled) &#123;</span><br><span class="line">        openlog(server.syslog_ident, LOG_PID | LOG_NDELAY | LOG_NOWAIT,</span><br><span class="line">            server.syslog_facility);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server.current_client = <span class="literal">NULL</span>;</span><br><span class="line">    server.clients = listCreate();</span><br><span class="line">    server.clients_to_close = listCreate();</span><br><span class="line">    server.slaves = listCreate();</span><br><span class="line">    server.monitors = listCreate();</span><br><span class="line">    server.slaveseldb = <span class="number">-1</span>; <span class="comment">/* Force to emit the first SELECT command. */</span></span><br><span class="line">    server.unblocked_clients = listCreate();</span><br><span class="line">    server.ready_keys = listCreate();</span><br><span class="line"></span><br><span class="line">    createSharedObjects();</span><br><span class="line">    adjustOpenFilesLimit();</span><br><span class="line">    server.el = aeCreateEventLoop(server.maxclients+REDIS_EVENTLOOP_FDSET_INCR);</span><br><span class="line">    server.db = zmalloc(<span class="keyword">sizeof</span>(redisDb)*server.dbnum);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Open the TCP listening socket for the user commands. */</span></span><br><span class="line">    <span class="keyword">if</span> (listenToPort(server.port,server.ipfd,&amp;server.ipfd_count) == REDIS_ERR)</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Open the listening Unix domain socket. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.unixsocket != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        unlink(server.unixsocket); <span class="comment">/* don't care if this fails */</span></span><br><span class="line">        server.sofd = anetUnixServer(server.neterr,server.unixsocket,server.unixsocketperm);</span><br><span class="line">        <span class="keyword">if</span> (server.sofd == ANET_ERR) &#123;</span><br><span class="line">            redisLog(REDIS_WARNING, <span class="string">"Opening socket: %s"</span>, server.neterr);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Abort if there are no listening sockets at all. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.ipfd_count == <span class="number">0</span> &amp;&amp; server.sofd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        redisLog(REDIS_WARNING, <span class="string">"Configured to not listen anywhere, exiting."</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Create the Redis databases, and initialize other internal state. */</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; server.dbnum; j++) &#123;</span><br><span class="line">        server.db[j].dict = dictCreate(&amp;dbDictType,<span class="literal">NULL</span>);</span><br><span class="line">        server.db[j].expires = dictCreate(&amp;keyptrDictType,<span class="literal">NULL</span>);</span><br><span class="line">        server.db[j].blocking_keys = dictCreate(&amp;keylistDictType,<span class="literal">NULL</span>);</span><br><span class="line">        server.db[j].ready_keys = dictCreate(&amp;setDictType,<span class="literal">NULL</span>);</span><br><span class="line">        server.db[j].watched_keys = dictCreate(&amp;keylistDictType,<span class="literal">NULL</span>);</span><br><span class="line">        server.db[j].id = j;</span><br><span class="line">        server.db[j].avg_ttl = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    server.pubsub_channels = dictCreate(&amp;keylistDictType,<span class="literal">NULL</span>);</span><br><span class="line">    server.pubsub_patterns = listCreate();</span><br><span class="line">    listSetFreeMethod(server.pubsub_patterns,freePubsubPattern);</span><br><span class="line">    listSetMatchMethod(server.pubsub_patterns,listMatchPubsubPattern);</span><br><span class="line">    server.cronloops = <span class="number">0</span>;</span><br><span class="line">    server.rdb_child_pid = <span class="number">-1</span>;</span><br><span class="line">    server.aof_child_pid = <span class="number">-1</span>;</span><br><span class="line">    aofRewriteBufferReset();</span><br><span class="line">    server.aof_buf = sdsempty();</span><br><span class="line">    server.lastsave = time(<span class="literal">NULL</span>); <span class="comment">/* At startup we consider the DB saved. */</span></span><br><span class="line">    server.lastbgsave_try = <span class="number">0</span>;    <span class="comment">/* At startup we never tried to BGSAVE. */</span></span><br><span class="line">    server.rdb_save_time_last = <span class="number">-1</span>;</span><br><span class="line">    server.rdb_save_time_start = <span class="number">-1</span>;</span><br><span class="line">    server.dirty = <span class="number">0</span>;</span><br><span class="line">    server.stat_numcommands = <span class="number">0</span>;</span><br><span class="line">    server.stat_numconnections = <span class="number">0</span>;</span><br><span class="line">    server.stat_expiredkeys = <span class="number">0</span>;</span><br><span class="line">    server.stat_evictedkeys = <span class="number">0</span>;</span><br><span class="line">    server.stat_starttime = time(<span class="literal">NULL</span>);</span><br><span class="line">    server.stat_keyspace_misses = <span class="number">0</span>;</span><br><span class="line">    server.stat_keyspace_hits = <span class="number">0</span>;</span><br><span class="line">    server.stat_peak_memory = <span class="number">0</span>;</span><br><span class="line">    server.stat_fork_time = <span class="number">0</span>;</span><br><span class="line">    server.stat_rejected_conn = <span class="number">0</span>;</span><br><span class="line">    server.stat_sync_full = <span class="number">0</span>;</span><br><span class="line">    server.stat_sync_partial_ok = <span class="number">0</span>;</span><br><span class="line">    server.stat_sync_partial_err = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(server.ops_sec_samples,<span class="number">0</span>,<span class="keyword">sizeof</span>(server.ops_sec_samples));</span><br><span class="line">    server.ops_sec_idx = <span class="number">0</span>;</span><br><span class="line">    server.ops_sec_last_sample_time = mstime();</span><br><span class="line">    server.ops_sec_last_sample_ops = <span class="number">0</span>;</span><br><span class="line">    server.unixtime = time(<span class="literal">NULL</span>);</span><br><span class="line">    server.mstime = mstime();</span><br><span class="line">    server.lastbgsave_status = REDIS_OK;</span><br><span class="line">    server.repl_good_slaves_count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Create the serverCron() time event, that's our main way to process</span></span><br><span class="line"><span class="comment">     * background operations. */</span></span><br><span class="line">    <span class="keyword">if</span>(aeCreateTimeEvent(server.el, <span class="number">1</span>, serverCron, <span class="literal">NULL</span>, <span class="literal">NULL</span>) == AE_ERR) &#123;</span><br><span class="line">        redisPanic(<span class="string">"Can't create the serverCron time event."</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Create an event handler for accepting new connections in TCP and Unix</span></span><br><span class="line"><span class="comment">     * domain sockets. */</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; server.ipfd_count; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (aeCreateFileEvent(server.el, server.ipfd[j], AE_READABLE,</span><br><span class="line">            acceptTcpHandler,<span class="literal">NULL</span>) == AE_ERR)</span><br><span class="line">            &#123;</span><br><span class="line">                redisPanic(</span><br><span class="line">                    <span class="string">"Unrecoverable error creating server.ipfd file event."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (server.sofd &gt; <span class="number">0</span> &amp;&amp; aeCreateFileEvent(server.el,server.sofd,AE_READABLE,</span><br><span class="line">        acceptUnixHandler,<span class="literal">NULL</span>) == AE_ERR) redisPanic(<span class="string">"Unrecoverable error creating server.sofd file event."</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Open the AOF file if needed. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.aof_state == REDIS_AOF_ON) &#123;</span><br><span class="line">        server.aof_fd = open(server.aof_filename,</span><br><span class="line">                               O_WRONLY|O_APPEND|O_CREAT,<span class="number">0644</span>);</span><br><span class="line">        <span class="keyword">if</span> (server.aof_fd == <span class="number">-1</span>) &#123;</span><br><span class="line">            redisLog(REDIS_WARNING, <span class="string">"Can't open the append-only file: %s"</span>,</span><br><span class="line">                strerror(errno));</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 32 bit instances are limited to 4GB of address space, so if there is</span></span><br><span class="line"><span class="comment">     * no explicit limit in the user provided configuration we set a limit</span></span><br><span class="line"><span class="comment">     * at 3 GB using maxmemory with 'noeviction' policy'. This avoids</span></span><br><span class="line"><span class="comment">     * useless crashes of the Redis instance for out of memory. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.arch_bits == <span class="number">32</span> &amp;&amp; server.maxmemory == <span class="number">0</span>) &#123;</span><br><span class="line">        redisLog(REDIS_WARNING,<span class="string">"Warning: 32 bit instance detected but no memory limit set. Setting 3 GB maxmemory limit with 'noeviction' policy now."</span>);</span><br><span class="line">        server.maxmemory = <span class="number">3072L</span>L*(<span class="number">1024</span>*<span class="number">1024</span>); <span class="comment">/* 3 GB */</span></span><br><span class="line">        server.maxmemory_policy = REDIS_MAXMEMORY_NO_EVICTION;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    replicationScriptCacheInit();</span><br><span class="line">    scriptingInit();</span><br><span class="line">    slowlogInit();</span><br><span class="line">    bioInit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="redis数据库创建"><a href="#redis数据库创建" class="headerlink" title="redis数据库创建"></a>redis数据库创建</h3><h4 id="核心结构体redisDb"><a href="#核心结构体redisDb" class="headerlink" title="核心结构体redisDb"></a>核心结构体redisDb</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span></span><br><span class="line">    dict *dict;                 <span class="comment">/* The keyspace for this DB */</span></span><br><span class="line">    dict *expires;              <span class="comment">/* Timeout of keys with a timeout set */</span></span><br><span class="line">    dict *blocking_keys;        <span class="comment">/* Keys with clients waiting for data (BLPOP) */</span></span><br><span class="line">    dict *ready_keys;           <span class="comment">/* Blocked keys that received a PUSH */</span></span><br><span class="line">    dict *watched_keys;         <span class="comment">/* WATCHED keys for MULTI/EXEC CAS */</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> avg_ttl;          <span class="comment">/* Average TTL, just for stats */</span></span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure>
<h4 id="创建流程"><a href="#创建流程" class="headerlink" title="创建流程"></a>创建流程</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_DEFAULT_DBNUM     16</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initServerConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">    server.dbnum = REDIS_DEFAULT_DBNUM;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果是配置文件里设置了数据库的数目,如<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Set the number of databases. The default database is DB 0, you can select</span></span><br><span class="line"><span class="comment"># a different one on a per-connection basis using SELECT &lt;dbid&gt; where</span></span><br><span class="line"><span class="comment"># dbid is a number between 0 and 'databases'-1</span></span><br><span class="line">databases 16</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//把文件配置信息读入内存</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loadServerConfig</span><span class="params">(<span class="keyword">char</span> *filename, <span class="keyword">char</span> *options)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">loadServerConfigFromString(config);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//解析配置信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loadServerConfigFromString</span><span class="params">(<span class="keyword">char</span> *config)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(argv[<span class="number">0</span>],<span class="string">"databases"</span>) &amp;&amp; argc == <span class="number">2</span>) &#123;</span><br><span class="line">            server.dbnum = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span> (server.dbnum &lt; <span class="number">1</span>) &#123;</span><br><span class="line">                err = <span class="string">"Invalid number of databases"</span>; <span class="keyword">goto</span> loaderr;</span><br><span class="line">            &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">            </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">    server.db = zmalloc(<span class="keyword">sizeof</span>(redisDb)*server.dbnum);</span><br><span class="line">...</span><br><span class="line">    <span class="comment">/* Create the Redis databases, and initialize other internal state. */</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; server.dbnum; j++) &#123;</span><br><span class="line">        server.db[j].dict = dictCreate(&amp;dbDictType,<span class="literal">NULL</span>);</span><br><span class="line">        server.db[j].expires = dictCreate(&amp;keyptrDictType,<span class="literal">NULL</span>);</span><br><span class="line">        server.db[j].blocking_keys = dictCreate(&amp;keylistDictType,<span class="literal">NULL</span>);</span><br><span class="line">        server.db[j].ready_keys = dictCreate(&amp;setDictType,<span class="literal">NULL</span>);</span><br><span class="line">        server.db[j].watched_keys = dictCreate(&amp;keylistDictType,<span class="literal">NULL</span>);</span><br><span class="line">        server.db[j].id = j;</span><br><span class="line">        server.db[j].avg_ttl = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="切换数据库"><a href="#切换数据库" class="headerlink" title="切换数据库"></a>切换数据库</h4><p>SELECT命令调用selectCommand, 有效值显然是[0, server.dbnum-1]<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">selectDb</span><span class="params">(redisClient *c, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (id &lt; <span class="number">0</span> || id &gt;= server.dbnum)</span><br><span class="line">        <span class="keyword">return</span> REDIS_ERR;</span><br><span class="line">    c-&gt;db = &amp;server.db[id];</span><br><span class="line">    <span class="keyword">return</span> REDIS_OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// SELECT命令调用selectCommand</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (getLongFromObjectOrReply(c, c-&gt;argv[<span class="number">1</span>], &amp;id,</span><br><span class="line">        <span class="string">"invalid DB index"</span>) != REDIS_OK)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (selectDb(c,id) == REDIS_ERR) &#123;</span><br><span class="line">        addReplyError(c,<span class="string">"invalid DB index"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        addReply(c,shared.ok);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://mojiajun.github.io/post/22230d9.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mojiajun">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mojiajun">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/post/22230d9.html" itemprop="url">ffmpeg-AVBuffer-AVBufferRef-源码阅读</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-03T00:00:00+08:00">
                2018-12-03
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/源码阅读/" itemprop="url" rel="index">
                    <span itemprop="name">源码阅读</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/源码阅读/ffmpeg/" itemprop="url" rel="index">
                    <span itemprop="name">ffmpeg</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>FFMPEG-AVBuffer-AVBufferRef-源码阅读</p>
<p>参考了<a href="https://www.cnblogs.com/tocy/p/ffmpeg-libavutil-avbuffer-imp.html" target="_blank" rel="noopener">ffmpeg中AVBuffer的实现分析</a></p>
<p>下面这个分析的更好.<a href="https://blog.csdn.net/muyuyuzhong/article/details/79381152" target="_blank" rel="noopener">深入理解FFMPEG-AVBuffer/AVBufferRef/AVBufferPool</a></p>
<p>主要实现文件位于libavutil中的buffer.h、buffer_internal.h、buffer.c三个文件中。其中最主要的是两个结构<strong>AVBufferRef</strong>和<strong>AVBuffer</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">libavutil/buffer_internal.h</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AVBuffer</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> *data; <span class="comment">/**&lt; data described by this buffer */</span></span><br><span class="line">    <span class="keyword">int</span>      size; <span class="comment">/**&lt; size of data in bytes */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  number of existing AVBufferRef instances referring to this buffer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">atomic_uint</span> refcount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * a callback for freeing the data</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> (*<span class="built_in">free</span>)(<span class="keyword">void</span> *opaque, <span class="keyword">uint8_t</span> *data);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * an opaque pointer, to be used by the freeing callback</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> *opaque;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A combination of BUFFER_FLAG_*</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> flags;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AVBufferRef</span> &#123;</span></span><br><span class="line">    AVBuffer *buffer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The data buffer. It is considered writable if and only if</span></span><br><span class="line"><span class="comment">     * this is the only reference to the buffer, in which case</span></span><br><span class="line"><span class="comment">     * av_buffer_is_writable() returns 1.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> *data;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Size of data in bytes.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span>      size;</span><br><span class="line">&#125; AVBufferRef;</span><br></pre></td></tr></table></figure>
<p>外部使用最好是通过AVBufferRef来引用数据.不然就丧失了这个设计的意义.(能保障当引用计数等于0时自动释放指定内存区域.)</p>
<p>av_buffer_alloc()</p>
<blockquote>
<p>调用了av_buffer_create()..把AVBufferRef和AVBuffer的data和size设成了一样的值</p>
<p>调用完成后返回一个AVBufferRef指针.<br>三次分配内存,1.实际数据存放的data指针,2.AVBufferRef结构体,3.AVBuffer结构体。</p>
</blockquote>
<p>av_buffer_allocz()只是在av_buffer_alloc()基础上加了一个把实际的数据域data初始化为0的过程.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">AVBufferRef *<span class="title">av_buffer_ref</span><span class="params">(AVBufferRef *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVBufferRef *ret = av_mallocz(<span class="keyword">sizeof</span>(*ret));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ret)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    *ret = *buf;</span><br><span class="line"></span><br><span class="line">    atomic_fetch_add_explicit(&amp;buf-&gt;buffer-&gt;refcount, <span class="number">1</span>, memory_order_relaxed);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>av_buffer_ref()给AVBufferRef *buf创建一份AVBufferRef结构体的copy,然后返回这个AVBufferRef.但是没有拷贝底层数据,只是把原来的引用计数用原子操作加一.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buffer_replace</span><span class="params">(AVBufferRef **dst, AVBufferRef **src)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVBuffer *b;</span><br><span class="line"></span><br><span class="line">    b = (*dst)-&gt;buffer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (src) &#123;</span><br><span class="line">        **dst = **src;</span><br><span class="line">        av_freep(src);</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        av_freep(dst);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (atomic_fetch_add_explicit(&amp;b-&gt;refcount, <span class="number">-1</span>, memory_order_acq_rel) == <span class="number">1</span>) &#123;</span><br><span class="line">        b-&gt;<span class="built_in">free</span>(b-&gt;opaque, b-&gt;data);</span><br><span class="line">        av_freep(&amp;b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">	这个buffer_replace是一个实现函数,只能在buffer.c内部使用.(加了<span class="keyword">static</span>)</span><br><span class="line">	功能如其名,让**dst被**src取代,这是结构体本身的直接赋值(覆盖).分两种情况:一,如果src是<span class="literal">NULL</span>,那么直接把AVBufferRef **dst这个结构体释放掉;二,如果src这个二级指针不为空,那么就完成替换操作,同时释放掉src.</span><br><span class="line"> 	不管哪种情况,dst里面管理的AVBuffer里面的refcount都要减一,如果满足合适条件(这个条件没看懂,是减一后判断引用计数是不是等于<span class="number">1</span>?),就释放掉AVBuffer和buf.也就是释放掉AVBufferRef这个类似于智能指针底下管理的数据.</span><br><span class="line">    类似C++的智能指针.但是又有区别,从右到左的赋值没有增加右边的引用计数,反而把右边的释放了,正如replace含义.</span><br><span class="line">PS:</span><br><span class="line"><span class="number">1.</span>查阅文档,发现atomic_fetch_add_explicit()返回的是计算前的值,所以这里==<span class="number">1</span>也就不奇怪了.</span><br><span class="line">The value held previously be the atomic object pointed to by obj.</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void av_buffer_unref(AVBufferRef **buf)调用了buffer_replace(buf, NULL),也就是把buf直接释放掉了,只要调用buffer_replace()就会把引用计数减一,然后检测底层数据的引用数.如果没有被引用了,就把底层数据释放掉.</span><br><span class="line"></span><br><span class="line">av_buffer_ref()</span><br><span class="line">av_buffer_unref()这两函数操作的都是AVBufferRef,一个创建AVBufferRef,一个销毁AVBufferRef,要不要操作底层数据会根据引用计数自行判断.</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">av_buffer_is_writable</span><span class="params">(<span class="keyword">const</span> AVBufferRef *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (buf-&gt;buffer-&gt;flags &amp; AV_BUFFER_FLAG_READONLY)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> atomic_load(&amp;buf-&gt;buffer-&gt;refcount) == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">buffer要可写必须前提是flags不能是AV_BUFFER_FLAG_READONLY,然后引用计数必须是<span class="number">1.</span>也即是当前只有一个AVBufferRef在引用这块buffer,才处于可写状态.</span><br><span class="line">av_buffer_make_writable(AVBufferRef **pbuf)这个就另外建立了一套新的引用计数系统,当然计数为<span class="number">1.</span>把原来的pbuf里面的引用计数减一.</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">av_buffer_make_writable</span><span class="params">(AVBufferRef **pbuf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVBufferRef *newbuf, *buf = *pbuf;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (av_buffer_is_writable(buf))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    newbuf = av_buffer_alloc(buf-&gt;size);<span class="comment">//分配三个东西(1.实际数据存放的data指针,2.AVBufferRef结构体,3.AVBuffer结构体。)的内存.创建一套新的引用计数系统.</span></span><br><span class="line">    <span class="keyword">if</span> (!newbuf)</span><br><span class="line">        <span class="keyword">return</span> AVERROR(ENOMEM);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(newbuf-&gt;data, buf-&gt;data, buf-&gt;size);<span class="comment">//把原来的buf-&gt;data拷贝到newbuf-&gt;data.</span></span><br><span class="line"></span><br><span class="line">    buffer_replace(pbuf, &amp;newbuf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">可以通过av_buffer_make_writable()来让其可写，该函数内部内部自动创建一个新的数据缓冲区，并且原来的AVBuffer引用计数<span class="number">-1.</span></span><br></pre></td></tr></table></figure>
<p>AVBufferPool还没分析.</p>
<p>然后这几个函数在哪被用到了还没看</p>
<p>libavutil/frame.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AVFrame</span><br><span class="line">av_frame_ref()</span><br><span class="line">av_frame_unref()</span><br></pre></td></tr></table></figure>
<p>libavcodec/avpacket.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AVPacket</span><br><span class="line">av_packet_ref()</span><br><span class="line">av_packet_unref()</span><br></pre></td></tr></table></figure>
<p>参考文献:<br>1.<a href="https://www.cnblogs.com/tocy/p/ffmpeg-libavutil-avbuffer-imp.html" target="_blank" rel="noopener">ffmpeg中AVBuffer的实现分析</a></p>
<p>2.<a href="https://blog.csdn.net/muyuyuzhong/article/details/79381152" target="_blank" rel="noopener">深入理解FFMPEG-AVBuffer/AVBufferRef/AVBufferPool</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">mojiajun</p>
              <p class="site-description motion-element" itemprop="description">莫佳骏学习笔记</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">16</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">mojiajun</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>








        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
